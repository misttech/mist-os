# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Definitions to build each of the Fuchsia IDKs.

import("//build/bazel/bazel_fuchsia_sdk.gni")
import("//build/config/build_api_module.gni")
import("//build/config/fuchsia/platform_version.gni")
import("//build/config/fuchsia/target_api_level.gni")
import("//build/dart/toolchain.gni")
import("//build/fidl/toolchain.gni")
import("//build/sdk/config.gni")
import("//build/sdk/idk.gni")
import("//build/sdk/idk_archive.gni")
import("//build/sdk/idk_subbuilds.gni")
import("//build/sdk/sdk_collection.gni")
import("//build/sdk/sdk_documentation.gni")
import("//build/sdk/sdk_final_manifest_golden.gni")
import("//build/sdk/sdk_molecule.gni")
import("//build/sdk/sdk_version_history.gni")
import("//tools/check-licenses/build/license_data.gni")
import("config.gni")

visibility = [ ":*" ]

# There is currently no need to build the IDK with a toolchain other than
# `default_toolchain`. The following assert prevents accidentally adding
# dependencies that cause this file and the many SDK-specific rules to be
# processed in other toolchains.
# None of the targets are binaries that would have variants applied.
# Additional host toolchains will process this file when cross-compiling tools.
assert(current_toolchain == default_toolchain ||
           current_toolchain == host_toolchain ||
           (sdk_cross_compile_host_tools && is_host),
       "Unexpected target toolchain `${current_toolchain}`.")

# Log a message if a non-default set of API levels or CPU architecture will be
# built as this reduces the compatibility coverage of the build and should not
# happen in infra. Ensure the messages are only logged once per build.
if (current_toolchain == default_toolchain) {
  if (override_idk_buildable_api_levels != false) {
    print(
        "IDK build supported API levels is overridden: ${platform_version.idk_buildable_api_levels}. Compatibility with other levels cannot be checked.")
  }

  # Ignore default list or an override that exactly matches (including order).
  if (idk_target_cpus != idk_target_cpus_default) {
    print("IDK build only covers a subset of target CPUs: ${idk_target_cpus}.")
  }
}

# Verify that `current_build_target_api_level` is actually supported.
if (current_build_target_api_level != "PLATFORM") {
  _override_is_supported = false
  foreach(supported_level, platform_version.idk_buildable_api_levels) {
    if (supported_level == current_build_target_api_level) {
      _override_is_supported = true
    }
  }

  # TODO(https://fxbug.dev/330709069): We should actually assert this, but doing
  # so breaks some builders that are out of sync with the support levels. We
  # should remove those builders and make this an assertion.
  if (!_override_is_supported) {
    print(
        "`current_build_target_api_level` (${current_build_target_api_level}) is not one of the supported API levels: ${platform_version.idk_buildable_api_levels}")
    print("Attempting to build anyways, but this may not go well...")
  }
}

# Include in the deps of targets that need to ensure that all atoms in the IDK
# that affect API or ABI compatibility are built. This includes FIDL libraries,
# sysroot, and source and prebuilt libraries.
# Note: This will not include code that is excluded from being built in the main
# platform build. Most code built in sub-builds is also built in the main build
# as part of the sub-builds dependency. However, some targets are explicitly
# excluded or different. ":core_packages" is an example.
# Note: The current value is broader than needed to satisfy the description. It
# could be narrowed if we find a way to ensure it does not rot.
_all_idk_atoms_affecting_compatibility = [ ":fuchsia_collection" ]

if (!sdk_inside_sub_build) {
  # This default target depends on the most important atoms built in the main
  # build. To build all atoms built in the main build, build
  # "//sdk:fuchsia_collection", To build everything, build
  # "//sdk:final_fuchsia_idk".
  group("sdk") {
    visibility += [ "//:*" ]

    testonly = true

    public_deps = [ ":in_tree_collection" ]

    deps = [
      # Ensure that the following target is available to build and that a default
      # build, which includes `//sdk` will also create
      # $OUTPUT_DIR/sdk/exported/zircon_sysroot/. See the target for details.
      ":zircon_sysroot",

      # Ensure that the host tools in-tree developers expect are always built
      # in a default build regardless of which IDK is built.
      ":idk_host_tools_collection($host_toolchain)",
    ]

    # Ensure the full IDK collection build is not accidentally a dependency.
    assert_no_deps = [ ":fuchsia_collection" ]
  }
}

# This file contains the list of all source files used in sdk_source_set()
# targets reachable from the Fuchsia IDK. The schema is simply a JSON list,
# where each item is the path to a single source file, relative to the source
# directory. Path are not sorted and appear in order of metadata walk, which is
# unstable.
build_api_module("sdk_source_set_list") {
  visibility += [ "//:*" ]
  testonly = true
  data_keys = [ "sdk_source_set_sources" ]
  deps = _all_idk_atoms_affecting_compatibility
}

if (current_toolchain == default_toolchain) {
  # Generates compatibility testing goldens for FIDL libraries in the IDK.
  # TODO(https://fxbug.dev/324656719): Ensure this covers APIs, libraries, etc.
  # that are not present at all levels, especially "PLATFORM".
  group("generate_compatibility_goldens") {
    visibility += [ "//scripts/versioning:*" ]
    testonly = true
    deps = _all_idk_atoms_affecting_compatibility
  }
}

# Contains the list of all plasa fragment files, which have a dump of the
# public API surfaces.
generated_file("plasa_manifest") {
  visibility += [ "//sdk/ctf/plasa:*" ]
  testonly = true
  data_keys = [ "plasa" ]
  outputs = [ "$root_build_dir/manifest.plasa.json" ]
  output_conversion = "json"
  deps = _all_idk_atoms_affecting_compatibility
}

# Generates, validates, and archive the "final" Fuchsia IDK, including prebuilt
# binaries for several target_cpu architectures and API levels.
group("final_fuchsia_idk") {
  visibility = []
  visibility = [
    "//:ninja_subbuilds",
    "//:sdk_archives",
  ]
  deps = [
    ":final_fuchsia_idk.archive",
    ":final_fuchsia_idk.exported",
    ":final_fuchsia_idk.validation",
  ]
  testonly = true

  # Ensure the non-in-tree IDK does not depend on the legacy "core" target.
  # TODO(https://fxbug.dev/317385989): Remove when deleting "core" target.
  assert_no_deps = [ ":core" ]
}

# Generates a "final" IDK archive, including prebuilt binaries for the
# specified `target_cpus` architectures on all `api_levels`.
template("final_fuchsia_idk_for_cpus_and_levels") {
  assert(defined(invoker.output_name))
  assert(defined(invoker.target_cpus))
  assert(defined(invoker.api_levels))

  idk(target_name) {
    forward_variables_from(invoker,
                           [
                             "api_levels",
                             "output_name",
                             "target_cpus",
                             "testonly",
                           ])
    if (defined(invoker.visibility)) {
      visibility += invoker.visibility
    }

    sdk_collection_label = "//sdk:fuchsia_collection"
    idk_subbuilds_label = "//sdk:fuchsia_collection_subbuilds"
    idk_subbuilds_prefix = "idk_subbuild.fuchsia_collection_for_subbuilds"
  }
}

# Generates the "final" IDK archive, including prebuilt binaries for all
# supported target_cpu architectures on all Supported API levels.
final_fuchsia_idk_for_cpus_and_levels("final_fuchsia_idk.exported") {
  visibility = []
  visibility = [
    ":final_fuchsia_idk",
    ":final_fuchsia_idk.archive",
    ":final_fuchsia_idk.archive.tarmaker",
    ":final_fuchsia_idk_bazel_sdk_tests_arm64",
    ":final_fuchsia_idk_bazel_sdk_tests_riscv64",
    ":final_fuchsia_idk_bazel_sdk_tests_x64",
    ":final_fuchsia_idk_manifest_golden",
    ":final_fuchsia_sdk",
  ]

  output_name = "fuchsia_idk"
  target_cpus = idk_target_cpus
  api_levels = platform_version.idk_buildable_api_levels

  # TODO(https://fxbug.dev/306723826): Deal with the fact that the mac builders
  # are too slow to enable this setting, and therefore the mac IDK won't have
  # per-api-level prebuilts.
  if (host_os == "mac") {
    api_levels = []
  }
}

idk_archive("final_fuchsia_idk.archive") {
  visibility += [ "*" ]
  idk = ":final_fuchsia_idk.exported"
  idk_output_name = "fuchsia_idk"
}

group("final_fuchsia_idk.validation") {
  deps = []
  if (host_os == "linux") {
    deps += [
      # Not everything builds on the mac builders, so not everything shows up in
      # the golden files.
      #
      # TODO(https://fxbug.dev/306723826): Deal with the fact that the mac
      # builders are inconsistent.
      ":final_fuchsia_idk_manifest_golden",

      # Run the Bazel SDK test suite against the final exported directory,
      # TODO(https://fxbug.dev/42075205): Make the Bazel SDK test suite runnable on MacOS!
      ":final_fuchsia_idk_bazel_sdk_tests",
    ]
  }
  testonly = true
}

# This target runs the test suite against each target architecture
# supported by the IDK. Currently, this runs multiple instances of
# the test suite, one per target cpu. This is a dependency of
# //sdk:final_fuchsia_idk.validation.
run_fuchsia_bazel_sdk_tests("final_fuchsia_idk_bazel_sdk_tests") {
  target_cpus = idk_target_cpus
  idk_exported_path = "$root_build_dir/sdk/exported/fuchsia_idk"
  idk_exported_target = "//sdk:final_fuchsia_idk.exported"
}

# This target generates a Fuchsia Bazel SDK directory directly
# from the content of the in-tree IDK. This requires a working Bazel
# workspace, but its output does not depend on the content of the
# @fuchsia_sdk repository used by the platform build.
generate_fuchsia_bazel_sdk("final_fuchsia_sdk") {
  idk_export_target = "//sdk:final_fuchsia_idk.exported"
  idk_export_dir = "$root_build_dir/sdk/exported/fuchsia_idk"
}

# Verify the content of the final_fuchsia_sdk target by running
# the Bazel SDK test suite with it for all supported target cpus.
run_fuchsia_bazel_sdk_tests("final_fuchsia_sdk_tests") {
  target_cpus = idk_target_cpus
  fuchsia_sdk_target = ":final_fuchsia_sdk"

  # NOTE: For now, nothing should depend on the :final_fuchsia_sdk_test
  # target, except //:root_targets. This ensures the target is always
  # defined in the GN graph, but can only be built explicitly.
  visibility = []
  visibility = [ "//:root_targets" ]
}

sdk_final_manifest_golden("final_fuchsia_idk_manifest_golden") {
  golden = "manifests/fuchsia_idk.manifest"
  idk_name = "fuchsia_idk"
  idk_exported_label = ":final_fuchsia_idk.exported"
}

if (!is_host) {
  # Generates a "final" IDK archive, including prebuilt binaries for
  # several target_cpu architectures on all Supported API levels.
  final_fuchsia_idk_for_cpus_and_levels("final_fuchsia_idk_head_only") {
    output_name = "fuchsia_idk_head_only"
    target_cpus = [ target_cpu ]
    api_levels = []  # `PLATFORM` artifacts will be used as `HEAD`

    # TODO(https://fxbug.dev/306723826): Deal with the fact that the mac builders
    # are too slow to enable this setting, and therefore the mac IDK won't have
    # per-api-level prebuilts.
    if (host_os == "mac") {
      api_levels = []
    }
  }

  # Generates an exported "final" SDK that only supports the target CPU
  # architecture and API level `HEAD`.
  generate_fuchsia_bazel_sdk("final_fuchsia_sdk_head_only") {
    idk_export_target = "//sdk:final_fuchsia_idk_head_only"
    idk_export_dir = "$root_build_dir/sdk/exported/fuchsia_idk_head_only"
  }

  # Template defining the targets used to build the  IDK.
  # When the target name is "fuchsia", all atoms will be built. Otherwise,
  # the subset needed for in-tree uses of the IDK will be built.
  template("idk_rules") {
    assert(defined(invoker.atoms_independent_of_api_level_and_cpu_arch))
    assert(defined(invoker.atoms_to_include_in_deprecated_arch_directory))
    assert(defined(invoker.dart_library))
    assert(defined(invoker.docs))
    assert(defined(invoker.docs_dependent_on_fidl))
    assert(defined(invoker.fidl_libraries))
    assert(defined(invoker.host_tests))
    assert(defined(invoker.host_tools))
    assert(defined(invoker.non_sdk_deps_build_tests_for_all_builds))
    assert(defined(invoker.packages))
    assert(defined(invoker.prebuilt_libraries))
    assert(defined(invoker.source_libraries))
    assert(defined(invoker.sysroot))
    assert(defined(invoker.vulkan_layers))

    main_target_name = "${target_name}_collection"

    # The collection that is built by sub-builds. The IDK uses sub-builds
    # for each CPU architecture at all supported API levels and at "PLATFORM"
    # for CPU architectures other than the target CPU.
    # This target will also be built in the main build at "PLATFORM" for the
    # target CPU because the sub-build rule depends on it as a way to trigger
    # sub-builds to rebuild when needed.
    sdk_collection("${main_target_name}_for_subbuilds") {
      visibility = []
      visibility = [
        ":*",  # Required for "${main_target_name}_idk_subbuilds-api*".
        "//:build_only",  # Used to specify the target of the sub-builds.
      ]

      category = "partner"
      id = sdk_id

      # Use the name of the main collection in paths as required to merge the
      # sub-builds.
      name = main_target_name
      if (!sdk_inside_sub_build) {
        # The main build builds the `main_target_name` collection and, as
        # described above, this sub-build collection. Since some output files are
        # based on the collection name rather than the target name, some paths
        # could collide. To avoid this, add a suffix. This is acceptable because
        # the output from that instance of this target is not actually used for
        # anything.
        name += "_for_subbuild_deps"
      }

      deps = [
        # Don't add other sdk_molecules here. Add them to the molecule below.
        ":${main_target_name}.fuchsia_idk_atoms_produced_by_subbuilds",
      ]
    }

    # All atoms to be produced by the sub-builds for inclusion in the IDK.
    #
    # Due to limitations of the build system at the GN/Bazel boundary, this
    # cannot contain testonly atoms. See https://fxbug.dev/42070088.
    # Libraries and packages for use in tests absolutely belong in the IDK, but
    # the `testonly` attribute must be removed before they can be added.
    sdk_molecule(
        "${main_target_name}.fuchsia_idk_atoms_produced_by_subbuilds") {
      category = "partner"

      # Atoms included in the IDK that are not for a specific API level.
      if (current_build_target_api_level == "PLATFORM") {
        deps = [ ":${main_target_name}.fuchsia_idk_atoms_built_only_at_platform_for_each_cpu_arch" ]
      }

      # Atoms included in the IDK for each API level.
      if (current_build_target_api_level != "PLATFORM") {
        deps = [ ":${main_target_name}.fuchsia_idk_atoms_for_each_api_level" ]
      } else if (!sdk_inside_sub_build) {
        # Add non-SDK deps in the case of the main build to ensure accurate
        # dependency change checking for the sub-builds. See the comment for
        # "${main_target_name}_for_subbuilds".
        non_sdk_deps = [
          # While atoms included in the IDK only at specific API levels should not
          # be built or included at PLATFORM, the main build must have a deps.
          ":${main_target_name}.fuchsia_idk_atoms_for_each_api_level",

          # Though the FIDL artifacts are not produced by sub-builds, changes to
          # the FIDL files could affect sub-builds. Take a dependency here in the
          # main build so that changes to FIDL files in the IDK will cause the
          # sub-builds to be re-evaluated. This is relevant in cases where FIDL
          # files are modified in ways that affect individual API levels but not
          # the output when fidlc is targeting "PLATFORM".
          "//sdk/fidl",
        ]
      }
    }

    # Prebuilt libraries and packages that are built exclusively for the API
    # levels that SDK users can target (not "PLATFORM").
    # Note: This target can be built at "PLATFORM" as required by the sub-build
    # infrastructure.
    sdk_molecule("${main_target_name}.fuchsia_idk_atoms_for_each_api_level") {
      category = "partner"

      # This target should only be built at PLATFORM as part of sub-build deps.
      visibility = []
      visibility = [
        # Dependencies related to template sub-targets.
        ":${main_target_name}.fuchsia_idk_atoms_for_each_api_level",
        ":${main_target_name}.fuchsia_idk_atoms_for_each_api_level.validate",
      ]
      if (current_build_target_api_level != "PLATFORM" ||
          !sdk_inside_sub_build) {
        visibility += [ ":${main_target_name}.fuchsia_idk_atoms_produced_by_subbuilds.manifest" ]
      }

      non_sdk_deps = invoker.non_sdk_deps_build_tests_for_all_builds
      deps = invoker.prebuilt_libraries + invoker.sysroot

      # SDK packages cannot be built at "PLATFORM". This only affects the
      # sub-build deps.
      # TODO(https://fxbug.dev/347094435): Make it possible to cover the
      # SDK package deps and remove this condition.
      if (current_build_target_api_level != "PLATFORM") {
        deps += invoker.packages
      } else {
        not_needed(invoker, [ "packages" ])
      }
    }

    if (current_build_target_api_level == "PLATFORM" ||
        # Handle core.x64-sdk_source_sets_and_shlibs-apiXX-build_only builders.
        # TODO(https://fxbug.dev/42082833): Remove this.
        override_target_api_level != false) {
      # These rules are processed at least once for the primary target CPU,
      # which may not match the host_cpu. They may also be processed for
      # additional CPU architectures when building the IDK.
      sdk_molecule(
          "${main_target_name}.fuchsia_idk_atoms_built_only_at_platform_for_each_cpu_arch") {
        category = "partner"

        non_sdk_deps = invoker.non_sdk_deps_build_tests_for_all_builds

        # Do not add more dependencies here. Instead, add new dependencies to
        # :fuchsia_idk_atoms_independent_of_api_level_for_one_cpu_arch,
        # which verifies there are no API level dependencies.

        # Atoms that currently must be generated at "PLATFORM" for backwards
        # compatibility with IDK users that do not yet use per-API-level atoms.
        deps = invoker.atoms_to_include_in_deprecated_arch_directory

        # While the Vulkan layers support being built at individual API levels,
        # the SDK atom is not aware of API levels so each sub-build would be
        # written to the same path in the IDK, clobbering all but one for each
        # CPU architecture.
        # TODO(https://fxbug.dev/327223536): Make an SDK atom for loadable
        # modules that supports is API level-aware and move this to
        # :fuchsia_idk_atoms_for_each_api_level.
        deps += invoker.vulkan_layers
      }

      # The rules below only need to be processed once, during the main build.
      # Since sub-builds change the `target_cpu`, this cannot be used as
      # a condition. While, `host_cpu` does not change in sub-builds, using that
      # would require extra processing and building when it does not match the
      # primary target CPU. Therefore, use `sdk_inside_sub_build`.
      # TODO(https://fxbug.dev/310006516): Once this and
      # https://fxbug.dev/327223536 are addressed sub-builds will never target
      # "PLATFORM" and this logic and GN variable can be removed.
      if (!sdk_inside_sub_build) {
        # The collection for the IDK.
        # This target was historically always named "core".
        # Only built in the main build at "PLATFORM" for the target CPU.
        # Sub-builds build ":${main_target_name}_for_subbuilds" for this same
        # collection.
        # Note: idk() expects the collection's manifest to be its target name.
        # Hence the short name of this target.
        sdk_collection(main_target_name) {
          visibility = []
          visibility = invoker.visibility

          category = "partner"
          id = sdk_id

          deps = [
            # Don't add other sdk_molecules here. Add them to the molecule below.
            ":${main_target_name}.fuchsia_idk_atoms_produced_by_main_platform_build",
          ]
        }

        # The sub-builds.
        # Note that the variants (prefixes) do NOT share an output directory
        # because this would require plumbing through a stamp file override and,
        # more significantly, require adding complexity to support
        # //build/scripts/ninjatrace2json.py.
        # This should be okay since it should be rare that both variants are built.
        idk_subbuilds("${main_target_name}_subbuilds") {
          visibility = []
          visibility = invoker.subbuilds_visibility

          sdk_collection_label = ":${main_target_name}_for_subbuilds"
          subbuild_prefix = "idk_subbuild.${main_target_name}_for_subbuilds"

          # Use the same name as the collection so paths match.
          sdk_collection_name = main_target_name
        }

        # All atoms to be produced by the main build for inclusion in the IDK.
        #
        # Due to limitations of the build system at the GN/Bazel boundary, this
        # cannot contain testonly atoms. See https://fxbug.dev/42070088.
        # Libraries and packages for use in tests absolutely belong in the IDK, but
        # the `testonly` attribute must be removed before they can be added.
        sdk_molecule(
            "${main_target_name}.fuchsia_idk_atoms_produced_by_main_platform_build") {
          category = "partner"
          deps = [
            ":${main_target_name}.fuchsia_idk_atoms_built_in_main_platform_build_only",
            ":${main_target_name}.fuchsia_idk_atoms_built_only_at_platform_for_each_cpu_arch",
          ]

          # Parts of the in-tree build assume that the "core" manifest exists.
          # Temporarily ensure that manifest is generated by the same in-tree
          # IDK build tree. Use a non_sdk_deps so it is not included in the
          # IDK's manifest. This must be here because idk() and sdk_collection()
          # do not support non_sdk_deps.
          # TODO(https://fxbug.dev/317385989): Burn down these assumptions and
          # remove this dependency.
          if (main_target_name == "in_tree_collection") {
            non_sdk_deps = [ ":core" ]

            # Do not include atoms in core in the prebuild data.
            metadata = {
              idk_atom_prebuild_info_barrier = deps
            }
          }
        }

        sdk_molecule(
            "${main_target_name}.fuchsia_idk_atoms_built_in_main_platform_build_only") {
          # This molecule is a subset of the target above for organization only
          # and should thus not be used elsewhere.
          visibility = []
          visibility = [
            ":${main_target_name}.fuchsia_idk_atoms_produced_by_main_platform_build.manifest",

            # Dependencies related to template sub-targets.
            ":${main_target_name}.fuchsia_idk_atoms_built_in_main_platform_build_only",
            ":${main_target_name}.fuchsia_idk_atoms_built_in_main_platform_build_only.validate",
          ]
          category = "partner"

          deps = [
            ":${main_target_name}.fuchsia_idk_atoms_built_only_at_platform_for_one_cpu_arch",
            ":${main_target_name}.fuchsia_idk_atoms_independent_of_api_level_for_one_cpu_arch",
          ]
          deps += invoker.host_tools + invoker.host_tests
        }

        # Do not add dependencies to this target without a really good reason.
        # Most such dependencies should be verifiably independent of the API level
        # and (not verifiable) CPU architecture (add to
        # :fuchsia_idk_atoms_independent_of_api_level_for_one_cpu_arch).
        #
        # IDK atoms that must be built at "PLATFORM" but only once (for one CPU
        # architecture).
        # The resulting artifacts should be independent of the CPU architecture,
        # though that cannot be enforced.
        sdk_molecule(
            "${main_target_name}.fuchsia_idk_atoms_built_only_at_platform_for_one_cpu_arch") {
          category = "partner"

          deps =
              # This target contains atoms that depend on FIDL libraries, but it
              # does not build the underlying libraries.
              invoker.source_libraries +
              # This target compiles the FIDL files, but the output used in the IDK
              # is not specific to any API level or CPU architecture.
              invoker.fidl_libraries +
              # Some generated documentation depends on FIDL and thus cannot be in
              # :fuchsia_idk_atoms_independent_of_api_level_for_one_cpu_arch_...
              invoker.docs_dependent_on_fidl
        }

        # IDK atoms that are independent of a specific API level and only need to
        # be built once (for one CPU architecture).
        # The former is enforced (as much as practical) by an assert_no_deps.
        # The resulting artifacts should be independent of the CPU architecture,
        # though that cannot be enforced. The target CPU architecture is used.
        sdk_molecule(
            "${main_target_name}.fuchsia_idk_atoms_independent_of_api_level_for_one_cpu_arch") {
          category = "partner"

          # The following serve as a proxy for the building of FIDL files. A
          # dependency on these suggests that there is a dependency on FIDL
          # interface(s), which would likely mean that the code must be built at
          # each API level and should be in a different molecule.
          assert_no_deps = [
            "//tools/fidl/fidl_api_diff:host",
            "//tools/fidl/fidl_api_summarize:fidl_api_summarize($host_toolchain)",
            "//tools/fidl/fidlc:fidl-lint.host",
          ]

          deps = invoker.atoms_independent_of_api_level_and_cpu_arch +
                 invoker.dart_library + invoker.docs
        }
      } else {
        not_needed(invoker, [])
      }  # end if (!sdk_inside_sub_build)
    } else {
      not_needed(invoker,
                 [
                   "atoms_to_include_in_deprecated_arch_directory",
                   "vulkan_layers",
                 ])
    }  # end if (current_build_target_api_level == "PLATFORM")

    if (sdk_inside_sub_build) {
      not_needed(invoker,
                 [
                   "atoms_independent_of_api_level_and_cpu_arch",
                   "dart_library",
                   "docs",
                   "docs_dependent_on_fidl",
                   "fidl_libraries",
                   "host_tests",
                   "host_tools",
                   "source_libraries",
                   "subbuilds_visibility",
                 ])
    }
  }  # end template

  # Instantiate the target rules for the complete external IDK and the in-tree
  # IDK used by the in-tree Bazel SDK.

  _common_non_sdk_deps_build_tests_for_all_builds = [
    # Successfully building at each API level, including PLATFORM, is the test.
    "//zircon/system:availability_test",
  ]

  _common_atoms_independent_of_api_level_and_cpu_arch = [
    ":core_bindlib",
    ":core_data",
    ":version_history_sdk($default_toolchain)",
  ]
  _common_fidl_libraries = [ "//sdk/fidl" ]
  _common_prebuilt_libraries = [ ":core_cc_prebuilt_libraries" ]
  _common_source_libraries = [ ":core_cc_source_libraries" ]
  _common_sysroot = [ ":core_sysroot" ]

  # The Fuchsia IDK that is distributed to out-of-tree developers.
  idk_rules("fuchsia") {
    visibility = []
    visibility = [
      ":exported_collection_for_tool_goldens",
      ":final_fuchsia_idk.exported",
      ":final_fuchsia_idk_head_only",
      ":generate_compatibility_goldens",
      ":plasa_manifest",
      ":sdk_source_set_list",
      "//build/bazel/licenses:all_bazel_inputs",
    ]
    subbuilds_visibility = [ ":final_fuchsia_idk.exported" ]

    non_sdk_deps_build_tests_for_all_builds =
        _common_non_sdk_deps_build_tests_for_all_builds

    atoms_independent_of_api_level_and_cpu_arch =
        _common_atoms_independent_of_api_level_and_cpu_arch

    fidl_libraries = _common_fidl_libraries
    prebuilt_libraries = _common_prebuilt_libraries
    source_libraries = _common_source_libraries
    sysroot = _common_sysroot

    dart_library = [ ":core_dart_library" ]
    packages = [ ":core_packages" ]
    vulkan_layers = [ "//src/lib/vulkan:vulkan_layers" ]

    docs = [
      ":core_licenses",
      "//sdk/docs",
    ]
    docs_dependent_on_fidl = [ "//tools/docsgen:ref_docs_sdk" ]

    host_tests = [
      # These host tests are (currently) unversioned and only need to be
      # built once.
      # TODO(https://fxbug.dev/330373943): Move once tests are versioned.
      ":fuchsia_idk_atoms_host_tests",
    ]

    host_tools = [
      # IDK atoms that are host tools. They must currently support all
      # Supported API levels and thus only need to be built once.
      # TODO(https://fxbug.dev/349889250): Move host tools to
      # :fuchsia_idk_atoms_at_platform_for_host_cpu_arch_only and/or
      # :fuchsia_idk_atoms_for_each_api_level as appropriate.
      ":host_tools_for_configured_host_cpus",
    ]

    # TODO(https://fxbug.dev/310006516): Remove these once the Bazel SDK and all
    # out-of-tree IDK users are using the per-API-level artifacts.
    # Note that they will still be built at PLATFORM via the sub-builds
    # deps; they just won't be included in the IDK.
    atoms_to_include_in_deprecated_arch_directory = prebuilt_libraries + sysroot
  }

  # The in-tree subset of the IDK that contains only those atoms needed for the
  # in-tree build and SDK.
  idk_rules("in_tree") {
    visibility = []
    visibility = [
      ":bazel_in_tree_idk",
      ":sdk",
      "//:bazel_workspace",
    ]
    subbuilds_visibility = [ ":bazel_in_tree_idk" ]

    non_sdk_deps_build_tests_for_all_builds =
        _common_non_sdk_deps_build_tests_for_all_builds

    atoms_independent_of_api_level_and_cpu_arch =
        _common_atoms_independent_of_api_level_and_cpu_arch

    fidl_libraries = _common_fidl_libraries
    prebuilt_libraries = _common_prebuilt_libraries
    source_libraries = _common_source_libraries
    sysroot = _common_sysroot

    # Not used in-tree.
    dart_library = []

    # The packages are large and not used in-tree.
    packages = []

    # The Vulkan layers are large and not used by the in-tree SDK.
    vulkan_layers = []

    # No need for docs in-tree.
    docs = []
    docs_dependent_on_fidl = []

    # The host tests are not used via the SDK in-tree.
    host_tests = []

    # The minimum set of tools required to support the Bazel SDK.
    host_tools = [
      ":build_host_tools($host_toolchain)",
      ":non_build_host_tools_required_by_bazel_sdk($host_toolchain)",
    ]

    # TODO(https://fxbug.dev/385406226): Exclude these from the in-tree IDK
    # once the Bazel SDK uses artifacts built at HEAD.
    # Note that they will still be built at PLATFORM via the sub-builds
    # deps; they just won't be included in the IDK.
    # For the sysroot, Bazel needs to support the per-level sysroot first -
    # see https://fxbug.dev/385408047.
    atoms_to_include_in_deprecated_arch_directory = prebuilt_libraries + sysroot
  }

  # In-tree, ffx plugins/tools and tests depend on the existence of a
  # collection (not IDK) manifest at "$OUT_DIR/sdk/manifest/core" and/or
  # associated directory at "$OUT_DIR/sdk/exported/core" to determine the
  # location of tools. Create a collection that generates a manifest with the
  # necessary paths.
  # TODO(https://fxbug.dev/317385989): Remove once these legacy dependencies
  # on the internals of the IDK build are eliminated.
  sdk_collection("core") {
    visibility = []
    visibility = [
      ":exported_idk_for_ffx_tests",
      ":in_tree_collection.fuchsia_idk_atoms_produced_by_main_platform_build.manifest",
    ]

    category = "partner"
    id = sdk_id

    deps = [
      # Include all tools in the full IDK and only tools.
      ":host_tools_for_single_toolchain($host_toolchain)",
    ]
  }

  # Builds the appropriate atoms depending on the build type - main build, CPU
  # arch sub-build, and API level sub-build. It selects the deps of
  # "fuchsia_collection" or "fuchsia_collection_for_subbuilds" as appropriate.
  # This is only used by vendor repos, which do not have a separate collection
  # for sub-builds, do not have an internal IDK, and depend on this (indirectly)
  # from their collection.
  #
  # Due to limitations of the build system at the GN/Bazel boundary, this cannot
  # contain testonly atoms. See https://fxbug.dev/42070088. Libraries and
  # packages for use in tests absolutely belong in the IDK, but the `testonly`
  # attribute must be removed before they can be added.
  sdk_molecule("fuchsia_idk_atoms") {
    visibility = []
    visibility += [
      "//vendor/*",

      # Dependencies related to template sub-targets.
      ":fuchsia_idk_atoms",
      ":fuchsia_idk_atoms.validate",
    ]

    category = "partner"

    if (!sdk_inside_sub_build) {
      assert(
          current_build_target_api_level == "PLATFORM" ||
          # Handle core.x64-sdk_source_sets_and_shlibs-apiXX-build_only builders.
          # TODO(https://fxbug.dev/42082833): Remove this.
          override_target_api_level != false)
      deps = [
        ":fuchsia_collection.fuchsia_idk_atoms_produced_by_main_platform_build",
      ]
    } else {
      deps = [ ":fuchsia_collection.fuchsia_idk_atoms_produced_by_subbuilds" ]
    }
  }
}  # end if (!is_host)

sdk_molecule("fuchsia_idk_atoms_host_tests") {
  category = "partner"
  deps = [ ":core_experimental_python_e2e_tests" ]
}

group("tests_no_e2e") {
  visibility += [ "*" ]
  testonly = true
  assert_no_deps = e2e_test_libs

  deps = [
    "//sdk/categories:tests",
    "//sdk/ctf/plasa:tests",
    "//sdk/fidl:tests",
    "//sdk/lib:tests",
    "//sdk/rust:tests",
    "//tools/fidl/abi-compat:check-compatibility",
  ]
}

group("tests") {
  visibility += [ "*" ]
  testonly = true

  deps = [
    ":tests_no_e2e",

    # `testing:tests` contains unit tests for sl4f, which depend on sl4f so it
    # can't live inside `test_no_e2e`.
    "//sdk/testing:tests",
  ]
}

# Version history does not differ by toolchain.
if (current_toolchain == default_toolchain) {
  sdk_version_history("version_history") {
    visibility += [ "*" ]
    id = "sdk://version_history"
    category = "partner"
    source = "version_history.json"
  }
}

# License/rights related information for the SDK.
sdk_documentation("open_source") {
  name = "open_source"

  category = "partner"

  files = []
  foreach(file,
          [
            "AUTHORS",
            "LICENSE",
            "PATENTS",
          ]) {
    files += [
      {
        source = "//$file"
        dest = file
      },
    ]
  }
}

# Licensing information for the 'libc'-style musl library.
sdk_documentation("musl_license") {
  name = "musl_license"

  category = "partner"

  files = [
    {
      source = "//zircon/third_party/ulib/musl/COPYRIGHT"
      dest = "COPYRIGHT.musl"
    },
  ]
}

# Build this target to generate a NOTICE file for the SDK.
# Uncomment the next line, build it, then manually copy the output
# to "//tools/check-licenses/assets/sdk/NOTICE.fuchsia"
# TODO(https://fxbug.dev/42053181): Build the NOTICE file automatically during SDK generation.
#
#license_data("sdk_notice_gen") {
#  target = "//sdk"
#}

# Notice file for all contents in the Fuchsia SDK.
# TODO(https://fxbug.dev/42053181): Replace this with individual notices for each SDK element.
sdk_documentation("sdk_notice") {
  name = "sdk_notice"

  category = "partner"

  files = [
    {
      source = "//tools/check-licenses/assets/sdk/NOTICE.fuchsia"
      dest = "NOTICE.fuchsia"
    },
  ]
}

# A tiny SDK collection used to export the content of the Zircon sysroot
# This is only needed because several other parts of the Fuchsia build
# depend on $OUTPUT_DIR/sdk/exported/zircon_sysroot/ to be available
# and properly populated, see [1] for all details. Also, some third-party repos
# build or reference building this rule [2].
#
# Note that //zircon/public/sysroot_sdk is already
# a transitive dependency of //sdk:in_tree_collection, so using the content of
# $OUTPUT_DIR/sdk/exported/in_tree_collection/ would be equivalent, except that
# this directory is much longer to build (since it contains host tools).
#
# [1] https://cs.opensource.google/search?q=zircon_sysroot&ss=fuchsia%2Ffuchsia
# [2] https://cs.opensource.google/search?q=%22sdk:zircon_sysroot%22&ss=fuchsia%2Ffuchsia
sdk_collection("zircon_sysroot") {
  # This collection is not included in any SDK and could be a standard `group()`
  # except that there are shell scripts that expect
  # `$OUTPUT_DIR/sdk/exported/zircon_sysroot/` to be populated,
  # TODO(https://fxbug.dev/331962496): Find a solution that doesn't depend on
  # sdk_* templates.
  category = "internal"

  deps = [ "//zircon/public/sysroot_sdk" ]
}

if (is_host) {
  # Tools and data used on a host development machine (usually Linux or macOS).
  sdk_molecule("host_tools_for_single_toolchain") {
    category = "partner"
    deps = [
      ":build_host_tools",
      ":non_build_host_tools",
      ":non_build_host_tools_required_by_bazel_sdk",
    ]
  }

  # Tools and data used on a host development machine to interact with a
  # target device running Fuchsia. These are not needed to build the IDK or SDK.
  # Some tools may depend on tools in peer molecules.
  sdk_molecule("non_build_host_tools") {
    category = "partner"
    deps = [
      "//src/developer/debug/zxdb:zxdb_sdk",
      "//src/developer/ffx/plugins/agis:sdk",
      "//src/developer/ffx/plugins/audio:sdk",
      "//src/developer/ffx/plugins/component:sdk",
      "//src/developer/ffx/plugins/coverage:sdk",
      "//src/developer/ffx/plugins/debug:sdk",
      "//src/developer/ffx/plugins/emulator:sdk",
      "//src/developer/ffx/plugins/fuzz:sdk",
      "//src/developer/ffx/plugins/inspect:sdk",
      "//src/developer/ffx/plugins/log:sdk",
      "//src/developer/ffx/plugins/process:sdk",
      "//src/developer/ffx/plugins/profile:sdk",
      "//src/developer/ffx/plugins/repository:sdk",
      "//src/developer/ffx/plugins/session:sdk",
      "//src/developer/ffx/plugins/setui:sdk",
      "//src/developer/ffx/plugins/trace:sdk",
      "//src/developer/ffx/plugins/wlan:sdk",
      "//src/developer/ffx/tools/starnix:sdk",
      "//src/performance/trace2json:bin_sdk",
      "//src/sys/pkg/bin/far:bin_sdk",
      "//src/sys/pkg/testing/fake-omaha-client:bin_sdk",
      "//tools/fidlcat:fidlcat_sdk",
      "//tools/net/device-finder:device-finder_sdk",

      # TODO(https://fxbug.dev/42177692): Remove these once the emulators are available independently.
      "//src/developer/ffx/plugins/emulator:crosvm_internal",
      "//src/developer/ffx/plugins/emulator:qemu_internal",
      "//src/developer/ffx/plugins/emulator:uefi_internal_arm64",
      "//src/developer/ffx/plugins/emulator:uefi_internal_x64",
    ]
  }

  # Tools on which the Bazel SDK's `fuchsia_toolchain_info` explicitly depends.
  # At least some of these should not be needed by the in-tree SDK build and
  # should be moved to "non_build_host_tools". See https://fxbug.dev/395968221.
  sdk_molecule("non_build_host_tools_required_by_bazel_sdk") {
    category = "partner"
    deps = [
      "//build/assembly/tools/generate_config:generate_config_sdk",
      "//src/developer/ffx:bin_sdk",
      "//src/developer/ffx/plugins/driver:sdk",
      "//src/developer/ffx/plugins/emulator:aemu_internal",
      "//src/developer/ffx/plugins/product:sdk",
      "//src/developer/ffx/plugins/test:sdk",
      "//tools/bootserver_old:bootserver_sdk",
      "//tools/funnel:funnel_sdk",
      "//tools/sdk-tools/fssh:fssh_sdk",
      "//tools/symbolizer:sdk",
      "//zircon/tools/merkleroot:merkleroot_sdk",
    ]
  }

  # Tools and data used on a host development machine to build software to run
  # on Fuchsia.
  sdk_molecule("build_host_tools") {
    category = "partner"
    deps = [
      "//src/developer/ffx/plugins/assembly:sdk",
      "//src/developer/ffx/plugins/package:sdk",
      "//src/developer/ffx/plugins/scrutiny:sdk",
      "//src/starnix/tools/gen_android_starnix_container:gen_android_starnix_container_sdk",
      "//src/storage/bin/fvm:fvm_sdk",
      "//src/storage/blobfs/tools:blobfs_sdk",
      "//src/storage/minfs/tools:minfs_sdk",
      "//src/storage/tools/blobfs-compression:blobfs-compression_sdk",
      "//tools/bindc:bindc_sdk",
      "//tools/cmc:cmc_sdk",
      "//tools/configc:configc_sdk",
      "//tools/fidl/fidlc:fidl-format_sdk",
      "//tools/fidl/fidlc:fidlc_sdk",
      "//tools/fidl/fidlgen_cpp:fidlgen_cpp_sdk",
      "//tools/fidl/fidlgen_hlcpp:fidlgen_hlcpp_sdk",
      "//tools/fidl/fidlgen_rust:fidlgen_rust_sdk",
      "//zircon/tools/zbi:zbi_sdk",
    ]
  }
} else {
  # Contains :host_tools_for_single_toolchain for all host toolchains that this
  # build is configured to include. Always includes host tools for
  # `host_toolchain`, and includes host tools for other host toolchains when
  # `sdk_cross_compile_host_tools` is true.
  sdk_molecule("host_tools_for_configured_host_cpus") {
    category = "partner"

    _toolchains = []
    if (host_os == "linux" && sdk_cross_compile_host_tools) {
      _required_target_cpus = [
        "x64",
        "arm64",
      ]
      _skipped_target_cpus = idk_target_cpus_default - idk_target_cpus
      assert(
          _skipped_target_cpus == _skipped_target_cpus + _required_target_cpus -
                                      _required_target_cpus,
          "`idk_target_cpus` must include all CPUs for which host tools are being cross-compiled: ${idk_target_cpus} vs. ${_required_target_cpus}")
      _toolchains += [
        host_x64_toolchain,
        host_arm64_toolchain,
      ]
    } else {
      _toolchains = [ host_toolchain ]
    }

    deps = []
    foreach(toolchain, _toolchains) {
      deps += [ ":host_tools_for_single_toolchain($toolchain)" ]
    }
  }
}  # end if (is_host)

sdk_molecule("core_bindlib") {
  category = "partner"
  deps = [
    "//src/devices/bind/fuchsia:fuchsia_sdk",
    "//src/devices/bind/fuchsia.acpi:fuchsia.acpi_sdk",
    "//src/devices/bind/fuchsia.adc:fuchsia.adc_sdk",
    "//src/devices/bind/fuchsia.amlogic.platform:fuchsia.amlogic.platform_sdk",
    "//src/devices/bind/fuchsia.amlogic.platform.a311d:fuchsia.amlogic.platform.a311d_sdk",
    "//src/devices/bind/fuchsia.amlogic.platform.meson:fuchsia.amlogic.platform.meson_sdk",
    "//src/devices/bind/fuchsia.arm.platform:fuchsia.arm.platform_sdk",
    "//src/devices/bind/fuchsia.block:fuchsia.block_sdk",
    "//src/devices/bind/fuchsia.broadcom.platform:fuchsia.broadcom.platform_sdk",
    "//src/devices/bind/fuchsia.broadcom.platform.sdio:fuchsia.broadcom.platform.sdio_sdk",
    "//src/devices/bind/fuchsia.clock:fuchsia.clock_sdk",
    "//src/devices/bind/fuchsia.designware.platform:fuchsia.designware.platform_sdk",
    "//src/devices/bind/fuchsia.devicetree:fuchsia.devicetree_sdk",
    "//src/devices/bind/fuchsia.ethernet:fuchsia.ethernet_sdk",
    "//src/devices/bind/fuchsia.focaltech.platform:fuchsia.focaltech.platform_sdk",
    "//src/devices/bind/fuchsia.google.platform:fuchsia.google.platform_sdk",
    "//src/devices/bind/fuchsia.gpio:fuchsia.gpio_sdk",
    "//src/devices/bind/fuchsia.i2c:fuchsia.i2c_sdk",
    "//src/devices/bind/fuchsia.khadas.platform:fuchsia.khadas.platform_sdk",
    "//src/devices/bind/fuchsia.mailbox:fuchsia.mailbox_sdk",
    "//src/devices/bind/fuchsia.nxp.platform:fuchsia.nxp.platform_sdk",
    "//src/devices/bind/fuchsia.pci:fuchsia.pci_sdk",
    "//src/devices/bind/fuchsia.platform:fuchsia.platform_sdk",
    "//src/devices/bind/fuchsia.power:fuchsia.power_sdk",
    "//src/devices/bind/fuchsia.pwm:fuchsia.pwm_sdk",
    "//src/devices/bind/fuchsia.realtek.platform:fuchsia.realtek.platform_sdk",
    "//src/devices/bind/fuchsia.register:fuchsia.register_sdk",
    "//src/devices/bind/fuchsia.regulator:fuchsia.regulator_sdk",
    "//src/devices/bind/fuchsia.sdio:fuchsia.sdio_sdk",
    "//src/devices/bind/fuchsia.sdmmc:fuchsia.sdmmc_sdk",
    "//src/devices/bind/fuchsia.serial:fuchsia.serial_sdk",
    "//src/devices/bind/fuchsia.spmi:fuchsia.spmi_sdk",
    "//src/devices/bind/fuchsia.sysmem:fuchsia.sysmem_sdk",
    "//src/devices/bind/fuchsia.test:fuchsia.test_sdk",
    "//src/devices/bind/fuchsia.test.platform:fuchsia.test.platform_sdk",
    "//src/devices/bind/fuchsia.ti.platform:fuchsia.ti.platform_sdk",
    "//src/devices/bind/fuchsia.usb.phy:fuchsia.usb.phy_sdk",
    "//src/devices/bind/fuchsia.verisilicon.platform:fuchsia.verisilicon.platform_sdk",
  ]
}

sdk_molecule("core_packages") {
  category = "partner"
  deps = [
    "//src/developer/build_info/testing:fake-build-info-sdk",
    "//src/graphics/examples/vkproto/cmd-buf-benchmark:cmd-buf-benchmark-test-sdk",
    "//src/graphics/examples/vkproto/driver-tests:vkproto-driver-test-sdk",
    "//src/graphics/tests/benchmark:vkcopy-test-sdk",
    "//src/graphics/tests/vkext:vkext-test-sdk",
    "//src/graphics/tests/vkloop:vkloop-test-sdk",
    "//src/graphics/tests/vkreadback:vkreadback_test_sdk",
    "//src/lib/fuchsia-component-test/realm_builder_server:realm_builder_server_sdk",
    "//src/performance/memory/heapdump/collector:collector_sdk",
    "//src/testing/fidl/intl_property_manager:intl_property_manager_sdk",
  ]
}

sdk_molecule("core_data") {
  category = "partner"
  deps = [
    # TODO(ddorwin): Rename these to make it clear that they are data (e.g., _shards).
    "//sdk/lib/driver_component:driver_component",
    "//sdk/lib/heapdump_instrumentation:heapdump_instrumentation_shard",
    "//sdk/lib/inspect/shards:inspect_sdk",
    "//sdk/lib/sys/component:realm_builder_shard_sdk",
    "//sdk/lib/syslog/shards:syslog_sdk",
    "//sdk/lib/vulkan",
    "//src/developer/ffx/lib/symbol-index:symbol-index-sdk",
  ]
}

sdk_molecule("core_dart_library") {
  category = "partner"
  deps = [ "//sdk/testing/sl4f/client:client_sdk($dart_toolchain)" ]
}

sdk_molecule("core_experimental_python_e2e_tests") {
  category = "partner"
  if (host_os == "linux") {
    deps = [
      "//src/tests/end_to_end/rtc:rtc_conformance_test_sdk($host_toolchain)",
    ]
  }
}

# C/C++ code that must be provided as prebuilt libraries for each supported API
# level. Must export symbols with C linkage.
sdk_molecule("core_cc_prebuilt_libraries") {
  category = "partner"
  deps = [
    "//sdk/lib/async-default:async-default_sdk",
    "//sdk/lib/async-loop:async-loop-default_sdk",
    "//sdk/lib/fdio:fdio_sdk",
    "//sdk/lib/magma_client:magma_client_sdk",
    "//sdk/lib/svc:svc_sdk",
    "//sdk/lib/vfs/internal:vfs_internal_sdk",
    "//src/devices/bin/driver_runtime:driver_runtime_sdk",
    "//src/performance/memory/heapdump/instrumentation:instrumentation_sdk",
    "//third_party/Vulkan-Loader/src:libvulkan_sdk",
    "//zircon/system/ulib/sync:sync_sdk",
    "//zircon/system/ulib/syslog:syslog_sdk",
    "//zircon/system/ulib/trace-engine:trace-engine_sdk",
    "//zircon/system/ulib/trace-provider:trace-provider-so_sdk",
    "//zircon/system/ulib/trace-vthread:trace-vthread_sdk",
  ]
}

# C/C++ code that is provided as source in the SDK.
# Prefer providing source code if all dependencies are available in the SDK.
# All source files must be buildable at each supported API level.
# There is currently not mechanism to ensure this, even at "PLATFORM" because
# it does not cause the source files to be compiled. It only generates the SDK
# atoms
# TODO(https://fxbug.dev/42083950): Ensure the libraries build and are
# complete at all API levels.
sdk_molecule("core_cc_source_libraries") {
  category = "partner"
  deps = [
    "//sdk/lib/async:async-cpp_sdk",
    "//sdk/lib/async:async_sdk",
    "//sdk/lib/async-loop:async-loop-cpp_sdk",
    "//sdk/lib/async-loop:async-loop_sdk",
    "//sdk/lib/async-loop-testing/cpp:cpp_sdk",
    "//sdk/lib/async-testing:async-testing_sdk",
    "//sdk/lib/async_patterns/cpp:cpp_sdk",
    "//sdk/lib/async_patterns/testing/cpp:cpp_sdk",
    "//sdk/lib/component/incoming/cpp:cpp_sdk",
    "//sdk/lib/component/outgoing/cpp:cpp_sdk",
    "//sdk/lib/driver/component/cpp:cpp_sdk",
    "//sdk/lib/driver/devfs/cpp:cpp_sdk",
    "//sdk/lib/driver/fake-bti/cpp:cpp_sdk",
    "//sdk/lib/driver/fake-gpio/cpp:cpp_sdk",
    "//sdk/lib/driver/fake-mmio-reg/cpp:cpp_sdk",
    "//sdk/lib/driver/fake-object/cpp:cpp_sdk",
    "//sdk/lib/driver/fake-platform-device/cpp:cpp_sdk",
    "//sdk/lib/driver/metadata/cpp:cpp_sdk",
    "//sdk/lib/driver/mock-mmio/cpp:cpp_sdk",
    "//sdk/lib/driver/platform-device/cpp:cpp_sdk",
    "//sdk/lib/driver/power/cpp:cpp_sdk",
    "//sdk/lib/driver/testing/cpp:cpp_sdk",
    "//sdk/lib/driver/testing/cpp:scoped_global_logger_sdk",
    "//sdk/lib/fidl/cpp:cpp_sdk",
    "//sdk/lib/fidl/cpp:hlcpp_conversion_sdk",
    "//sdk/lib/fidl/cpp:natural_ostream_sdk",
    "//sdk/lib/fidl/cpp/wire:wire_sdk",
    "//sdk/lib/fidl/hlcpp:hlcpp_sdk",
    "//sdk/lib/fidl_driver:fidl_driver_natural_sdk",
    "//sdk/lib/fidl_driver:fidl_driver_sdk",
    "//sdk/lib/fit-promise:fit-promise_sdk",
    "//sdk/lib/input_report_reader:input_report_reader_sdk",
    "//sdk/lib/inspect/component/cpp:cpp_sdk",
    "//sdk/lib/magma_common:magma_common_sdk",
    "//sdk/lib/media/cpp:cpp_sdk",
    "//sdk/lib/stdcompat:stdcompat_sdk",
    "//sdk/lib/sys/component/cpp/testing:cpp_library_sdk",
    "//sdk/lib/sys/cpp:cpp_sdk",
    "//sdk/lib/sys/cpp/testing:cpp_sdk",
    "//sdk/lib/sys/testing:testing_sdk",
    "//sdk/lib/syslog/cpp:cpp_sdk",
    "//sdk/lib/syslog/structured_backend:structured_backend_sdk",
    "//sdk/lib/trace",
    "//sdk/lib/ui/scenic/cpp:cpp_sdk",
    "//sdk/lib/ui/scenic/cpp/testing:testing_sdk",
    "//sdk/lib/vfs/cpp:cpp_sdk",
    "//sdk/lib/virtgralloc:virtgralloc_headers_sdk",
    "//sdk/lib/zbi-format:zbi-format_sdk",
    "//src/devices/lib/mmio:mmio_sdk",
    "//src/lib/memory_barriers:memory_barriers_sdk",
    "//zircon/system/ulib/hwreg:hwreg_public_sdk",
    "//zircon/system/ulib/inspect:inspect_sdk",
    "//zircon/system/ulib/trace:trace_sdk",
  ]
}

sdk_molecule("core_sysroot") {
  category = "partner"
  deps = [ "//zircon/public/sysroot_sdk" ]
}

# License/copyright files for the SDK.
sdk_molecule("core_licenses") {
  category = "partner"
  deps = [
    ":musl_license",
    ":open_source",
    ":sdk_notice",
    "//third_party/Vulkan-Loader/src:vulkan_license",
  ]
}

#
# BEGIN @fuchsia_sdk
#
# The following is relevant to the Ninja-generated IDK used to
# populate the @fuchsia_sdk repository for the in-tree Bazel
# workspace.
#
# This only contains the targets necessary to generate this IDK,
# as validation is performed in both Ninja and Bazel targets
# defined in //build/bazel/bazel_sdk/BUILD.gn

if (current_toolchain == default_toolchain) {
  # An IDK used to expose the SDK atoms to the in-tree Bazel workspace's
  # `@fuchsia_sdk` repository.
  #
  # This exposes a subset of the atoms in the complete "fuchsia" IDK.
  # By default it only provides binaries for the current `target_cpu`
  # architecture and the "PLATFORM" API level.
  idk("bazel_in_tree_idk") {
    visibility = []
    visibility = [
      ":bazel_in_tree_idk_tests_${target_cpu}",
      "//:ninja_subbuilds",
      "//build/bazel:fuchsia_in_tree_idk.hash",
      "//build/bazel:generate_main_workspace",
      "//build/bazel/bazel_sdk:bazel_in_tree_idk.bazel_input",
    ]

    assert_no_deps = [
      # Ensure a sampling of excluded targets are not being pulled into the
      # in-tree build.
      "//src/lib/vulkan:vulkan_layers",
      "//src/testing/end_to_end/honeydew:honeydew_no_testonly",
      "//tools/docsgen:ref_docs_sdk",

      # Ensure the full IDK collection build is not accidentally a dependency.
      ":fuchsia_collection",
    ]

    output_name = "bazel_in_tree_idk"
    sdk_collection_label = "//sdk:in_tree_collection"
    idk_subbuilds_label = "//sdk:in_tree_collection_subbuilds"
    idk_subbuilds_prefix = "idk_subbuild.in_tree_collection_for_subbuilds"

    target_cpus = [ target_cpu ]

    api_levels = []  # `PLATFORM` artifacts will be used as `HEAD`

    # TODO(https://fxbug.dev/306723826): Deal with the fact that the mac builders
    # are too slow to enable this setting, and therefore the mac IDK won't have
    # per-api-level prebuilts.
    if (host_os == "mac") {
      api_levels = []
    }
  }

  # Run the Bazel SDK test suite against the content of
  # //sdk:bazel_in_tree_idk. This is only useful for development,
  # as the content of the @fuchsia_sdk repository, populated
  # from the same IDK, is already checked by a different suite
  # of tests defined under //build/bazel/bazel_sdk.
  run_fuchsia_bazel_sdk_tests("bazel_in_tree_idk_tests") {
    target_cpus = [ target_cpu ]

    idk_exported_target = "//sdk:bazel_in_tree_idk"
    idk_exported_path = "$root_build_dir/sdk/exported/bazel_in_tree_idk"

    # For now, nothing should depend on this except
    # //:root_targets to ensure it can be launched manually
    # with  `fx build //sdk:bazel_in_tree_idk_tests`
    visibility = []
    visibility = [ "//:root_targets" ]
  }

  #
  # END @fuchsia_sdk

  #
  # BEGIN @internal_sdk
  # DO NOT ADD anything here! This will soon be removed.
  # See https://fxbug.dev/333907192.
  #

  # This SDK molecule is a collection of libraries only available to the in-tree
  # Bazel build. See //sdk:bazel_internal_only
  sdk_molecule("bazel_internal_only_libs") {
    category = "internal"
    deps = [
      # When removing targets from this list, remove them from the exceptions or
      # allowlist for the `sdk_*()` template they used.

      # TODO(https://fxbug.dev/333907192): Depend on the target already in the
      # in-tree IDK.
      ":version_history_sdk($default_toolchain)",

      # TODO(https://fxbug.dev/343059325): Promote devicetree to "partner".
      "//sdk/lib/driver/devicetree/manager:manager_sdk",
      "//sdk/lib/driver/devicetree/manager:manager-test-helper_sdk",
      "//sdk/lib/driver/devicetree/testing:board-test-helper_sdk",
      "//sdk/lib/driver/devicetree/testing:visitor-test-helper_sdk",
      "//sdk/lib/driver/devicetree/visitors:driver-visitor_sdk",
      "//sdk/lib/driver/devicetree/visitors:load-visitors_sdk",
      "//sdk/lib/driver/devicetree/visitors:registration_sdk",
      "//sdk/lib/driver/devicetree/visitors/default:default_sdk",
      "//sdk/lib/driver/devicetree/visitors/drivers:all-driver-visitors_sdk",

      # TODO(https://fxbug.dev/333907192): Promote mock-registers to "partner".
      "//src/devices/registers/testing/mock-registers:mock-registers_sdk",

      # TODO(https://fxbug.dev/333907192): Promote mmio source sets to "partner".
      "//src/devices/lib/mmio:test_helper_sdk",
      "//src/devices/testing/fake-mmio-reg:fake-mmio-reg_sdk",
      "//src/devices/testing/mock-mmio-reg:mock-mmio-reg_sdk",

      # TODO(https://fxbug.dev/333907192): Eliminate vendor dependencies on fzl
      # or promote it to "partner".
      "//zircon/system/ulib/fzl:fzl_sdk",
    ]
  }

  # A collection of SDK atoms used to populate the @internal_sdk Bazel
  # repository. Only used internally to expose atoms that are not ready
  # to be moved to the partner category, but still must be visible
  # from the Bazel graph. See https://fxbug.dev/333907192.
  #
  # Content are bound to change a lot.
  # TODO(https://fxbug.dev/333907192): Remove this.
  sdk_collection("bazel_internal_only") {
    visibility = []
    visibility = [ ":bazel_internal_only_idk" ]

    category = "internal"
    id = sdk_id

    deps = [ ":bazel_internal_only_libs" ]
  }

  # An IDK used to expose the bazel_internal_only collection for the
  # @internal_sdk repository of the platform build's Bazel workspace.
  # TODO(https://fxbug.dev/333907192): Remove this.
  idk("bazel_internal_only_idk") {
    visibility = []
    visibility = [
      "//build/bazel:fuchsia_internal_only_idk.hash",
      "//build/bazel:generate_main_workspace",
    ]
    output_name = "bazel_internal_only_idk"
    sdk_collection_label = "//sdk:bazel_internal_only"

    # There is no such target. This is okay because the values below ensure
    # there are no sub-builds that would use it.
    # Specifying a label serves to ensure no sub-builds are added because they
    # would require that this target exist.
    idk_subbuilds_label = "//sdk:non_existent_internal_only_idk_subbuilds"

    # Only build this for the current target_cpu and the "PLATFORM" API level.
    # This ensures no sub-builds will be launched.
    # Any prebuilts built will only be available in the in the legacy "binaries"
    # metadata and the arch/ directory.
    target_cpus = [ target_cpu ]
    api_levels = []
  }

  #
  # END @internal_sdk
  #

  if (!sdk_inside_sub_build) {
    # Various ffx tests depend on the collection output in
    # "$OUT_DIR/sdk/exported/core" for tools. They should depend
    # on this target to abstract the dependency from details of the IDK build.
    # These tests only need the core tools.
    # TODO(https://fxbug.dev/392136182): Remove those dependencies.
    group("exported_idk_for_ffx_tests") {
      testonly = true
      visibility = []
      visibility = [
        # Do not add to this list. See  the comment in
        # `//src/developer/ffx:ffx_bin`.

        "//src/developer/ffx/lib/e2e_emu:isolated_emulator_data",
        "//src/developer/ffx/lib/fuchsia-controller/tests:core_sdk_host_test_data",
        "//src/developer/ffx/lib/symbolize/tests:ffx_symbolize_lib_e2e_test_emulator_data",
        "//src/developer/ffx/plugins/component/create/tests/structured_config:verify_ffx_component_create_parent_overrides_emulator_data",
        "//src/developer/ffx/plugins/component/run/tests/structured_config:verify_ffx_component_run_parent_overrides_emulator_data",
        "//src/developer/ffx/plugins/profile/heapdump:verify_ffx_profile_heapdump_emulator_data",
        "//src/developer/ffx/plugins/target/ssh:ffx_target_ssh_e2e_tests_emulator_data",
        "//src/developer/ffx/tools/power/system-activity/application-activity:ffx_power_system_activity_application_activity_e2e_tests_emulator_data",
        "//src/developer/ffx/tools/target-package/tests:verify_ffx_target_package_explore_emulator_data",
        "//vendor/*",
      ]

      deps = [ ":core" ]
    }
  }
}  # current_toolchain == default_toolchain

if (is_host) {
  # A collection of all host tools in the IDK for the current (host) toolchain.
  # This must contain exactly the set of host tools (for a single CPI
  # architecture) included in ":final_fuchsia_idk". It is used to generate
  # documentation for the tools.
  # Its "SDK root" is at:
  # `get_label_info("//sdk:idk_host_tools_collection", "root_out_dir") + "/sdk/exported/idk_host_tools_collection"`
  sdk_collection("idk_host_tools_collection") {
    visibility = []
    visibility = [
      ":sdk",
      "//tools/docsgen:invoke_clidoc",
    ]

    # TODO(https://fxbug.dev/317385989): Find a solution that doesn't depend on
    # sdk_* templates.
    category = "internal"

    deps = [ ":host_tools_for_single_toolchain" ]
  }

  # A collection that only contains host tools that are used by the Fuchsia
  # build when running ffx tools via the `ffx_action()` template. This allows
  # "ffx-assembly" to find the tools it needs via an IDK manifest just as it
  # would when used with a real IDK.
  sdk_collection("host_tools_used_by_ffx_action_during_build") {
    # This (sorta) restricts the use of this group to instances of the
    # `ffx_action()` template, which uses the group below.
    visibility = []
    visibility = [ "//src/developer/ffx/build:host_tools_used_by_ffx_action" ]

    # TODO(https://fxbug.dev/317385989): Find a solution that doesn't depend on
    # sdk_* templates.
    category = "internal"

    id = sdk_id

    # This is a collection of host tools that are used _by_ ffx itself to
    # perform actions within the build.  As such, it CANNOT have a dependency
    # the main ffx binary, or any of the subtools, or it will cause all
    # ffx_action()'s using subtools to be dependent on the compilation of the
    # main ffx binary (and/or all subtools), adding minutes to any incremental
    # build of an ffx subtool.
    assert_no_deps = [
      "//src/developer/ffx:bin_sdk",
      "//src/developer/ffx:ffx_tool",
      "//src/developer/ffx/frontends/ffx:ffx_bin($host_toolchain)",
    ]

    deps = [
      # Do not add to this list.
      # Prefer solutions that do not require locating tool dependencies via an
      # IDK manifest.
      "//src/storage/bin/fvm:fvm_sdk",
      "//src/storage/blobfs/tools:blobfs_sdk",
      "//tools/cmc:cmc_sdk",
      "//zircon/tools/zbi:zbi_sdk",
    ]
  }
}  # end if (is_host)

# Host tools necessary to build the IDK. Keep this minimal, so IDK subbuilds can
# start running as quickly as possible.
#
# This rule copies each of the tools listed below into
# `$root_build_dir/sdk/idk_build_tools`. For example, a tool like `cmc` will
# appear in `$root_build_dir/sdk/idk_build_tools/host_x64/cmc` on an x64 host.
# SDK subbuilds will look for host tools in that directory, so they will only
# have access to binaries that they explicitly depend on via this rule.
copy("idk_build_tools") {
  visibility += [
    "//build/*",
    "//sdk/firmware:*",
    "//vendor/*",
  ]

  sources = [
    "$host_out_dir/bindc",
    "$host_out_dir/cmc",
    "$host_out_dir/configc",
    "$host_out_dir/far",
    "$host_out_dir/ffx-package_unversioned",
    "$host_out_dir/fidl-format",
    "$host_out_dir/fidl-lint",
    "$host_out_dir/fidl_api_diff",
    "$host_out_dir/fidl_api_summarize",
    "$host_out_dir/fidlc",
    "$host_out_dir/fidlgen_cpp",
    "$host_out_dir/fidlgen_hlcpp",
    "$host_out_dir/fidlgen_rust",
    "$host_out_dir/json_merge",
    "$host_out_dir/measure-tape",
    "$host_out_dir/package-tool",
    "$host_out_dir/zither",
  ]

  # Looks like `host_x64`.
  _rebased_host_dir = rebase_path(host_out_dir, root_build_dir)
  outputs = [ "$root_build_dir/sdk/idk_build_tools/${_rebased_host_dir}/{{source_file_part}}" ]

  deps = [
    "//build/tools/json_merge($host_toolchain)",
    "//src/developer/ffx/plugins/package:ffx_package_tool($host_toolchain)",
    "//src/sys/pkg/bin/far:bin($host_toolchain)",
    "//src/sys/pkg/bin/package-tool($host_toolchain)",
    "//tools/bindc:bin($host_toolchain)",
    "//tools/cmc:cmc($host_toolchain)",
    "//tools/configc:configc($host_toolchain)",
    "//tools/fidl/fidl_api_diff($host_toolchain)",
    "//tools/fidl/fidl_api_summarize($host_toolchain)",
    "//tools/fidl/fidlc:fidl-format($host_toolchain)",
    "//tools/fidl/fidlc:fidl-lint($host_toolchain)",
    "//tools/fidl/fidlc($host_toolchain)",
    "//tools/fidl/fidlgen_cpp($host_toolchain)",
    "//tools/fidl/fidlgen_hlcpp($host_toolchain)",
    "//tools/fidl/fidlgen_rust($host_toolchain)",
    "//tools/fidl/measure-tape/src:measure-tape($host_toolchain)",
    "//zircon/tools/zither($host_toolchain)",
  ]
}

# Controls the maximum number of simultaneous subbuilds.
pool("subbuild_pool") {
  depth = sdk_max_simultaneous_sub_builds
}
