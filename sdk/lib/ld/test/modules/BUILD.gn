# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/lto/config.gni")
import("//build/dist/resource.gni")
import("//build/testing/host_test_data.gni")
import("//build/toolchain/generated_ifs_file.gni")
import("//build/toolchain/ifs_shared_library.gni")
import("//build/toolchain/toolchain_environment.gni")
import("//sdk/lib/ld/testing/test_elf_object.gni")

# This only gets instantiated in the environment where the test modules are
# meant to be built.

# Everything in this list has can_be_in_process = true.
in_process_executables = [
  ":ret17",
  ":ret23",
  ":partial-page-bss",
  ":partial-page-bss-garbage-at-eof",
  ":relative-reloc",
  ":symbolic-reloc",
  ":ld-dep",
  ":basic-dep",
  ":indirect-deps",
  ":passive-abi-basic",
  ":passive-abi-rdebug",
  ":passive-abi-many-deps",
  ":symbolic-namespace",
  ":many-deps",
  ":init-fini",
  ":tls-shlib-only",
  ":tls-exec-shlib",
  ":tls-gd",
  ":tls-desc",
  ":tls-ld",
  ":zygote",
  ":zygote-secondary",
]

non_module_in_process_executables = [
  ":tls-exec-only",
  ":tls-ie",
]

# Everything in this list does not have can_be_in_process = true.
executables = [
  ":missing-dep",
  ":missing-sym",
  ":missing-transitive-dep",
  ":relro",
  ":fixed-load-address",
]

non_module_executables = [ ":backtrace" ]

if (is_fuchsia) {
  in_process_executables += [ ":llvm-profdata" ]
  executables += [ ":second-session" ]
}

modules = [
  ":second-session-module",
  ":generate-host-test-data",
  ":tls-dep-module",
  ":tls-desc-dep-module",
]

# Musl's dlclose does not unload the module, which prevents being able to reuse
# the same test module in multiple dlopen tests that do not expect the module
# or its deps to already be loaded. Therefore tests must use uniquely named test
# files. `per_test_modules` includes the modules that require unique names per
# test, and  `per_test_suffices` include test names in
# //sdk/lib/dl/test/dl-load-tests.cc. The following foreach loop will add
# suffixed targets for each module in `per_test_modules` to `modules`.
per_test_modules = [
  ":multiple-foo-deps",
  ":transitive-foo-dep",
  ":multiple-transitive-foo-deps",
  ":root-precedence-in-dep-resolution",
  ":precedence-in-dep-resolution",
]

per_test_suffices = [
  "DepOrder",
  "TransitiveDepOrder",
  "LoadedTransitiveDepOrder",
  "OpenDepDirectly",
  "LocalPrecedence",
  "LocalPrecedenceTransitiveDeps",
  "GlobalPrecedence",
  "GlobalPrecedenceDeps",
  "RelativeRelocPrecedence",
  "RootPrecedenceInDepResolution",
  "PrecedenceInDepResolution",
]

foreach(suffix, per_test_suffices) {
  foreach(module, per_test_modules) {
    modules += [ "$module.$suffix.module" ]
  }
}

foreach(label, executables + in_process_executables) {
  modules += [ "$label.module" ]
}

executables += non_module_executables

foreach(label, in_process_executables + non_module_in_process_executables) {
  executables += [
    label,
    "$label.in-process",
  ]
}

# This is used to roll up all the test binaries with appropriate variant
# selection for metadata collection purposes.  It's used to get the test
# binaries populated in the Fuchsia package (via resource() equivalents) or
# host subdirectory (via host_test_data() equivalents).
group("modules") {
  testonly = true

  deps = executables + modules

  if (!is_fuchsia) {
    # On Fuchsia, the binary targets themselves are resource() equivalents.
    # On host, extra `.host-test-data` targets are defined below.
    data_deps = []
    foreach(test, deps) {
      data_deps += [ "$test.host-test-data" ]
    }
  }
}

config("semantic-interposition") {
  visibility = [ ":*" ]

  # TODO(https://fxbug.dev/42069056): clang will still perform interprocedural
  # optimization in a PIC, this flag disallows that and requires the PLT call
  # always be made so we can properly test applying plt relocations.
  if (!is_gcc) {
    cflags = [ "-fsemantic-interposition" ]
  }
}

# On POSIX systems, a dlopen'd test module's DT_NEEDED dependencies will be
# looked for in a search path.  Embedding DT_RUNPATH of $ORIGIN tells it to
# look first in the directory containing the original dlopen'd module.
config("runpath-origin") {
  visibility = [ ":*" ]
  if (!is_fuchsia) {
    ldflags = [ "-Wl,--enable-new-dtags,-rpath,\$ORIGIN" ]
  }
}

template("_test_non_executable") {
  main_target_name = target_name
  shlib_target_name = "$main_target_name.${invoker.target_type}"

  # This reaches the actual target, but also collects metadata to roll up into
  # test_elf_load_set() targets.  The test_elf_object() target itself is enough
  # to reach the real target as deps (for linking and packaging).  But if the
  # real target has any public{,_deps,_configs} those need to be propagated as
  # public_deps, so the group keeps the real target's public persona but also
  # reaches the test_elf_object() without creating a circularity.
  group(main_target_name) {
    visibility = [ ":*" ]
    testonly = true
    public_deps = [ ":$shlib_target_name($shlib_toolchain)" ]
    deps = [ ":$main_target_name.test-elf-object($shlib_toolchain)" ]
  }

  test_elf_object("$main_target_name.test-elf-object") {
    visibility = [ ":*" ]
    testonly = true
    deps = [ ":$shlib_target_name" ]
  }

  target(invoker.target_type, shlib_target_name) {
    visibility = [ ":*" ]
    testonly = true

    output_name = main_target_name
    deps = []
    public_deps = []
    shlib_deps = []
    ldflags = []
    forward_variables_from(invoker,
                           "*",
                           [
                             "configs",
                             "output_name",
                             "remove_configs",
                             "target_type",
                           ])

    public_deps += [ "//sdk/lib/ld:standalone" ]
    deps += [ ":test-module.deps" ] + shlib_deps

    if (is_linux) {
      configs -= [ "//build/config/linux:implicit-host-libs" ]
    }
    configs += [ ":nostdlibs" ]
    if (defined(invoker.configs)) {
      configs += invoker.configs
    }

    # Make sure a system dlopen loading the shared library as a dependency of
    # another module will look for its own dependencies adjacent to it.
    configs += [ ":runpath-origin" ]

    if (defined(invoker.remove_configs)) {
      configs += invoker.remove_configs
      configs -= invoker.remove_configs
    }
  }

  if (!is_fuchsia && current_toolchain == shlib_toolchain) {
    prefixes = {
      loadable_module = ""
      shared_library = "lib"
    }
    prefix = prefixes[invoker.target_type]

    # host_test_data() generates this copy() target with this metadata, but it
    # adds extra deps that don't work here and are only in host_test_data() for
    # issues with non-shlib variant binaries that don't apply here.
    copy("$main_target_name.host-test-data") {
      visibility = [ ":*" ]
      testonly = true

      deps = [ ":$shlib_target_name" ]
      sources = [ "$root_out_dir/$prefix$main_target_name.so" ]

      # TODO(https://fxbug.dev/333947906): copy targets to a variant dedicated dir.
      outputs = [ "$host_out_dir/test_data/elfldltl/{{source_file_part}}" ]
      metadata = {
        test_runtime_deps = process_file_template(sources, outputs)
      }

      data_deps = []
      if (defined(invoker.shlib_deps)) {
        foreach(shlib, invoker.shlib_deps) {
          data_deps += [ "$shlib.host-test-data" ]
        }
      }
    }
  }
}

template("test_shared_library") {
  _test_non_executable(target_name) {
    target_type = "shared_library"
    forward_variables_from(invoker, "*", [ "target_type" ])
  }
}

template("test_ifs_shared_library") {
  generated_ifs_file("${target_name}.ifs") {
    visibility = [ ":*" ]
    testonly = true

    forward_variables_from(invoker,
                           [
                             "soname",
                             "symbols",
                           ])
  }
  ifs_shared_library(target_name) {
    visibility = [ ":*" ]
    testonly = true
    deps = []

    forward_variables_from(invoker,
                           "*",
                           [
                             "abi",
                             "soname",
                             "symbols",
                           ])

    gen_outputs = get_target_outputs(":${target_name}.ifs")
    abi = gen_outputs[0]

    deps += [ ":${target_name}.ifs" ]
  }
}

template("test_loadable_module") {
  module_target = target_name

  _test_non_executable(module_target) {
    target_type = "loadable_module"
    data_deps = []
    exclude_toolchain_tags = []
    forward_variables_from(invoker, "*", [ "target_type" ])

    exclude_toolchain_tags += [ "instrumentation-runtime" ]

    if (!is_fuchsia && defined(invoker.shlib_deps)) {
      # On Fuchsia, the indirect deps are all reached as resource()
      # equivalents implicitly.  On host, the shlib_deps binaries must both
      # be copied into the right test-data directory and roll up as
      # host_test_data() equivalents.  This is evaluated after variant
      # selection so it reaches the right variant $shlib_toolchain where
      # test_shared_library() defines the `.host-test-data` target.
      foreach(shlib, invoker.shlib_deps) {
        data_deps += [ "$shlib.host-test-data($shlib_toolchain)" ]
      }
    }
  }

  if (!is_fuchsia && current_toolchain != shlib_toolchain) {
    # On Fuchsia, the test loadable_module is reached as a resource()
    # equivalent implicitly.  On host, it must both be copied into the right
    # test-data directory and roll up as an host_test_data() equivalent.  The
    # variant selection is done by the loadable_module() target, but we are
    # in the right environment that produces a copy() target into the base
    # toolchain's $root_out_dir.  This host_test_data() will copy again from
    # there.
    if (is_linux) {
      assert(toolchain_environment == "linux",
             "$current_toolchain is $toolchain_environment")
    }
    host_test_data("$module_target.host-test-data") {
      deps = [ ":$module_target.loadable_module" ]
      sources = [ "$root_out_dir/$module_target.so" ]
      outputs = [ "$host_out_dir/test_data/elfldltl/{{source_file_part}}" ]
    }
  }
}

template("test_executable") {
  executable_target = target_name

  suffices = [
    "",
    ".module",
  ]
  if (defined(invoker.can_be_in_process) && invoker.can_be_in_process) {
    suffices += [ ".in-process" ]
  }

  foreach(suffix, suffices) {
    if (suffix == ".module") {
      target_type = "loadable_module"
    } else {
      target_type = "executable"
    }
    target(target_type, executable_target + suffix) {
      visibility = [ ":*" ]
      testonly = true

      if (is_linux) {
        configs -= [ "//build/config/linux:implicit-host-libs" ]
      }

      deps = []
      data_deps = []
      forward_variables_from(invoker,
                             "*",
                             [
                               "configs",
                               "shlib_deps",
                               "testonly",
                             ])
      deps += [ ":test-executable$suffix" ]
      if (defined(invoker.shlib_deps)) {
        deps += invoker.shlib_deps
      }
      if (defined(invoker.configs)) {
        configs += invoker.configs
      }

      if (target_type == "executable") {
        # This is needed in the non-Zircon (host/Linux) toolchains to avoid
        # having any implicit deps injected.
        disable_syslog_backend = true
      }

      exclude_toolchain_tags = [ "instrumentation-runtime" ]

      if (!is_fuchsia && defined(invoker.shlib_deps)) {
        # On Fuchsia, the indirect deps are all reached as resource()
        # equivalents implicitly.  On host, the shlib_deps binaries must both
        # be copied into the right test-data directory and roll up as
        # host_test_data() equivalents.  This is evaluated after variant
        # selection so it reaches the right variant $shlib_toolchain where
        # test_shared_library() defines the `.host-test-data` target.
        foreach(shlib, invoker.shlib_deps) {
          data_deps += [ "$shlib.host-test-data($shlib_toolchain)" ]
        }
      }
    }

    if (!is_fuchsia && current_toolchain != shlib_toolchain) {
      # On Fuchsia, the test executable is reached as a resource() equivalent
      # implicitly.  On host, it must both be copied into the right test-data
      # directory and roll up as an host_test_data() equivalent.  The variant
      # selection is done by the executable() target, but we are in the right
      # environment that produces a copy() target into the base toolchain's
      # $root_out_dir.  This host_test_data() will copy again from there.
      if (is_linux) {
        assert(toolchain_environment == "linux",
               "$current_toolchain is $toolchain_environment")
      }
      if (target_type == "loadable_module") {
        output_suffix = ".so"
      } else {
        output_suffix = ""
      }
      host_test_data("$executable_target$suffix.host-test-data") {
        deps = [ ":$executable_target$suffix" ]
        sources = [ "$root_out_dir/$executable_target$suffix$output_suffix" ]
        outputs = [ "$host_out_dir/test_data/elfldltl/{{source_file_part}}" ]
      }
    }

    # When this rolls up into a test_elf_source_set() target linked into the
    # test, then ld::testing::TestElfLoadSet::Get("$executable_target") works.
    test_elf_load_set("$executable_target$suffix.load-set") {
      visibility = [ "../*" ]
      output_name = executable_target + suffix
      deps = [ ":$executable_target$suffix.test-elf-object" ]
    }

    # The executable / module itself comes first in the TestElfLoadSet,
    # followed by its transitive deps.
    test_elf_object("$executable_target$suffix.test-elf-object") {
      visibility = [ ":*" ]
      testonly = true
      deps = [ ":$executable_target$suffix" ]
    }
  }
}

# The test executables declare an `extern "C" ... TestStart(...)` entry point.
#
# When built for in-process tests, the ELF entry point will be called directly
# by the test code.  For Fuchsia, link the test executables with -e TestStart.
# For POSIX, link with an assembly implementation of _start that tail-calls
# TestStart.
#
# When built for separate-process tests, the ELF entry point cannot return.
# Instead, it's defined to call TestStart and exit with its value.
foreach(in_process,
        [
          "",
          ".in-process",
          ".module",
        ]) {
  static_library("test-executable$in_process") {
    visibility = [ ":*" ]
    testonly = true

    if (in_process != "") {
      defines = [ "IN_PROCESS_TEST" ]
    }

    public = [
      "ensure-test-thread-pointer.h",
      "test-start.h",
    ]
    public_deps = [ "//sdk/lib/ld:standalone" ]
    public_configs = [
      ":runpath-origin",
      ":semantic-interposition",
      "//build/config:frame_pointers",
    ]
    sources = [ "ensure-test-thread-pointer.cc" ]
    deps = [
      ":test-module.deps",
      "//zircon/system/public",
    ]

    if (in_process != ".module") {
      public_deps += [ "//sdk/lib/ld:startup" ]
      if (is_fuchsia) {
        if (in_process == "") {
          sources += [ "zircon-test-start.cc" ]
          deps += [ "//src/zircon/lib/zircon" ]
        } else {
          public_configs += [ ":test-executable.in-process.config" ]
        }
      } else {
        sources += [ "posix-test-start.S" ]
        deps += [ "//zircon/kernel/lib/arch" ]
      }

      # This dependency is evaluated in the toolchain where the
      # test_executable() is built, after variant selection.  So it gets the
      # right version of ld-startup installed where the test needs to find it.
      data_deps = [ "..:ld-startup.test-data($shlib_toolchain)" ]
    }
  }
}

# These are things that every test module of all target types implicitly
# depends on.
group("test-module.deps") {
  visibility = [ ":*" ]
  testonly = true

  deps = [ ":test-ubsan" ]

  # When llvm-profdata instrumentation is in use, it may generate calls to
  # functions that are supplied by the runtime.  Even though the modules aren't
  # actually using the runtime to extract their data (yet, anyway), they link
  # in the runtime to make sure any such references are satisfied at link time.
  if (toolchain_variant.tags + [ "llvm-profdata" ] - [ "llvm-profdata" ] !=
      toolchain_variant.tags) {
    deps += [ "//src/lib/llvm-profdata" ]
  }
}

source_set("test-ubsan") {
  visibility = [ ":*" ]
  testonly = true

  if (is_ubsan) {
    sources = [
      "test-ubsan.cc",
      "test-ubsan.h",
    ]
    deps = [
      "//src/lib/ubsan-custom:handlers",
      "//zircon/system/ulib/c/stdio/printf_core:wrapper",
    ]
    if (is_fuchsia) {
      sources += [ "test-ubsan-zircon.cc" ]
    } else {
      sources += [ "test-ubsan-posix.cc" ]
    }
  }
}

# clang++ will add -lc++ and -lm, which we don't want for these tests. Note
# there are differences between the Fuchsia and GNU toolchains in clang. The
# GNU toolchain will unconditionally add -lm regardless of -nostdlib++ though
# the Fuchsia driver doesn't. -nodefaultlibs will stop the driver from adding
# -lm, but we get unused -nolibc warning because the arg is never read when
# -nodefaultlibs is specified, so just ignore the warning.
config("nostdlibs") {
  if (is_fuchsia) {
    ldflags = [ "-nostdlib++" ]
  } else {
    ldflags = [
      "-nodefaultlibs",
      "-Wno-unused-command-line-argument",
    ]
  }
}

template("test_dep") {
  test_shared_library("ld-dep-$target_name") {
    deps = []
    dep_symbols = []
    shlib_deps = []
    forward_variables_from(invoker, "*")

    decls = ""
    syms = ""
    foreach(dep, dep_symbols) {
      decls += "extern \"C\" int64_t $dep();"
      syms += "$dep, "
    }

    defines = [
      # This is the int64_t value of the symbol defined in this file.
      "VALUE=$value",

      # This is the symbol name of the symbol defined in this file.
      "SYM=$symbol_name",

      # These are the declarations of symbols from dependencies.
      "DECLS=$decls",

      # This is the list of symbol names used from dependencies.
      "DEP_SYMS=$syms",
    ]

    sources = [ "dep-template.cc" ]
    deps += [ "//zircon/system/public" ]
  }
}

config("test-executable.in-process.config") {
  visibility = [ ":*" ]
  defines = [ "IN_PROCESS_TEST" ]
  ldflags = [ "-Wl,-e,TestStart" ]
}

test_executable("ret17") {
  can_be_in_process = true
  sources = [ "ret17.cc" ]
}

test_executable("ret23") {
  can_be_in_process = true
  sources = [ "ret23.cc" ]
}

test_executable("partial-page-bss") {
  can_be_in_process = true
  sources = [ "partial-page-bss.cc" ]
}

# With --strip-sections, the file will usually end at the end of the last
# segment's p_offset + p_filesz anyway, so there won't be any data in the
# partial page needing zeroing and it will actually just be zero already in the
# mapped file.  So gin up a version of the partial-page-bss executable that has
# some nonzero garbage appended to the file so that the partial page will
# certainly be nonzero and the logic for zeroing it will really get tested.
foreach(suffix,
        [
          "",
          ".in-process",
          ".module",
        ]) {
  if (current_toolchain != shlib_toolchain || suffix == ".module") {
    action("gen-partial-page-bss-garbage-at-eof$suffix") {
      visibility = [ ":*" ]
      testonly = true
      script = "garbage-at-eof.sh"
      deps = [ ":partial-page-bss$suffix" ]
      if (suffix == ".module") {
        suffix += ".so"
      }
      sources = [ "$root_out_dir/partial-page-bss$suffix" ]
      outputs = [ "$root_out_dir/partial-page-bss-garbage-at-eof$suffix" ]
      args = rebase_path(sources + outputs, root_build_dir)
    }
    resource("partial-page-bss-garbage-at-eof$suffix") {
      visibility = [ ":*" ]
      testonly = true
      deps = [ ":gen-partial-page-bss-garbage-at-eof$suffix" ]
      sources = get_target_outputs(deps[0])
      outputs = [ "bin/{{source_file_part}}" ]
      allow_binary_output_dir = true
    }
    if (!is_fuchsia) {
      host_test_data("partial-page-bss-garbage-at-eof$suffix.host-test-data") {
        deps = [ ":gen-partial-page-bss-garbage-at-eof$suffix" ]
        sources = get_target_outputs(deps[0])
        outputs = [ "$host_out_dir/test_data/elfldltl/{{source_file_part}}" ]
      }
    }
  }
}

test_executable("relative-reloc") {
  can_be_in_process = true
  sources = [ "relative-reloc.cc" ]
}

config("temporarily-build-as-shared") {
  visibility = [ ":*" ]

  cflags = [
    "-fPIC",
    "-Wno-unused-command-line-argument",
    "-Wno-option-ignored",
  ]
  ldflags = cflags
  ldflags += [ "-shared" ]
}

test_executable("symbolic-reloc") {
  can_be_in_process = true
  sources = [
    "interp.S",
    "symbolic-reloc.cc",
  ]
  defines = [ "DYNAMIC_LINKER_PATH=\"${toolchain_variant.libprefix}ld.so.1\"" ]
  deps = [ "//zircon/system/public" ]
  configs = [ ":temporarily-build-as-shared" ]
}

test_executable("ld-dep") {
  can_be_in_process = true
  sources = [ "ld-dep.cc" ]
  deps = [ "../.." ]
}

test_dep("a") {
  symbol_name = "a"
  value = 13
}

test_executable("basic-dep") {
  can_be_in_process = true
  sources = [ "basic-dep.cc" ]
  shlib_deps = [ ":ld-dep-a" ]
}

test_executable("indirect-deps") {
  can_be_in_process = true
  sources = [ "basic-dep.cc" ]
  shlib_deps = [ ":indirect-deps-a" ]
}

test_shared_library("indirect-deps-a") {
  sources = [ "indirect-deps-a.cc" ]
  deps = [ "//zircon/system/public" ]
  shlib_deps = [
    ":indirect-deps-b",
    ":indirect-deps-c",
  ]
}

test_shared_library("indirect-deps-b") {
  sources = [ "indirect-deps-b.cc" ]
  deps = [ "//zircon/system/public" ]
}

test_shared_library("indirect-deps-c") {
  sources = [ "indirect-deps-c.cc" ]
  deps = [ "//zircon/system/public" ]
}

test_executable("passive-abi-basic") {
  can_be_in_process = true
  sources = [ "passive-abi-basic.cc" ]
  deps = [ "../.." ]
}

test_executable("passive-abi-rdebug") {
  can_be_in_process = true
  sources = [ "passive-abi-rdebug.cc" ]
  deps = [ "../.." ]
}

test_executable("symbolic-namespace") {
  can_be_in_process = true
  sources = [ "symbolic-namespace.cc" ]
  deps = [ "../.." ]
  shlib_deps = [ ":ld-dep-a" ]
}

# These show the dependency graph of the test and the expected return value of
# each dependency's only symbol.
#
# many-deps -> (13 + -8 + 3 + 9 = 17)
#   a -> 13
#   b -> -2 (-2 + 2 + 13 + -21 = -8)
#     c -> 2
#     a -> 13
#     d -> -5 (-5 + -16 = -21)
#       c -> 2
#       e -> -18
#   f -> 3
#   _ld_abi -> 9 (the number of total modules including vdso which may not be
#                 depended on: this is only applicable for many-deps-passive-abi)

test_dep("b") {
  symbol_name = "b"
  value = -2
  dep_symbols = [
    "a",
    "c",
    "d",
  ]
  shlib_deps = [
    ":ld-dep-a",
    ":ld-dep-c",
    ":ld-dep-d",
  ]
}

test_dep("c") {
  symbol_name = "c"
  value = 2
}

test_dep("d") {
  symbol_name = "d"
  value = -5
  dep_symbols = [
    "c",
    "e",
  ]
  shlib_deps = [
    ":ld-dep-c",
    ":ld-dep-e",
  ]
}

test_dep("e") {
  symbol_name = "e"
  value = -18
}

test_dep("f") {
  symbol_name = "f"
  value = 3
}

# This version of many-deps uses a constant number (9) in its return value
# instead of _ld_abi to represent the total number of loaded modules.
test_executable("many-deps") {
  can_be_in_process = true
  sources = [ "many-deps.cc" ]

  shlib_deps = [
    ":ld-dep-a",
    ":ld-dep-b",
    ":ld-dep-f",
  ]
}

# The version of many-deps depends on _ld_abi.
test_executable("passive-abi-many-deps") {
  can_be_in_process = true
  sources = [ "passive-abi-many-deps.cc" ]

  deps = [ "../.." ]
  shlib_deps = [
    ":ld-dep-a",
    ":ld-dep-b",
    ":ld-dep-f",
  ]
}

test_executable("init-fini") {
  can_be_in_process = true
  sources = [ "init-fini.cc" ]
  deps = [ "../.." ]
}

test_executable("tls-exec-only") {
  can_be_in_process = true
  sources = [ "tls-exec-only.cc" ]
  deps = [
    "../..",
    "//src/lib/elfldltl",
  ]

  # workaround for b/349448459 to remote-link successfully
  configs = [ "//build/config:remote_link_scandeps_workaround" ]
}

test_executable("tls-shlib-only") {
  can_be_in_process = true
  sources = [ "tls-shlib-only.cc" ]
  deps = [ "../.." ]
  shlib_deps = [ ":tls-dep" ]
}

test_shared_library("tls-dep") {
  public = [ "tls-dep.h" ]
  sources = [ "tls-dep.cc" ]
  configs = [ "//build/config:no-tlsdesc" ]
  deps = [
    "//sdk/lib/ld:static-tls-get-addr",
    "//zircon/system/public",
  ]

  # TODO(https://fxbug.dev/42085421): LTO insists on using IE accesses here. Remove this
  # when the LLVM bug gets fixed and the fixed toolchain rolled into Fuchsia.
  remove_configs = [ "//build/config/lto" ]
  configs += [ "//build/config/lto:no-lto" ]
}

# This is the same as tls-dep, but without the dep on static-tls-get-addr, so
# that it's possible to test various libc implementations of TLS and avoid the
# transitive dep on ld.so.1.
test_loadable_module("tls-dep-module") {
  public = [ "tls-dep.h" ]
  sources = [ "tls-dep.cc" ]
  configs = [ "//build/config:no-tlsdesc" ]
  deps = [ "//zircon/system/public" ]

  # We need to allow undefined sysmbols, since __tls_get_addr will not be
  # defined by this module or any link-time dependency, but will be supplied by libc.
  remove_configs = [ "//build/config:symbol_no_undefined" ]

  # TODO(https://fxbug.dev/42085421): LTO insists on using IE accesses here. Remove this
  # when the LLVM bug gets fixed and the fixed toolchain rolled into Fuchsia.
  remove_configs += [ "//build/config/lto" ]

  configs += [ "//build/config/lto:no-lto" ]
}

# This is the same as tls-dep but using TLSDESC, with no __tls_get_addr.
test_shared_library("tls-desc-dep") {
  public = [ "tls-dep.h" ]
  sources = [ "tls-dep.cc" ]
  configs = [ "//build/config:tlsdesc" ]
  deps = [ "//zircon/system/public" ]

  # TODO(https://fxbug.dev/42085421): LTO insists on using IE accesses here. Remove this
  # when the LLVM bug gets fixed and the fixed toolchain rolled into Fuchsia.
  remove_configs = [ "//build/config/lto" ]
  configs += [ "//build/config/lto:no-lto" ]
}

# This is the same as tls-dep-module but using TLSDESC, with no __tls_get_addr.
test_loadable_module("tls-desc-dep-module") {
  public = [ "tls-dep.h" ]
  sources = [ "tls-dep.cc" ]
  configs = [ "//build/config:tlsdesc" ]
  deps = [ "//zircon/system/public" ]

  # We need to allow undefined sysmbols, since __tls_get_addr will not be
  # defined by this module or any link-time dependency, but will be supplied by libc.
  remove_configs = [ "//build/config:symbol_no_undefined" ]

  # TODO(https://fxbug.dev/42085421): LTO insists on using IE accesses here. Remove this
  # when the LLVM bug gets fixed and the fixed toolchain rolled into Fuchsia.
  remove_configs += [ "//build/config/lto" ]

  configs += [ "//build/config/lto:no-lto" ]
}

test_executable("tls-exec-shlib") {
  can_be_in_process = true
  sources = [ "tls-exec-shlib.cc" ]
  deps = [ "../.." ]
  shlib_deps = [ ":tls-dep" ]
}

test_executable("tls-ie") {
  can_be_in_process = true
  sources = [ "tls-ie.cc" ]
  deps = [ "../.." ]
  shlib_deps = [ ":tls-ie-dep" ]
}

test_ifs_shared_library("tls-ie-dep-weak") {
  soname = "libtls-ie.so"
  symbols = [
    {
      name = "tls_ie_data"
      type = "Func"
    },
    {
      name = "tls_ie_bss"
      type = "Func"
    },
    {
      # This is not actually defined in the runtime DSO.
      name = "tls_ie_weak"
      type = "TLS"
      size = 4
    },
  ]

  public = [ "tls-ie-dep.h" ]

  data_deps = [ ":tls-ie-dep" ]
}

# The actual tls-ie is an empty library that doesn't define all the symbols
# seen at link time in the IFS-generated link stub.
test_shared_library("tls-ie-dep") {
  public = [ "tls-ie-dep.h" ]
  sources = [ "tls-ie-dep.cc" ]
  deps = [ "//zircon/system/public" ]

  # TODO(https://fxbug.dev/42085421): LTO insists on using LE accesses. Remove
  # this when the LLVM bug gets fixed and the fixed toolchain rolled into
  # Fuchsia.
  remove_configs = [ "//build/config/lto" ]
  configs = [ "//build/config/lto:no-lto" ]
}

test_executable("tls-gd") {
  can_be_in_process = true
  sources = [ "tls-gd.cc" ]
  configs = [ "//build/config:no-tlsdesc" ]
  deps = [ "../.." ]
  shlib_deps = [ ":tls-dep" ]
}

# This is the same as tls-gd, but using TLSDESC.
test_executable("tls-desc") {
  can_be_in_process = true
  sources = [ "tls-gd.cc" ]
  configs = [ "//build/config:tlsdesc" ]
  deps = [ "../.." ]
  shlib_deps = [ ":tls-desc-dep" ]
}

test_executable("tls-ld") {
  can_be_in_process = true
  sources = [ "tls-ld.cc" ]
  configs = [ "//build/config:no-tlsdesc" ]
  deps = [ "../.." ]
  shlib_deps = [ ":tls-ld-dep" ]
}

test_shared_library("tls-ld-dep") {
  public = [ "tls-ld-dep.h" ]
  sources = [ "tls-ld-dep.cc" ]
  configs = [ "//build/config:no-tlsdesc" ]
  deps = [
    "//sdk/lib/ld:static-tls-get-addr",
    "//zircon/system/public",
  ]

  # TODO(https://fxbug.dev/42085421): LTO insists on using IE accesses here. Remove this
  # when the LLVM bug gets fixed and the fixed toolchain rolled into Fuchsia.
  remove_configs = [ "//build/config/lto" ]
  configs += [ "//build/config/lto:no-lto" ]
}

# This will generate the host-test-data for shlib_deps that are not used by any
# executables/modules (but are used in tests).
test_loadable_module("generate-host-test-data") {
  shlib_deps = [
    ":ld-dep-defines-missing-sym",
    ":ld-dep-missing-sym-dep",
  ]
}

# This test shlib will generate build artifacts for :missing-sym-dep.ifs, but
# is not used directly in tests.
test_dep("missing-sym-dep") {
  symbol_name = "this_symbol_is_not_used"
  value = 0
}

test_dep("defines-missing-sym") {
  symbol_name = "missing_sym"
  value = 2
}

# missing-sym: calls missing_sym()
#   - libld-dep-missing-sym-dep -> does not define missing_sym()
test_executable("missing-sym") {
  sources = [ "missing-sym.cc" ]

  # Note this isn't shlib_deps because there's no corresponding .host-test-data
  # subtarget, so instead we have explicit data_deps on the real runtime dep.
  # For Fuchsia this is implicit via the data_deps in ifs_shared_library().
  deps = [ ":missing-sym-dep.ifs" ]
  if (!is_fuchsia) {
    data_deps = [ ":ld-dep-missing-sym-dep.host-test-data($shlib_toolchain)" ]
  }
}

# This is a stub for libld-dep-missing-sym-dep for :missing-sym
test_ifs_shared_library("missing-sym-dep.ifs") {
  soname = "libld-dep-missing-sym-dep.so"
  symbols = [
    {
      name = "missing_sym"
      type = "Func"
    },
  ]

  data_deps = [ ":ld-dep-missing-sym-dep" ]
}

# Includes a symbol provided by a DT_NEEDED (missing-dep-dep) that cannot be
# found:
# missing-dep -> (x) missing-dep-dep
test_executable("missing-dep") {
  sources = [ "missing-dep.cc" ]

  # Note this isn't shlib_deps because there's no corresponding test data.
  deps = [ ":missing-dep-dep" ]
}

test_ifs_shared_library("missing-dep-dep") {
  soname = "libmissing-dep-dep.so"
  symbols = [
    {
      name = "missing_dep_sym"
      type = "Func"
    },
  ]
}

# Includes a symbol that is provided by a dependency of a DT_NEEDED, but that
# dependency cannot be found:
# missing-transitive-dep -> has-missing-dep -> (x) missing-dep-dep
test_executable("missing-transitive-dep") {
  sources = [ "missing-transitive-dep.cc" ]

  shlib_deps = [ ":has-missing-dep" ]
}

# This shared library exports a symbol with a definition that includes another
# symbol provided by a DT_NEEDED (missing-dep-dep) that cannot be found.
test_shared_library("has-missing-dep") {
  sources = [ "has-missing-dep.cc" ]

  # Note this isn't shlib_deps because there's no corresponding test data.
  deps = [
    ":missing-dep-dep",
    "//zircon/system/public",
  ]
}

test_executable("relro") {
  sources = [ "relro.cc" ]
  deps = [ "//zircon/system/public" ]
}

test_executable("fixed-load-address") {
  sources = [ "fixed-load-address.cc" ]
  deps = [ "//src/lib/elfldltl" ]

  # workaround for b/349448459 to remote-link successfully
  configs = [ "//build/config:remote_link_scandeps_workaround" ]
}

test_executable("second-session") {
  sources = [ "second-session.cc" ]

  # Though this is an executable, it has a DT_SONAME and the linker is told to
  # export all its STV_DEFAULT symbols as a shared_library() would by default.
  ldflags = [
    "-Wl,-soname,libsecond-session-test.so.1",
    "-rdynamic",
  ]

  deps = [
    ":indirect-deps-a",
    "//src/zircon/lib/zircon",
    "//zircon/system/public",
    "//zircon/system/ulib/zx",

    # This isn't really necessary as a link-time dependency, though it doesn't
    # hurt (a DT_NEEDED for its own DT_SONAME won't try to add any new module
    # at runtime).  `gn check` requires it because second-session.lib owns the
    # header file.
    ":second-session.lib",
  ]

  data_deps = [ ":second-session-module" ]
}

# This is the link-time dependency necessary for the second-session test's
# secondary dynamic linking domain.
test_ifs_shared_library("second-session.lib") {
  soname = "libsecond-session-test.so.1"
  symbols = [
    {
      name = "defined_in_main_executable"
      type = "Func"
    },
  ]
  public = [ "second-session.h" ]
}

test_loadable_module("second-session-module") {
  sources = [ "second-session-module.cc" ]
  deps = [
    ":second-session-module-deps-a",
    ":second-session.lib",
    ":test-executable.module",
  ]
}

test_shared_library("second-session-module-deps-a") {
  sources = [ "second-session-module-deps-a.cc" ]
  deps = [ "//zircon/system/public" ]
}

test_executable("zygote") {
  can_be_in_process = true
  ldflags = [
    "-Wl,-soname,libzygote-test.so.1",
    "-rdynamic",
  ]
  sources = [ "zygote.cc" ]
  shlib_deps = [ ":zygote-dep" ]
  deps = [
    "//zircon/system/public",

    # This creates a DT_NEEDED on the executable's own SONAME, which should
    # have no effect.  It also grants `gn check` access to the zygote.h header.
    ":zygote.lib",
  ]
}

test_ifs_shared_library("zygote.lib") {
  soname = "libzygote-test.so.1"
  symbols = [
    {
      name = "called_by_zygote_dep"
      type = "Func"
    },
    {
      name = "initialized_data"
      type = "Object"
      size = 8
    },
    {
      name = "zygote_test_main"
      type = "Func"
    },
  ]

  public = [ "zygote.h" ]
}

test_shared_library("zygote-dep") {
  sources = [ "zygote-dep.cc" ]
  deps = [
    ":zygote.lib",
    "//zircon/system/public",
  ]
}

test_executable("zygote-secondary") {
  can_be_in_process = true
  sources = [ "zygote-secondary.cc" ]
  shlib_deps = [ ":zygote-dep" ]
  deps = [
    ":zygote.lib",
    "//zircon/system/public",
  ]
}

# This loop generates a copy of each target with each suffix in
# `per_test_suffices` appended to the target name.
foreach(test, [ "" ] + per_test_suffices) {
  # Add appropriate delimiters to suffices used for filenames and symbols
  suffix = test
  sym_suffix = test
  if (test != "") {
    suffix = ".$test"
    sym_suffix = "_$test"
  }

  test_dep("foo-v1$suffix") {
    symbol_name = "foo$sym_suffix"
    value = 2
  }

  test_dep("foo-v2$suffix") {
    symbol_name = "foo$sym_suffix"
    value = 7
  }

  test_shared_library("has-foo-v1$suffix") {
    defines = [ "TEST_SYMBOL_SUFFIX=$sym_suffix" ]
    sources = [ "foo.cc" ]
    shlib_deps = [ ":ld-dep-foo-v1$suffix" ]
  }

  test_shared_library("has-foo-v2$suffix") {
    defines = [ "TEST_SYMBOL_SUFFIX=$sym_suffix" ]
    sources = [ "foo.cc" ]
    shlib_deps = [ ":ld-dep-foo-v2$suffix" ]
  }

  # bar-v1: bar_v1() calls foo()
  #   - foo-v1 -> foo() returns 2
  test_shared_library("bar-v1$suffix") {
    defines = [ "TEST_SYMBOL_SUFFIX=$sym_suffix" ]
    sources = [ "bar-v1.cc" ]
    shlib_deps = [ ":ld-dep-foo-v1$suffix" ]
  }

  # bar-v2: bar_v2() calls foo()
  #   - foo-v1 -> foo() returns 7
  test_shared_library("bar-v2$suffix") {
    defines = [ "TEST_SYMBOL_SUFFIX=$sym_suffix" ]
    sources = [ "bar-v2.cc" ]
    shlib_deps = [ ":ld-dep-foo-v2$suffix" ]
  }

  # multiple-foo-deps:
  #  - foo-v1 -> foo() returns 2
  #  - foo-v2 -> foo() returns 7
  test_loadable_module("multiple-foo-deps$suffix.module") {
    defines = [ "TEST_SYMBOL_SUFFIX=$sym_suffix" ]
    sources = [ "foo.cc" ]
    shlib_deps = [
      ":ld-dep-foo-v1$suffix",
      ":ld-dep-foo-v2$suffix",
    ]
  }

  # transitive-foo-dep:
  #   - has-foo-v1:
  #     - foo-v1 -> foo() returns 2
  #   - foo-v2 -> foo() returns 7
  test_loadable_module("transitive-foo-dep$suffix.module") {
    defines = [ "TEST_SYMBOL_SUFFIX=$sym_suffix" ]
    sources = [ "foo.cc" ]
    shlib_deps = [
      ":has-foo-v1$suffix",
      ":ld-dep-foo-v2$suffix",
    ]
  }

  # multiple-transitive-foo-deps:
  #   - has-foo-v1:
  #     - foo-v1 -> foo() returns 2
  #   - has-foo-v2:
  #    - foo-v2 -> foo() returns 7
  test_loadable_module("multiple-transitive-foo-deps$suffix.module") {
    shlib_deps = [
      ":has-foo-v1$suffix",
      ":has-foo-v2$suffix",
    ]
  }

  # root-precedence-in-dep-resolution: foo() returns 17
  #   - bar-v1: bar_v1() calls foo()
  #    - foo-v1 -> foo() returns 2
  #   - bar-v2: bar_v2() calls foo()
  #    - foo-v2 -> foo() returns 7
  test_loadable_module("root-precedence-in-dep-resolution$suffix.module") {
    defines = [ "TEST_SYMBOL_SUFFIX=$sym_suffix" ]
    sources = [ "foo-ret-17.cc" ]
    shlib_deps = [
      ":bar-v1$suffix",
      ":bar-v2$suffix",
    ]
  }

  # precedence-in-dep-resolution:
  #   - bar-v1: bar_v1() calls foo()
  #    - foo-v1 -> foo() returns 2
  #   - bar-v2: bar_v2() calls foo()
  #    - foo-v2 -> foo() returns 7
  test_loadable_module("precedence-in-dep-resolution$suffix.module") {
    # This module does not have a source because it's only used to test the
    # resolution order for its dependencies.
    shlib_deps = [
      ":bar-v1$suffix",
      ":bar-v2$suffix",
    ]
  }
}

test_executable("llvm-profdata") {
  can_be_in_process = true
  sources = [ "llvm-profdata.cc" ]
  deps = [
    "//src/lib/llvm-profdata",
    "//zircon/system/ulib/zx",
  ]

  # workaround for b/349448459 to remote-link successfully
  configs = [ "//build/config:remote_link_scandeps_workaround" ]
}

test_executable("backtrace") {
  sources = [ "backtrace.cc" ]
  deps = [ "//zircon/system/public" ]
}
