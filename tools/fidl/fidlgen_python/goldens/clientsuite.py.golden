# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["fidl.clientsuite"]
add_ir_path(_ir_path)


@dataclass
class Empty:
    __fidl_kind__ = "struct"
    __fidl_type__ = "Empty"
    __fidl_raw_type__ = "fidl.clientsuite/Empty"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/Empty"
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class NonEmptyPayload:
    some_field: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "NonEmptyPayload"
    __fidl_raw_type__ = "fidl.clientsuite/NonEmptyPayload"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/NonEmptyPayload"
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class OpenTargetFlexibleTwoWayErrResponse:
    __fidl_kind__ = "struct"
    __fidl_type__ = "OpenTargetFlexibleTwoWayErrResponse"
    __fidl_raw_type__ = "fidl.clientsuite/OpenTarget_FlexibleTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_FlexibleTwoWayErr_Response",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class OpenTargetFlexibleTwoWayResponse:
    __fidl_kind__ = "struct"
    __fidl_type__ = "OpenTargetFlexibleTwoWayResponse"
    __fidl_raw_type__ = "fidl.clientsuite/OpenTarget_FlexibleTwoWay_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_FlexibleTwoWay_Response",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class OpenTargetStrictTwoWayErrResponse:
    __fidl_kind__ = "struct"
    __fidl_type__ = "OpenTargetStrictTwoWayErrResponse"
    __fidl_raw_type__ = "fidl.clientsuite/OpenTarget_StrictTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_StrictTwoWayErr_Response",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class RunnerCallFlexibleOneWayRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallFlexibleOneWayRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallFlexibleOneWayRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallFlexibleOneWayRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallFlexibleTwoWayErrRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallFlexibleTwoWayErrRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallFlexibleTwoWayErrRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallFlexibleTwoWayErrRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallFlexibleTwoWayFieldsErrRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallFlexibleTwoWayFieldsErrRequest"
    __fidl_raw_type__ = (
        "fidl.clientsuite/RunnerCallFlexibleTwoWayFieldsErrRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallFlexibleTwoWayFieldsErrRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallFlexibleTwoWayFieldsRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallFlexibleTwoWayFieldsRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallFlexibleTwoWayFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallFlexibleTwoWayFieldsRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallFlexibleTwoWayRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallFlexibleTwoWayRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallFlexibleTwoWayRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallFlexibleTwoWayRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallOneWayNoRequestRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallOneWayNoRequestRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallOneWayNoRequestRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallOneWayNoRequestRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallOneWayStructRequestRequest:
    target: int
    request: NonEmptyPayload

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallOneWayStructRequestRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallOneWayStructRequestRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallOneWayStructRequestRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "request": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallOneWayTableRequestRequest:
    target: int
    request: TablePayload

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallOneWayTableRequestRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallOneWayTableRequestRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallOneWayTableRequestRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "request": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallOneWayUnionRequestRequest:
    target: int
    request: UnionPayload

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallOneWayUnionRequestRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallOneWayUnionRequestRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallOneWayUnionRequestRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "request": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallStrictOneWayRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallStrictOneWayRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallStrictOneWayRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallStrictOneWayRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallStrictTwoWayErrRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallStrictTwoWayErrRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallStrictTwoWayErrRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallStrictTwoWayErrRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallStrictTwoWayFieldsErrRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallStrictTwoWayFieldsErrRequest"
    __fidl_raw_type__ = (
        "fidl.clientsuite/RunnerCallStrictTwoWayFieldsErrRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallStrictTwoWayFieldsErrRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallStrictTwoWayFieldsRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallStrictTwoWayFieldsRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallStrictTwoWayFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallStrictTwoWayFieldsRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallStrictTwoWayRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallStrictTwoWayRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallStrictTwoWayRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallStrictTwoWayRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallTwoWayNoPayloadRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallTwoWayNoPayloadRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallTwoWayNoPayloadRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallTwoWayNoPayloadRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallTwoWayStructPayloadErrRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallTwoWayStructPayloadErrRequest"
    __fidl_raw_type__ = (
        "fidl.clientsuite/RunnerCallTwoWayStructPayloadErrRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallTwoWayStructPayloadErrRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallTwoWayStructPayloadRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallTwoWayStructPayloadRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallTwoWayStructPayloadRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallTwoWayStructPayloadRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallTwoWayStructRequestRequest:
    target: int
    request: NonEmptyPayload

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallTwoWayStructRequestRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallTwoWayStructRequestRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallTwoWayStructRequestRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "request": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallTwoWayTablePayloadRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallTwoWayTablePayloadRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallTwoWayTablePayloadRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallTwoWayTablePayloadRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallTwoWayTableRequestRequest:
    target: int
    request: TablePayload

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallTwoWayTableRequestRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallTwoWayTableRequestRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallTwoWayTableRequestRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "request": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallTwoWayUnionPayloadRequest:
    target: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallTwoWayUnionPayloadRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallTwoWayUnionPayloadRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallTwoWayUnionPayloadRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerCallTwoWayUnionRequestRequest:
    target: int
    request: UnionPayload

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerCallTwoWayUnionRequestRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerCallTwoWayUnionRequestRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerCallTwoWayUnionRequestRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "request": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerGetVersionResponse:
    version: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerGetVersionResponse"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerGetVersionResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerGetVersionResponse",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "version": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerIsTestEnabledRequest:
    test: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerIsTestEnabledRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerIsTestEnabledRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerIsTestEnabledRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "test": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerIsTestEnabledResponse:
    is_enabled: bool

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerIsTestEnabledResponse"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerIsTestEnabledResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerIsTestEnabledResponse",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "is_enabled": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerReceiveAjarEventsRequest:
    target: int
    reporter: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerReceiveAjarEventsRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerReceiveAjarEventsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerReceiveAjarEventsRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "reporter": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerReceiveClosedEventsRequest:
    target: int
    reporter: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerReceiveClosedEventsRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerReceiveClosedEventsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerReceiveClosedEventsRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "reporter": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class RunnerReceiveOpenEventsRequest:
    target: int
    reporter: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "RunnerReceiveOpenEventsRequest"
    __fidl_raw_type__ = "fidl.clientsuite/RunnerReceiveOpenEventsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/RunnerReceiveOpenEventsRequest",
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "target": None,  # type: ignore[arg-type,unused-ignore]
                "reporter": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class UnknownEvent:
    ordinal: int

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownEvent"
    __fidl_raw_type__ = "fidl.clientsuite/UnknownEvent"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/UnknownEvent"
        )

    # TODO(https://fxbug.dev/394421154): Assigning None (incorrectly) to each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "ordinal": None,  # type: ignore[arg-type,unused-ignore]
            }
        )


@dataclass
class BindingsProperties:
    io_style: int | None

    def __init__(
        self,
        io_style: int | None = None,
    ) -> None:
        self.io_style = io_style

    __fidl_kind__ = "table"
    __fidl_type__ = "BindingsProperties"
    __fidl_raw_type__ = "fidl.clientsuite/BindingsProperties"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/BindingsProperties"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class TablePayload:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "TablePayload"
    __fidl_raw_type__ = "fidl.clientsuite/TablePayload"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/TablePayload"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


class AjarTargetEventReport:
    _fidl_error: typing.Optional[int]
    _unknown_event: typing.Optional[UnknownEvent]

    __fidl_kind__ = "union"
    __fidl_type__ = "AjarTargetEventReport"
    __fidl_raw_type__ = "fidl.clientsuite/AjarTargetEventReport"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.fidl_error != other.fidl_error:
            return False
        if self.unknown_event != other.unknown_event:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        if self.unknown_event:
            variant = f"unknown_event={self.unknown_event!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        fidl_error: typing.Optional[int] = None,
        unknown_event: typing.Optional[UnknownEvent] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if unknown_event is not None:
            self._unknown_event = unknown_event
            variants.append("unknown_event")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    @property
    def unknown_event(self) -> UnknownEvent | None:
        return getattr(self, "_unknown_event", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/AjarTargetEventReport"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ClosedTargetEventReport:
    _fidl_error: typing.Optional[int]
    _on_event_no_payload: typing.Optional[Empty]
    _on_event_struct_payload: typing.Optional[NonEmptyPayload]
    _on_event_table_payload: typing.Optional[TablePayload]
    _on_event_union_payload: typing.Optional[UnionPayload]

    __fidl_kind__ = "union"
    __fidl_type__ = "ClosedTargetEventReport"
    __fidl_raw_type__ = "fidl.clientsuite/ClosedTargetEventReport"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.fidl_error != other.fidl_error:
            return False
        if self.on_event_no_payload != other.on_event_no_payload:
            return False
        if self.on_event_struct_payload != other.on_event_struct_payload:
            return False
        if self.on_event_table_payload != other.on_event_table_payload:
            return False
        if self.on_event_union_payload != other.on_event_union_payload:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        if self.on_event_no_payload:
            variant = f"on_event_no_payload={self.on_event_no_payload!r}"
        if self.on_event_struct_payload:
            variant = (
                f"on_event_struct_payload={self.on_event_struct_payload!r}"
            )
        if self.on_event_table_payload:
            variant = f"on_event_table_payload={self.on_event_table_payload!r}"
        if self.on_event_union_payload:
            variant = f"on_event_union_payload={self.on_event_union_payload!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        fidl_error: typing.Optional[int] = None,
        on_event_no_payload: typing.Optional[Empty] = None,
        on_event_struct_payload: typing.Optional[NonEmptyPayload] = None,
        on_event_table_payload: typing.Optional[TablePayload] = None,
        on_event_union_payload: typing.Optional[UnionPayload] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if on_event_no_payload is not None:
            self._on_event_no_payload = on_event_no_payload
            variants.append("on_event_no_payload")
            number_of_variants += 1
        if on_event_struct_payload is not None:
            self._on_event_struct_payload = on_event_struct_payload
            variants.append("on_event_struct_payload")
            number_of_variants += 1
        if on_event_table_payload is not None:
            self._on_event_table_payload = on_event_table_payload
            variants.append("on_event_table_payload")
            number_of_variants += 1
        if on_event_union_payload is not None:
            self._on_event_union_payload = on_event_union_payload
            variants.append("on_event_union_payload")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    @property
    def on_event_no_payload(self) -> Empty | None:
        return getattr(self, "_on_event_no_payload", None)

    @property
    def on_event_struct_payload(self) -> NonEmptyPayload | None:
        return getattr(self, "_on_event_struct_payload", None)

    @property
    def on_event_table_payload(self) -> TablePayload | None:
        return getattr(self, "_on_event_table_payload", None)

    @property
    def on_event_union_payload(self) -> UnionPayload | None:
        return getattr(self, "_on_event_union_payload", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/ClosedTargetEventReport"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ClosedTargetTwoWayStructPayloadErrResult:
    _response: typing.Optional[NonEmptyPayload]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "ClosedTargetTwoWayStructPayloadErrResult"
    __fidl_raw_type__ = (
        "fidl.clientsuite/ClosedTarget_TwoWayStructPayloadErr_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[NonEmptyPayload] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> NonEmptyPayload | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/ClosedTarget_TwoWayStructPayloadErr_Result",
        )

    def unwrap(self) -> NonEmptyPayload:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class EmptyResultClassification:
    _success: typing.Optional[Empty]
    _fidl_error: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "EmptyResultClassification"
    __fidl_raw_type__ = "fidl.clientsuite/EmptyResultClassification"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.success != other.success:
            return False
        if self.fidl_error != other.fidl_error:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.success:
            variant = f"success={self.success!r}"
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        success: typing.Optional[Empty] = None,
        fidl_error: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if success is not None:
            self._success = success
            variants.append("success")
            number_of_variants += 1
        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def success(self) -> Empty | None:
        return getattr(self, "_success", None)

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/EmptyResultClassification",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class EmptyResultWithErrorClassification:
    _success: typing.Optional[Empty]
    _application_error: typing.Optional[int]
    _fidl_error: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "EmptyResultWithErrorClassification"
    __fidl_raw_type__ = "fidl.clientsuite/EmptyResultWithErrorClassification"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.success != other.success:
            return False
        if self.application_error != other.application_error:
            return False
        if self.fidl_error != other.fidl_error:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.success:
            variant = f"success={self.success!r}"
        if self.application_error:
            variant = f"application_error={self.application_error!r}"
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        success: typing.Optional[Empty] = None,
        application_error: typing.Optional[int] = None,
        fidl_error: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if success is not None:
            self._success = success
            variants.append("success")
            number_of_variants += 1
        if application_error is not None:
            self._application_error = application_error
            variants.append("application_error")
            number_of_variants += 1
        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def success(self) -> Empty | None:
        return getattr(self, "_success", None)

    @property
    def application_error(self) -> int | None:
        return getattr(self, "_application_error", None)

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/EmptyResultWithErrorClassification",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class NonEmptyResultClassification:
    _success: typing.Optional[NonEmptyPayload]
    _fidl_error: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "NonEmptyResultClassification"
    __fidl_raw_type__ = "fidl.clientsuite/NonEmptyResultClassification"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.success != other.success:
            return False
        if self.fidl_error != other.fidl_error:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.success:
            variant = f"success={self.success!r}"
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        success: typing.Optional[NonEmptyPayload] = None,
        fidl_error: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if success is not None:
            self._success = success
            variants.append("success")
            number_of_variants += 1
        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def success(self) -> NonEmptyPayload | None:
        return getattr(self, "_success", None)

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/NonEmptyResultClassification",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class NonEmptyResultWithErrorClassification:
    _success: typing.Optional[NonEmptyPayload]
    _application_error: typing.Optional[int]
    _fidl_error: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "NonEmptyResultWithErrorClassification"
    __fidl_raw_type__ = "fidl.clientsuite/NonEmptyResultWithErrorClassification"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.success != other.success:
            return False
        if self.application_error != other.application_error:
            return False
        if self.fidl_error != other.fidl_error:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.success:
            variant = f"success={self.success!r}"
        if self.application_error:
            variant = f"application_error={self.application_error!r}"
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        success: typing.Optional[NonEmptyPayload] = None,
        application_error: typing.Optional[int] = None,
        fidl_error: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if success is not None:
            self._success = success
            variants.append("success")
            number_of_variants += 1
        if application_error is not None:
            self._application_error = application_error
            variants.append("application_error")
            number_of_variants += 1
        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def success(self) -> NonEmptyPayload | None:
        return getattr(self, "_success", None)

    @property
    def application_error(self) -> int | None:
        return getattr(self, "_application_error", None)

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/NonEmptyResultWithErrorClassification",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class OpenTargetEventReport:
    _fidl_error: typing.Optional[int]
    _unknown_event: typing.Optional[UnknownEvent]
    _strict_event: typing.Optional[Empty]
    _flexible_event: typing.Optional[Empty]

    __fidl_kind__ = "union"
    __fidl_type__ = "OpenTargetEventReport"
    __fidl_raw_type__ = "fidl.clientsuite/OpenTargetEventReport"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.fidl_error != other.fidl_error:
            return False
        if self.unknown_event != other.unknown_event:
            return False
        if self.strict_event != other.strict_event:
            return False
        if self.flexible_event != other.flexible_event:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        if self.unknown_event:
            variant = f"unknown_event={self.unknown_event!r}"
        if self.strict_event:
            variant = f"strict_event={self.strict_event!r}"
        if self.flexible_event:
            variant = f"flexible_event={self.flexible_event!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        fidl_error: typing.Optional[int] = None,
        unknown_event: typing.Optional[UnknownEvent] = None,
        strict_event: typing.Optional[Empty] = None,
        flexible_event: typing.Optional[Empty] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if unknown_event is not None:
            self._unknown_event = unknown_event
            variants.append("unknown_event")
            number_of_variants += 1
        if strict_event is not None:
            self._strict_event = strict_event
            variants.append("strict_event")
            number_of_variants += 1
        if flexible_event is not None:
            self._flexible_event = flexible_event
            variants.append("flexible_event")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    @property
    def unknown_event(self) -> UnknownEvent | None:
        return getattr(self, "_unknown_event", None)

    @property
    def strict_event(self) -> Empty | None:
        return getattr(self, "_strict_event", None)

    @property
    def flexible_event(self) -> Empty | None:
        return getattr(self, "_flexible_event", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/OpenTargetEventReport"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class OpenTargetFlexibleTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "OpenTargetFlexibleTwoWayErrResult"
    __fidl_raw_type__ = "fidl.clientsuite/OpenTarget_FlexibleTwoWayErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_FlexibleTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class OpenTargetFlexibleTwoWayFieldsErrResult:
    _response: typing.Optional[NonEmptyPayload]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "OpenTargetFlexibleTwoWayFieldsErrResult"
    __fidl_raw_type__ = (
        "fidl.clientsuite/OpenTarget_FlexibleTwoWayFieldsErr_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[NonEmptyPayload] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> NonEmptyPayload | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_FlexibleTwoWayFieldsErr_Result",
        )

    def unwrap(self) -> NonEmptyPayload:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class OpenTargetFlexibleTwoWayFieldsResult:
    _response: typing.Optional[NonEmptyPayload]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "OpenTargetFlexibleTwoWayFieldsResult"
    __fidl_raw_type__ = (
        "fidl.clientsuite/OpenTarget_FlexibleTwoWayFields_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[NonEmptyPayload] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> NonEmptyPayload | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_FlexibleTwoWayFields_Result",
        )

    def unwrap(self) -> NonEmptyPayload:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class OpenTargetFlexibleTwoWayResult:
    _response: typing.Optional[None]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "OpenTargetFlexibleTwoWayResult"
    __fidl_raw_type__ = "fidl.clientsuite/OpenTarget_FlexibleTwoWay_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_FlexibleTwoWay_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class OpenTargetStrictTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "OpenTargetStrictTwoWayErrResult"
    __fidl_raw_type__ = "fidl.clientsuite/OpenTarget_StrictTwoWayErr_Result"
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_StrictTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class OpenTargetStrictTwoWayFieldsErrResult:
    _response: typing.Optional[NonEmptyPayload]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "OpenTargetStrictTwoWayFieldsErrResult"
    __fidl_raw_type__ = (
        "fidl.clientsuite/OpenTarget_StrictTwoWayFieldsErr_Result"
    )
    _is_result = True

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[NonEmptyPayload] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> NonEmptyPayload | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/OpenTarget_StrictTwoWayFieldsErr_Result",
        )

    def unwrap(self) -> NonEmptyPayload:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise AssertionError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise AssertionError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class TableResultClassification:
    _success: typing.Optional[TablePayload]
    _fidl_error: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "TableResultClassification"
    __fidl_raw_type__ = "fidl.clientsuite/TableResultClassification"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.success != other.success:
            return False
        if self.fidl_error != other.fidl_error:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.success:
            variant = f"success={self.success!r}"
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        success: typing.Optional[TablePayload] = None,
        fidl_error: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if success is not None:
            self._success = success
            variants.append("success")
            number_of_variants += 1
        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def success(self) -> TablePayload | None:
        return getattr(self, "_success", None)

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/TableResultClassification",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionPayload:
    _some_variant: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionPayload"
    __fidl_raw_type__ = "fidl.clientsuite/UnionPayload"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_variant != other.some_variant:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_variant:
            variant = f"some_variant={self.some_variant!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_variant: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_variant is not None:
            self._some_variant = some_variant
            variants.append("some_variant")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_variant(self) -> int | None:
        return getattr(self, "_some_variant", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "fidl.clientsuite", "fidl.clientsuite/UnionPayload"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionResultClassification:
    _success: typing.Optional[UnionPayload]
    _fidl_error: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionResultClassification"
    __fidl_raw_type__ = "fidl.clientsuite/UnionResultClassification"
    _is_result = False

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.success != other.success:
            return False
        if self.fidl_error != other.fidl_error:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.success:
            variant = f"success={self.success!r}"
        if self.fidl_error:
            variant = f"fidl_error={self.fidl_error!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        success: typing.Optional[UnionPayload] = None,
        fidl_error: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if success is not None:
            self._success = success
            variants.append("success")
            number_of_variants += 1
        if fidl_error is not None:
            self._fidl_error = fidl_error
            variants.append("fidl_error")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def success(self) -> UnionPayload | None:
        return getattr(self, "_success", None)

    @property
    def fidl_error(self) -> int | None:
        return getattr(self, "_fidl_error", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "fidl.clientsuite",
            "fidl.clientsuite/UnionResultClassification",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


FidlErrorKind = enum.IntEnum(
    "FidlErrorKind",
    {
        "__fidl_kind__": "enum",
        "__fidl_type__": "FidlErrorKind",
        "__fidl_raw_type__": "fidl.clientsuite/FidlErrorKind",
        "__strict__": True,
        "OTHER_ERROR": 1,
        "DECODING_ERROR": 2,
        "CHANNEL_PEER_CLOSED": 3,
        "UNKNOWN_METHOD": 4,
        "UNEXPECTED_MESSAGE": 5,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


IoStyle = enum.IntEnum(
    "IoStyle",
    {
        "__fidl_kind__": "enum",
        "__fidl_type__": "IoStyle",
        "__fidl_raw_type__": "fidl.clientsuite/IoStyle",
        "__strict__": True,
        "SYNC": 1,
        "ASYNC": 2,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


Test = enum.IntEnum(
    "Test",
    {
        "__fidl_kind__": "enum",
        "__fidl_type__": "Test",
        "__fidl_raw_type__": "fidl.clientsuite/Test",
        "__strict__": False,
        "SETUP": 1,
        "TWO_WAY_NO_PAYLOAD": 2,
        "TWO_WAY_STRUCT_PAYLOAD": 42,
        "TWO_WAY_TABLE_PAYLOAD": 43,
        "TWO_WAY_UNION_PAYLOAD": 44,
        "TWO_WAY_RESULT_WITH_PAYLOAD": 45,
        "TWO_WAY_RESULT_WITH_ERROR": 46,
        "TWO_WAY_STRUCT_REQUEST": 52,
        "TWO_WAY_TABLE_REQUEST": 53,
        "TWO_WAY_UNION_REQUEST": 54,
        "ONE_WAY_NO_REQUEST": 48,
        "ONE_WAY_STRUCT_REQUEST": 49,
        "ONE_WAY_TABLE_REQUEST": 50,
        "ONE_WAY_UNION_REQUEST": 51,
        "RECEIVE_EVENT_NO_PAYLOAD": 55,
        "RECEIVE_EVENT_STRUCT_PAYLOAD": 56,
        "RECEIVE_EVENT_TABLE_PAYLOAD": 57,
        "RECEIVE_EVENT_UNION_PAYLOAD": 58,
        "GRACEFUL_FAILURE_DURING_CALL_AFTER_PEER_CLOSE": 3,
        "RECEIVE_EVENT_BAD_MAGIC_NUMBER": 60,
        "RECEIVE_EVENT_UNEXPECTED_TXID": 61,
        "RECEIVE_EVENT_UNKNOWN_ORDINAL": 62,
        "RECEIVE_RESPONSE_BAD_MAGIC_NUMBER": 63,
        "RECEIVE_RESPONSE_UNEXPECTED_TXID": 64,
        "RECEIVE_RESPONSE_WRONG_ORDINAL_KNOWN": 65,
        "RECEIVE_RESPONSE_WRONG_ORDINAL_UNKNOWN": 67,
        "V1_TWO_WAY_NO_PAYLOAD": 40,
        "V1_TWO_WAY_STRUCT_PAYLOAD": 41,
        "ONE_WAY_CALL_DO_NOT_REPORT_PEER_CLOSED": 59,
        "ONE_WAY_STRICT_SEND": 4,
        "ONE_WAY_FLEXIBLE_SEND": 5,
        "TWO_WAY_STRICT_SEND": 6,
        "TWO_WAY_STRICT_SEND_MISMATCHED_STRICTNESS": 7,
        "TWO_WAY_STRICT_SEND_NON_EMPTY_PAYLOAD": 38,
        "TWO_WAY_STRICT_ERROR_SYNTAX_SEND_SUCCESS_RESPONSE": 8,
        "TWO_WAY_STRICT_ERROR_SYNTAX_SEND_ERROR_RESPONSE": 9,
        "TWO_WAY_STRICT_ERROR_SYNTAX_SEND_UNKNOWN_METHOD_RESPONSE": 10,
        "TWO_WAY_STRICT_ERROR_SYNTAX_SEND_MISMATCHED_STRICTNESS_UNKNOWN_METHOD_RESPONSE": 11,
        "TWO_WAY_STRICT_ERROR_SYNTAX_SEND_NON_EMPTY_PAYLOAD": 39,
        "TWO_WAY_FLEXIBLE_SEND_SUCCESS_RESPONSE": 12,
        "TWO_WAY_FLEXIBLE_SEND_ERROR_RESPONSE": 13,
        "TWO_WAY_FLEXIBLE_SEND_UNKNOWN_METHOD_RESPONSE": 14,
        "TWO_WAY_FLEXIBLE_SEND_MISMATCHED_STRICTNESS_UNKNOWN_METHOD_RESPONSE": 15,
        "TWO_WAY_FLEXIBLE_SEND_OTHER_FRAMEWORK_ERR_RESPONSE": 16,
        "TWO_WAY_FLEXIBLE_SEND_NON_EMPTY_PAYLOAD_SUCCESS_RESPONSE": 17,
        "TWO_WAY_FLEXIBLE_SEND_NON_EMPTY_PAYLOAD_UNKNOWN_METHOD_RESPONSE": 18,
        "TWO_WAY_FLEXIBLE_ERROR_SYNTAX_SEND_SUCCESS_RESPONSE": 19,
        "TWO_WAY_FLEXIBLE_ERROR_SYNTAX_SEND_ERROR_RESPONSE": 20,
        "TWO_WAY_FLEXIBLE_ERROR_SYNTAX_SEND_UNKNOWN_METHOD_RESPONSE": 21,
        "TWO_WAY_FLEXIBLE_ERROR_SYNTAX_SEND_MISMATCHED_STRICTNESS_UNKNOWN_METHOD_RESPONSE": 22,
        "TWO_WAY_FLEXIBLE_ERROR_SYNTAX_SEND_OTHER_FRAMEWORK_ERR_RESPONSE": 23,
        "TWO_WAY_FLEXIBLE_ERROR_SYNTAX_SEND_NON_EMPTY_PAYLOAD_SUCCESS_RESPONSE": 24,
        "TWO_WAY_FLEXIBLE_ERROR_SYNTAX_SEND_NON_EMPTY_PAYLOAD_UNKNOWN_METHOD_RESPONSE": 25,
        "RECEIVE_STRICT_EVENT": 26,
        "RECEIVE_STRICT_EVENT_MISMATCHED_STRICTNESS": 27,
        "RECEIVE_FLEXIBLE_EVENT": 28,
        "RECEIVE_FLEXIBLE_EVENT_MISMATCHED_STRICTNESS": 29,
        "UNKNOWN_STRICT_EVENT_OPEN_PROTOCOL": 30,
        "UNKNOWN_FLEXIBLE_EVENT_OPEN_PROTOCOL": 31,
        "UNKNOWN_STRICT_EVENT_AJAR_PROTOCOL": 32,
        "UNKNOWN_FLEXIBLE_EVENT_AJAR_PROTOCOL": 33,
        "UNKNOWN_STRICT_EVENT_CLOSED_PROTOCOL": 34,
        "UNKNOWN_FLEXIBLE_EVENT_CLOSED_PROTOCOL": 35,
        "UNKNOWN_STRICT_SERVER_INITIATED_TWO_WAY": 36,
        "UNKNOWN_FLEXIBLE_SERVER_INITIATED_TWO_WAY": 37,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


# Generated constants
CLIENT_SUITE_VERSION: int = 1


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class AjarTargetServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class AjarTargetClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "fidl.clientsuite"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


class AjarTargetEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


AjarTargetMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) fidl.clientsuite/AjarTarget"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class AjarTargetEventReporterServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {
        5150872472050569784: MethodInfo(
            name="report_event",
            request_ident="fidl.clientsuite/AjarTargetEventReport",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_report_event: typing.TypeAlias = None

    @abstractmethod
    def report_event(
        self,
        request: AjarTargetEventReport,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_report_event]
        | _MethodResponse_report_event
    ):
        ...


class AjarTargetEventReporterClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "fidl.clientsuite"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def report_event(
        self,
        *,
        fidl_error: int | None = None,
        unknown_event: UnknownEvent | None = None,
    ) -> None:
        msg = AjarTargetEventReport(
            fidl_error,
            unknown_event,
        )

        self._send_one_way_fidl_request(
            0,
            5150872472050569784,
            "fidl.clientsuite",
            msg,
        )


class AjarTargetEventReporterEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


AjarTargetEventReporterMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) fidl.clientsuite/AjarTargetEventReporter"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class ClosedTargetServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {
        8823160117673072416: MethodInfo(
            name="two_way_no_payload",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        4197391242806919613: MethodInfo(
            name="two_way_struct_payload",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/NonEmptyPayload",
        ),
        6034278263774013116: MethodInfo(
            name="two_way_table_payload",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/TablePayload",
        ),
        2303581613023334284: MethodInfo(
            name="two_way_union_payload",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/UnionPayload",
        ),
        7112457167486827531: MethodInfo(
            name="two_way_struct_payload_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="fidl.clientsuite/ClosedTarget_TwoWayStructPayloadErr_Result",
        ),
        5762209808438257078: MethodInfo(
            name="two_way_struct_request",
            request_ident="fidl.clientsuite/NonEmptyPayload",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        4411466441619884495: MethodInfo(
            name="two_way_table_request",
            request_ident="fidl.clientsuite/TablePayload",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        8852700443574767223: MethodInfo(
            name="two_way_union_request",
            request_ident="fidl.clientsuite/UnionPayload",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        880285710761691653: MethodInfo(
            name="one_way_no_request",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        2745184144532233426: MethodInfo(
            name="one_way_struct_request",
            request_ident="fidl.clientsuite/NonEmptyPayload",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        1894745725882679327: MethodInfo(
            name="one_way_table_request",
            request_ident="fidl.clientsuite/TablePayload",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        1453322211393998309: MethodInfo(
            name="one_way_union_request",
            request_ident="fidl.clientsuite/UnionPayload",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_two_way_no_payload: typing.TypeAlias = None

    @abstractmethod
    def two_way_no_payload(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_two_way_no_payload
        ]
        | _MethodResponse_two_way_no_payload
    ):
        ...

    _MethodResponse_two_way_struct_payload: typing.TypeAlias = NonEmptyPayload

    @abstractmethod
    def two_way_struct_payload(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_two_way_struct_payload
        ]
        | _MethodResponse_two_way_struct_payload
    ):
        ...

    _MethodResponse_two_way_table_payload: typing.TypeAlias = TablePayload

    @abstractmethod
    def two_way_table_payload(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_two_way_table_payload
        ]
        | _MethodResponse_two_way_table_payload
    ):
        ...

    _MethodResponse_two_way_union_payload: typing.TypeAlias = UnionPayload

    @abstractmethod
    def two_way_union_payload(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_two_way_union_payload
        ]
        | _MethodResponse_two_way_union_payload
    ):
        ...

    _MethodResponse_two_way_struct_payload_err: typing.TypeAlias = typing.Union[
        DomainError,
        NonEmptyPayload,
    ]

    @abstractmethod
    def two_way_struct_payload_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_two_way_struct_payload_err
        ]
        | _MethodResponse_two_way_struct_payload_err
    ):
        ...

    _MethodResponse_two_way_struct_request: typing.TypeAlias = None

    @abstractmethod
    def two_way_struct_request(
        self,
        request: NonEmptyPayload,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_two_way_struct_request
        ]
        | _MethodResponse_two_way_struct_request
    ):
        ...

    _MethodResponse_two_way_table_request: typing.TypeAlias = None

    @abstractmethod
    def two_way_table_request(
        self,
        request: TablePayload,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_two_way_table_request
        ]
        | _MethodResponse_two_way_table_request
    ):
        ...

    _MethodResponse_two_way_union_request: typing.TypeAlias = None

    @abstractmethod
    def two_way_union_request(
        self,
        request: UnionPayload,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_two_way_union_request
        ]
        | _MethodResponse_two_way_union_request
    ):
        ...

    _MethodResponse_one_way_no_request: typing.TypeAlias = None

    @abstractmethod
    def one_way_no_request(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_one_way_no_request
        ]
        | _MethodResponse_one_way_no_request
    ):
        ...

    _MethodResponse_one_way_struct_request: typing.TypeAlias = None

    @abstractmethod
    def one_way_struct_request(
        self,
        request: NonEmptyPayload,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_one_way_struct_request
        ]
        | _MethodResponse_one_way_struct_request
    ):
        ...

    _MethodResponse_one_way_table_request: typing.TypeAlias = None

    @abstractmethod
    def one_way_table_request(
        self,
        request: TablePayload,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_one_way_table_request
        ]
        | _MethodResponse_one_way_table_request
    ):
        ...

    _MethodResponse_one_way_union_request: typing.TypeAlias = None

    @abstractmethod
    def one_way_union_request(
        self,
        request: UnionPayload,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_one_way_union_request
        ]
        | _MethodResponse_one_way_union_request
    ):
        ...

    def on_event_no_payload(
        self,
    ) -> None:
        msg = None
        self._send_event(5685716274827179686, "fidl.clientsuite", msg)

    def on_event_struct_payload(
        self,
        *,
        some_field: int,
    ) -> None:
        msg = NonEmptyPayload(
            some_field,
        )
        self._send_event(5253669518495638118, "fidl.clientsuite", msg)

    def on_event_table_payload(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = TablePayload(
            some_field,
        )
        self._send_event(8251567748156745542, "fidl.clientsuite", msg)

    def on_event_union_payload(
        self,
        *,
        some_variant: int | None = None,
    ) -> None:
        msg = UnionPayload(
            some_variant,
        )
        self._send_event(7621842152112557728, "fidl.clientsuite", msg)


class ClosedTargetClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "fidl.clientsuite"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def two_way_no_payload(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = None
        return self._send_two_way_fidl_request(
            8823160117673072416,
            "fidl.clientsuite",
            msg,
            "",
        )

    def two_way_struct_payload(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, NonEmptyPayload]:
        msg = None
        return self._send_two_way_fidl_request(
            4197391242806919613,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/NonEmptyPayload"
            ),
        )

    def two_way_table_payload(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, TablePayload]:
        msg = None
        return self._send_two_way_fidl_request(
            6034278263774013116,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/TablePayload"
            ),
        )

    def two_way_union_payload(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, UnionPayload]:
        msg = None
        return self._send_two_way_fidl_request(
            2303581613023334284,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/UnionPayload"
            ),
        )

    def two_way_struct_payload_err(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, ClosedTargetTwoWayStructPayloadErrResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            7112457167486827531,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/ClosedTarget_TwoWayStructPayloadErr_Result"
            ),
        )

    def two_way_struct_request(
        self,
        *,
        some_field: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = NonEmptyPayload(
            some_field,
        )
        return self._send_two_way_fidl_request(
            5762209808438257078,
            "fidl.clientsuite",
            msg,
            "",
        )

    def two_way_table_request(
        self,
        *,
        some_field: int | None = None,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = TablePayload(
            some_field,
        )
        return self._send_two_way_fidl_request(
            4411466441619884495,
            "fidl.clientsuite",
            msg,
            "",
        )

    def two_way_union_request(
        self,
        *,
        some_variant: int | None = None,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = UnionPayload(
            some_variant,
        )
        return self._send_two_way_fidl_request(
            8852700443574767223,
            "fidl.clientsuite",
            msg,
            "",
        )

    def one_way_no_request(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            880285710761691653,
            "fidl.clientsuite",
            msg,
        )

    def one_way_struct_request(
        self,
        *,
        some_field: int,
    ) -> None:
        msg = NonEmptyPayload(
            some_field,
        )

        self._send_one_way_fidl_request(
            0,
            2745184144532233426,
            "fidl.clientsuite",
            msg,
        )

    def one_way_table_request(
        self,
        *,
        some_field: int | None = None,
    ) -> None:
        msg = TablePayload(
            some_field,
        )

        self._send_one_way_fidl_request(
            0,
            1894745725882679327,
            "fidl.clientsuite",
            msg,
        )

    def one_way_union_request(
        self,
        *,
        some_variant: int | None = None,
    ) -> None:
        msg = UnionPayload(
            some_variant,
        )

        self._send_one_way_fidl_request(
            0,
            1453322211393998309,
            "fidl.clientsuite",
            msg,
        )


class ClosedTargetEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {
        5685716274827179686: MethodInfo(
            name="on_event_no_payload",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        5253669518495638118: MethodInfo(
            name="on_event_struct_payload",
            request_ident="fidl.clientsuite/NonEmptyPayload",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        8251567748156745542: MethodInfo(
            name="on_event_table_payload",
            request_ident="fidl.clientsuite/TablePayload",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        7621842152112557728: MethodInfo(
            name="on_event_union_payload",
            request_ident="fidl.clientsuite/UnionPayload",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def on_event_no_payload(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def on_event_struct_payload(
        self,
        request: NonEmptyPayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def on_event_table_payload(
        self,
        request: TablePayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def on_event_union_payload(
        self,
        request: UnionPayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


ClosedTargetMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) fidl.clientsuite/ClosedTarget"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class ClosedTargetEventReporterServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {
        7172279718796493934: MethodInfo(
            name="report_event",
            request_ident="fidl.clientsuite/ClosedTargetEventReport",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_report_event: typing.TypeAlias = None

    @abstractmethod
    def report_event(
        self,
        request: ClosedTargetEventReport,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_report_event]
        | _MethodResponse_report_event
    ):
        ...


class ClosedTargetEventReporterClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "fidl.clientsuite"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def report_event(
        self,
        *,
        fidl_error: int | None = None,
        on_event_no_payload: Empty | None = None,
        on_event_struct_payload: NonEmptyPayload | None = None,
        on_event_table_payload: TablePayload | None = None,
        on_event_union_payload: UnionPayload | None = None,
    ) -> None:
        msg = ClosedTargetEventReport(
            fidl_error,
            on_event_no_payload,
            on_event_struct_payload,
            on_event_table_payload,
            on_event_union_payload,
        )

        self._send_one_way_fidl_request(
            0,
            7172279718796493934,
            "fidl.clientsuite",
            msg,
        )


class ClosedTargetEventReporterEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


ClosedTargetEventReporterMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) fidl.clientsuite/ClosedTargetEventReporter"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class OpenTargetServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {
        7904024199254697828: MethodInfo(
            name="strict_one_way",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        1119507890521778684: MethodInfo(
            name="flexible_one_way",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
        995098632483095874: MethodInfo(
            name="strict_two_way",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        8775166568163566307: MethodInfo(
            name="strict_two_way_fields",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/NonEmptyPayload",
        ),
        6063427118545698440: MethodInfo(
            name="strict_two_way_err",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="fidl.clientsuite/OpenTarget_StrictTwoWayErr_Result",
        ),
        9059738677182539537: MethodInfo(
            name="strict_two_way_fields_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="fidl.clientsuite/OpenTarget_StrictTwoWayFieldsErr_Result",
        ),
        7373850992214410631: MethodInfo(
            name="flexible_two_way",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="fidl.clientsuite/OpenTarget_FlexibleTwoWay_Result",
        ),
        4087393006943873764: MethodInfo(
            name="flexible_two_way_fields",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="fidl.clientsuite/OpenTarget_FlexibleTwoWayFields_Result",
        ),
        7932048879253591162: MethodInfo(
            name="flexible_two_way_err",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=True,
            response_identifier="fidl.clientsuite/OpenTarget_FlexibleTwoWayErr_Result",
        ),
        1029425766479692362: MethodInfo(
            name="flexible_two_way_fields_err",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=True,
            response_identifier="fidl.clientsuite/OpenTarget_FlexibleTwoWayFieldsErr_Result",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_strict_one_way: typing.TypeAlias = None

    @abstractmethod
    def strict_one_way(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_strict_one_way]
        | _MethodResponse_strict_one_way
    ):
        ...

    _MethodResponse_flexible_one_way: typing.TypeAlias = None

    @abstractmethod
    def flexible_one_way(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_one_way
        ]
        | _MethodResponse_flexible_one_way
    ):
        ...

    _MethodResponse_strict_two_way: typing.TypeAlias = None

    @abstractmethod
    def strict_two_way(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_strict_two_way]
        | _MethodResponse_strict_two_way
    ):
        ...

    _MethodResponse_strict_two_way_fields: typing.TypeAlias = NonEmptyPayload

    @abstractmethod
    def strict_two_way_fields(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_fields
        ]
        | _MethodResponse_strict_two_way_fields
    ):
        ...

    _MethodResponse_strict_two_way_err: typing.TypeAlias = typing.Union[
        DomainError,
        None,
    ]

    @abstractmethod
    def strict_two_way_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_err
        ]
        | _MethodResponse_strict_two_way_err
    ):
        ...

    _MethodResponse_strict_two_way_fields_err: typing.TypeAlias = typing.Union[
        DomainError,
        NonEmptyPayload,
    ]

    @abstractmethod
    def strict_two_way_fields_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_strict_two_way_fields_err
        ]
        | _MethodResponse_strict_two_way_fields_err
    ):
        ...

    _MethodResponse_flexible_two_way: typing.TypeAlias = typing.Union[
        FrameworkError,
        None,
    ]

    @abstractmethod
    def flexible_two_way(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way
        ]
        | _MethodResponse_flexible_two_way
    ):
        ...

    _MethodResponse_flexible_two_way_fields: typing.TypeAlias = typing.Union[
        FrameworkError,
        NonEmptyPayload,
    ]

    @abstractmethod
    def flexible_two_way_fields(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_fields
        ]
        | _MethodResponse_flexible_two_way_fields
    ):
        ...

    _MethodResponse_flexible_two_way_err: typing.TypeAlias = typing.Union[
        FrameworkError,
        DomainError,
        None,
    ]

    @abstractmethod
    def flexible_two_way_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_err
        ]
        | _MethodResponse_flexible_two_way_err
    ):
        ...

    _MethodResponse_flexible_two_way_fields_err: typing.TypeAlias = (
        typing.Union[
            FrameworkError,
            DomainError,
            NonEmptyPayload,
        ]
    )

    @abstractmethod
    def flexible_two_way_fields_err(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_flexible_two_way_fields_err
        ]
        | _MethodResponse_flexible_two_way_fields_err
    ):
        ...

    def strict_event(
        self,
    ) -> None:
        msg = None
        self._send_event(3110049402570307488, "fidl.clientsuite", msg)

    def flexible_event(
        self,
    ) -> None:
        msg = None
        self._send_event(5824395118547404952, "fidl.clientsuite", msg)


class OpenTargetClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "fidl.clientsuite"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def strict_one_way(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            7904024199254697828,
            "fidl.clientsuite",
            msg,
        )

    def flexible_one_way(
        self,
    ) -> None:
        msg = None

        self._send_one_way_fidl_request(
            0,
            1119507890521778684,
            "fidl.clientsuite",
            msg,
        )

    def strict_two_way(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = None
        return self._send_two_way_fidl_request(
            995098632483095874,
            "fidl.clientsuite",
            msg,
            "",
        )

    def strict_two_way_fields(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, NonEmptyPayload]:
        msg = None
        return self._send_two_way_fidl_request(
            8775166568163566307,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/NonEmptyPayload"
            ),
        )

    def strict_two_way_err(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, OpenTargetStrictTwoWayErrResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            6063427118545698440,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/OpenTarget_StrictTwoWayErr_Result"
            ),
        )

    def strict_two_way_fields_err(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, OpenTargetStrictTwoWayFieldsErrResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            9059738677182539537,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/OpenTarget_StrictTwoWayFieldsErr_Result"
            ),
        )

    def flexible_two_way(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, OpenTargetFlexibleTwoWayResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            7373850992214410631,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/OpenTarget_FlexibleTwoWay_Result"
            ),
        )

    def flexible_two_way_fields(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, OpenTargetFlexibleTwoWayFieldsResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            4087393006943873764,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/OpenTarget_FlexibleTwoWayFields_Result"
            ),
        )

    def flexible_two_way_err(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, OpenTargetFlexibleTwoWayErrResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            7932048879253591162,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/OpenTarget_FlexibleTwoWayErr_Result"
            ),
        )

    def flexible_two_way_fields_err(
        self,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, OpenTargetFlexibleTwoWayFieldsErrResult
    ]:
        msg = None
        return self._send_two_way_fidl_request(
            1029425766479692362,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/OpenTarget_FlexibleTwoWayFieldsErr_Result"
            ),
        )


class OpenTargetEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {
        3110049402570307488: MethodInfo(
            name="strict_event",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
        5824395118547404952: MethodInfo(
            name="flexible_event",
            request_ident="",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier=None,
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    @abstractmethod
    def strict_event(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...

    @abstractmethod
    def flexible_event(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None] | None:
        ...


OpenTargetMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) fidl.clientsuite/OpenTarget"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class OpenTargetEventReporterServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {
        8118645339567199818: MethodInfo(
            name="report_event",
            request_ident="fidl.clientsuite/OpenTargetEventReport",
            requires_response=False,
            empty_response=False,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_report_event: typing.TypeAlias = None

    @abstractmethod
    def report_event(
        self,
        request: OpenTargetEventReport,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_report_event]
        | _MethodResponse_report_event
    ):
        ...


class OpenTargetEventReporterClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "fidl.clientsuite"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def report_event(
        self,
        *,
        fidl_error: int | None = None,
        unknown_event: UnknownEvent | None = None,
        strict_event: Empty | None = None,
        flexible_event: Empty | None = None,
    ) -> None:
        msg = OpenTargetEventReport(
            fidl_error,
            unknown_event,
            strict_event,
            flexible_event,
        )

        self._send_one_way_fidl_request(
            0,
            8118645339567199818,
            "fidl.clientsuite",
            msg,
        )


class OpenTargetEventReporterEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


OpenTargetEventReporterMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) fidl.clientsuite/OpenTargetEventReporter"
)


import fidl._construct
from fidl._fidl_common import DomainError, MethodInfo, FrameworkError
from abc import abstractmethod, ABC


class RunnerServer(fidl._server.ServerBase, ABC):
    __fidl_kind__ = "server"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {
        6151094865554034132: MethodInfo(
            name="get_version",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/RunnerGetVersionResponse",
        ),
        8456568861872716880: MethodInfo(
            name="is_test_enabled",
            request_ident="fidl.clientsuite/RunnerIsTestEnabledRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/RunnerIsTestEnabledResponse",
        ),
        6518872820703682864: MethodInfo(
            name="check_alive",
            request_ident="",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        8553849771382515254: MethodInfo(
            name="get_bindings_properties",
            request_ident="",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/BindingsProperties",
        ),
        6029318298044407969: MethodInfo(
            name="call_two_way_no_payload",
            request_ident="fidl.clientsuite/RunnerCallTwoWayNoPayloadRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        2659811426878208326: MethodInfo(
            name="call_two_way_struct_payload",
            request_ident="fidl.clientsuite/RunnerCallTwoWayStructPayloadRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/NonEmptyResultClassification",
        ),
        517424185216448362: MethodInfo(
            name="call_two_way_table_payload",
            request_ident="fidl.clientsuite/RunnerCallTwoWayTablePayloadRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/TableResultClassification",
        ),
        9064011510580525152: MethodInfo(
            name="call_two_way_union_payload",
            request_ident="fidl.clientsuite/RunnerCallTwoWayUnionPayloadRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/UnionResultClassification",
        ),
        3100628808697771749: MethodInfo(
            name="call_two_way_struct_payload_err",
            request_ident="fidl.clientsuite/RunnerCallTwoWayStructPayloadErrRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/NonEmptyResultWithErrorClassification",
        ),
        8935324979276061509: MethodInfo(
            name="call_two_way_struct_request",
            request_ident="fidl.clientsuite/RunnerCallTwoWayStructRequestRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        7212342332333000126: MethodInfo(
            name="call_two_way_table_request",
            request_ident="fidl.clientsuite/RunnerCallTwoWayTableRequestRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        5469041625659498910: MethodInfo(
            name="call_two_way_union_request",
            request_ident="fidl.clientsuite/RunnerCallTwoWayUnionRequestRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        2645564239868906505: MethodInfo(
            name="call_one_way_no_request",
            request_ident="fidl.clientsuite/RunnerCallOneWayNoRequestRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        3830919545774453792: MethodInfo(
            name="call_one_way_struct_request",
            request_ident="fidl.clientsuite/RunnerCallOneWayStructRequestRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        8304956294418347759: MethodInfo(
            name="call_one_way_table_request",
            request_ident="fidl.clientsuite/RunnerCallOneWayTableRequestRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        702155129378639542: MethodInfo(
            name="call_one_way_union_request",
            request_ident="fidl.clientsuite/RunnerCallOneWayUnionRequestRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        5682710877569041515: MethodInfo(
            name="call_strict_one_way",
            request_ident="fidl.clientsuite/RunnerCallStrictOneWayRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        8238193170653898775: MethodInfo(
            name="call_flexible_one_way",
            request_ident="fidl.clientsuite/RunnerCallFlexibleOneWayRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        2281631162221649191: MethodInfo(
            name="call_strict_two_way",
            request_ident="fidl.clientsuite/RunnerCallStrictTwoWayRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        8027963207886237987: MethodInfo(
            name="call_strict_two_way_fields",
            request_ident="fidl.clientsuite/RunnerCallStrictTwoWayFieldsRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/NonEmptyResultClassification",
        ),
        5897108006990753562: MethodInfo(
            name="call_strict_two_way_err",
            request_ident="fidl.clientsuite/RunnerCallStrictTwoWayErrRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultWithErrorClassification",
        ),
        8044305163731028997: MethodInfo(
            name="call_strict_two_way_fields_err",
            request_ident="fidl.clientsuite/RunnerCallStrictTwoWayFieldsErrRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/NonEmptyResultWithErrorClassification",
        ),
        293287060805479753: MethodInfo(
            name="call_flexible_two_way",
            request_ident="fidl.clientsuite/RunnerCallFlexibleTwoWayRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultClassification",
        ),
        3677636279746006765: MethodInfo(
            name="call_flexible_two_way_fields",
            request_ident="fidl.clientsuite/RunnerCallFlexibleTwoWayFieldsRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/NonEmptyResultClassification",
        ),
        6763272537909111383: MethodInfo(
            name="call_flexible_two_way_err",
            request_ident="fidl.clientsuite/RunnerCallFlexibleTwoWayErrRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/EmptyResultWithErrorClassification",
        ),
        8854931429453661326: MethodInfo(
            name="call_flexible_two_way_fields_err",
            request_ident="fidl.clientsuite/RunnerCallFlexibleTwoWayFieldsErrRequest",
            requires_response=True,
            empty_response=False,
            has_result=False,
            response_identifier="fidl.clientsuite/NonEmptyResultWithErrorClassification",
        ),
        5249652665483729643: MethodInfo(
            name="receive_closed_events",
            request_ident="fidl.clientsuite/RunnerReceiveClosedEventsRequest",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        889006526008657827: MethodInfo(
            name="receive_ajar_events",
            request_ident="fidl.clientsuite/RunnerReceiveAjarEventsRequest",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
        8765983170380094431: MethodInfo(
            name="receive_open_events",
            request_ident="fidl.clientsuite/RunnerReceiveOpenEventsRequest",
            requires_response=True,
            empty_response=True,
            has_result=False,
            response_identifier="",
        ),
    }

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    _MethodResponse_get_version: typing.TypeAlias = RunnerGetVersionResponse

    @abstractmethod
    def get_version(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_get_version]
        | _MethodResponse_get_version
    ):
        ...

    _MethodResponse_is_test_enabled: typing.TypeAlias = (
        RunnerIsTestEnabledResponse
    )

    @abstractmethod
    def is_test_enabled(
        self,
        request: RunnerIsTestEnabledRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_is_test_enabled
        ]
        | _MethodResponse_is_test_enabled
    ):
        ...

    _MethodResponse_check_alive: typing.TypeAlias = None

    @abstractmethod
    def check_alive(
        self,
    ) -> (
        typing.Coroutine[typing.Any, typing.Any, _MethodResponse_check_alive]
        | _MethodResponse_check_alive
    ):
        ...

    _MethodResponse_get_bindings_properties: typing.TypeAlias = (
        BindingsProperties
    )

    @abstractmethod
    def get_bindings_properties(
        self,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_get_bindings_properties
        ]
        | _MethodResponse_get_bindings_properties
    ):
        ...

    _MethodResponse_call_two_way_no_payload: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_two_way_no_payload(
        self,
        request: RunnerCallTwoWayNoPayloadRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_two_way_no_payload
        ]
        | _MethodResponse_call_two_way_no_payload
    ):
        ...

    _MethodResponse_call_two_way_struct_payload: typing.TypeAlias = (
        NonEmptyResultClassification
    )

    @abstractmethod
    def call_two_way_struct_payload(
        self,
        request: RunnerCallTwoWayStructPayloadRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_two_way_struct_payload
        ]
        | _MethodResponse_call_two_way_struct_payload
    ):
        ...

    _MethodResponse_call_two_way_table_payload: typing.TypeAlias = (
        TableResultClassification
    )

    @abstractmethod
    def call_two_way_table_payload(
        self,
        request: RunnerCallTwoWayTablePayloadRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_two_way_table_payload
        ]
        | _MethodResponse_call_two_way_table_payload
    ):
        ...

    _MethodResponse_call_two_way_union_payload: typing.TypeAlias = (
        UnionResultClassification
    )

    @abstractmethod
    def call_two_way_union_payload(
        self,
        request: RunnerCallTwoWayUnionPayloadRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_two_way_union_payload
        ]
        | _MethodResponse_call_two_way_union_payload
    ):
        ...

    _MethodResponse_call_two_way_struct_payload_err: typing.TypeAlias = (
        NonEmptyResultWithErrorClassification
    )

    @abstractmethod
    def call_two_way_struct_payload_err(
        self,
        request: RunnerCallTwoWayStructPayloadErrRequest,
    ) -> (
        typing.Coroutine[
            typing.Any,
            typing.Any,
            _MethodResponse_call_two_way_struct_payload_err,
        ]
        | _MethodResponse_call_two_way_struct_payload_err
    ):
        ...

    _MethodResponse_call_two_way_struct_request: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_two_way_struct_request(
        self,
        request: RunnerCallTwoWayStructRequestRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_two_way_struct_request
        ]
        | _MethodResponse_call_two_way_struct_request
    ):
        ...

    _MethodResponse_call_two_way_table_request: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_two_way_table_request(
        self,
        request: RunnerCallTwoWayTableRequestRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_two_way_table_request
        ]
        | _MethodResponse_call_two_way_table_request
    ):
        ...

    _MethodResponse_call_two_way_union_request: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_two_way_union_request(
        self,
        request: RunnerCallTwoWayUnionRequestRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_two_way_union_request
        ]
        | _MethodResponse_call_two_way_union_request
    ):
        ...

    _MethodResponse_call_one_way_no_request: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_one_way_no_request(
        self,
        request: RunnerCallOneWayNoRequestRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_one_way_no_request
        ]
        | _MethodResponse_call_one_way_no_request
    ):
        ...

    _MethodResponse_call_one_way_struct_request: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_one_way_struct_request(
        self,
        request: RunnerCallOneWayStructRequestRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_one_way_struct_request
        ]
        | _MethodResponse_call_one_way_struct_request
    ):
        ...

    _MethodResponse_call_one_way_table_request: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_one_way_table_request(
        self,
        request: RunnerCallOneWayTableRequestRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_one_way_table_request
        ]
        | _MethodResponse_call_one_way_table_request
    ):
        ...

    _MethodResponse_call_one_way_union_request: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_one_way_union_request(
        self,
        request: RunnerCallOneWayUnionRequestRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_one_way_union_request
        ]
        | _MethodResponse_call_one_way_union_request
    ):
        ...

    _MethodResponse_call_strict_one_way: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_strict_one_way(
        self,
        request: RunnerCallStrictOneWayRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_strict_one_way
        ]
        | _MethodResponse_call_strict_one_way
    ):
        ...

    _MethodResponse_call_flexible_one_way: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_flexible_one_way(
        self,
        request: RunnerCallFlexibleOneWayRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_flexible_one_way
        ]
        | _MethodResponse_call_flexible_one_way
    ):
        ...

    _MethodResponse_call_strict_two_way: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_strict_two_way(
        self,
        request: RunnerCallStrictTwoWayRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_strict_two_way
        ]
        | _MethodResponse_call_strict_two_way
    ):
        ...

    _MethodResponse_call_strict_two_way_fields: typing.TypeAlias = (
        NonEmptyResultClassification
    )

    @abstractmethod
    def call_strict_two_way_fields(
        self,
        request: RunnerCallStrictTwoWayFieldsRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_strict_two_way_fields
        ]
        | _MethodResponse_call_strict_two_way_fields
    ):
        ...

    _MethodResponse_call_strict_two_way_err: typing.TypeAlias = (
        EmptyResultWithErrorClassification
    )

    @abstractmethod
    def call_strict_two_way_err(
        self,
        request: RunnerCallStrictTwoWayErrRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_strict_two_way_err
        ]
        | _MethodResponse_call_strict_two_way_err
    ):
        ...

    _MethodResponse_call_strict_two_way_fields_err: typing.TypeAlias = (
        NonEmptyResultWithErrorClassification
    )

    @abstractmethod
    def call_strict_two_way_fields_err(
        self,
        request: RunnerCallStrictTwoWayFieldsErrRequest,
    ) -> (
        typing.Coroutine[
            typing.Any,
            typing.Any,
            _MethodResponse_call_strict_two_way_fields_err,
        ]
        | _MethodResponse_call_strict_two_way_fields_err
    ):
        ...

    _MethodResponse_call_flexible_two_way: typing.TypeAlias = (
        EmptyResultClassification
    )

    @abstractmethod
    def call_flexible_two_way(
        self,
        request: RunnerCallFlexibleTwoWayRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_flexible_two_way
        ]
        | _MethodResponse_call_flexible_two_way
    ):
        ...

    _MethodResponse_call_flexible_two_way_fields: typing.TypeAlias = (
        NonEmptyResultClassification
    )

    @abstractmethod
    def call_flexible_two_way_fields(
        self,
        request: RunnerCallFlexibleTwoWayFieldsRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_flexible_two_way_fields
        ]
        | _MethodResponse_call_flexible_two_way_fields
    ):
        ...

    _MethodResponse_call_flexible_two_way_err: typing.TypeAlias = (
        EmptyResultWithErrorClassification
    )

    @abstractmethod
    def call_flexible_two_way_err(
        self,
        request: RunnerCallFlexibleTwoWayErrRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_call_flexible_two_way_err
        ]
        | _MethodResponse_call_flexible_two_way_err
    ):
        ...

    _MethodResponse_call_flexible_two_way_fields_err: typing.TypeAlias = (
        NonEmptyResultWithErrorClassification
    )

    @abstractmethod
    def call_flexible_two_way_fields_err(
        self,
        request: RunnerCallFlexibleTwoWayFieldsErrRequest,
    ) -> (
        typing.Coroutine[
            typing.Any,
            typing.Any,
            _MethodResponse_call_flexible_two_way_fields_err,
        ]
        | _MethodResponse_call_flexible_two_way_fields_err
    ):
        ...

    _MethodResponse_receive_closed_events: typing.TypeAlias = None

    @abstractmethod
    def receive_closed_events(
        self,
        request: RunnerReceiveClosedEventsRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_receive_closed_events
        ]
        | _MethodResponse_receive_closed_events
    ):
        ...

    _MethodResponse_receive_ajar_events: typing.TypeAlias = None

    @abstractmethod
    def receive_ajar_events(
        self,
        request: RunnerReceiveAjarEventsRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_receive_ajar_events
        ]
        | _MethodResponse_receive_ajar_events
    ):
        ...

    _MethodResponse_receive_open_events: typing.TypeAlias = None

    @abstractmethod
    def receive_open_events(
        self,
        request: RunnerReceiveOpenEventsRequest,
    ) -> (
        typing.Coroutine[
            typing.Any, typing.Any, _MethodResponse_receive_open_events
        ]
        | _MethodResponse_receive_open_events
    ):
        ...


class RunnerClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "fidl.clientsuite"

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )

    def get_version(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, RunnerGetVersionResponse]:
        msg = None
        return self._send_two_way_fidl_request(
            6151094865554034132,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/RunnerGetVersionResponse"
            ),
        )

    def is_test_enabled(
        self,
        *,
        test: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, RunnerIsTestEnabledResponse]:
        msg = RunnerIsTestEnabledRequest(
            test,
        )
        return self._send_two_way_fidl_request(
            8456568861872716880,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/RunnerIsTestEnabledResponse"
            ),
        )

    def check_alive(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = None
        return self._send_two_way_fidl_request(
            6518872820703682864,
            "fidl.clientsuite",
            msg,
            "",
        )

    def get_bindings_properties(
        self,
    ) -> typing.Coroutine[typing.Any, typing.Any, BindingsProperties]:
        msg = None
        return self._send_two_way_fidl_request(
            8553849771382515254,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/BindingsProperties"
            ),
        )

    def call_two_way_no_payload(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallTwoWayNoPayloadRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            6029318298044407969,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_two_way_struct_payload(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, NonEmptyResultClassification]:
        msg = RunnerCallTwoWayStructPayloadRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            2659811426878208326,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/NonEmptyResultClassification"
            ),
        )

    def call_two_way_table_payload(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, TableResultClassification]:
        msg = RunnerCallTwoWayTablePayloadRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            517424185216448362,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/TableResultClassification"
            ),
        )

    def call_two_way_union_payload(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, UnionResultClassification]:
        msg = RunnerCallTwoWayUnionPayloadRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            9064011510580525152,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/UnionResultClassification"
            ),
        )

    def call_two_way_struct_payload_err(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, NonEmptyResultWithErrorClassification
    ]:
        msg = RunnerCallTwoWayStructPayloadErrRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            3100628808697771749,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/NonEmptyResultWithErrorClassification"
            ),
        )

    def call_two_way_struct_request(
        self,
        *,
        target: int,
        request: NonEmptyPayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallTwoWayStructRequestRequest(
            target,
            request,
        )
        return self._send_two_way_fidl_request(
            8935324979276061509,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_two_way_table_request(
        self,
        *,
        target: int,
        request: TablePayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallTwoWayTableRequestRequest(
            target,
            request,
        )
        return self._send_two_way_fidl_request(
            7212342332333000126,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_two_way_union_request(
        self,
        *,
        target: int,
        request: UnionPayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallTwoWayUnionRequestRequest(
            target,
            request,
        )
        return self._send_two_way_fidl_request(
            5469041625659498910,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_one_way_no_request(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallOneWayNoRequestRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            2645564239868906505,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_one_way_struct_request(
        self,
        *,
        target: int,
        request: NonEmptyPayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallOneWayStructRequestRequest(
            target,
            request,
        )
        return self._send_two_way_fidl_request(
            3830919545774453792,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_one_way_table_request(
        self,
        *,
        target: int,
        request: TablePayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallOneWayTableRequestRequest(
            target,
            request,
        )
        return self._send_two_way_fidl_request(
            8304956294418347759,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_one_way_union_request(
        self,
        *,
        target: int,
        request: UnionPayload,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallOneWayUnionRequestRequest(
            target,
            request,
        )
        return self._send_two_way_fidl_request(
            702155129378639542,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_strict_one_way(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallStrictOneWayRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            5682710877569041515,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_flexible_one_way(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallFlexibleOneWayRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            8238193170653898775,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_strict_two_way(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallStrictTwoWayRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            2281631162221649191,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_strict_two_way_fields(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, NonEmptyResultClassification]:
        msg = RunnerCallStrictTwoWayFieldsRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            8027963207886237987,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/NonEmptyResultClassification"
            ),
        )

    def call_strict_two_way_err(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, EmptyResultWithErrorClassification
    ]:
        msg = RunnerCallStrictTwoWayErrRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            5897108006990753562,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultWithErrorClassification"
            ),
        )

    def call_strict_two_way_fields_err(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, NonEmptyResultWithErrorClassification
    ]:
        msg = RunnerCallStrictTwoWayFieldsErrRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            8044305163731028997,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/NonEmptyResultWithErrorClassification"
            ),
        )

    def call_flexible_two_way(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, EmptyResultClassification]:
        msg = RunnerCallFlexibleTwoWayRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            293287060805479753,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultClassification"
            ),
        )

    def call_flexible_two_way_fields(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, NonEmptyResultClassification]:
        msg = RunnerCallFlexibleTwoWayFieldsRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            3677636279746006765,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/NonEmptyResultClassification"
            ),
        )

    def call_flexible_two_way_err(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, EmptyResultWithErrorClassification
    ]:
        msg = RunnerCallFlexibleTwoWayErrRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            6763272537909111383,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/EmptyResultWithErrorClassification"
            ),
        )

    def call_flexible_two_way_fields_err(
        self,
        *,
        target: int,
    ) -> typing.Coroutine[
        typing.Any, typing.Any, NonEmptyResultWithErrorClassification
    ]:
        msg = RunnerCallFlexibleTwoWayFieldsErrRequest(
            target,
        )
        return self._send_two_way_fidl_request(
            8854931429453661326,
            "fidl.clientsuite",
            msg,
            fidl._fidl_common.normalize_identifier(
                "fidl.clientsuite/NonEmptyResultWithErrorClassification"
            ),
        )

    def receive_closed_events(
        self,
        *,
        target: int,
        reporter: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = RunnerReceiveClosedEventsRequest(
            target,
            reporter,
        )
        return self._send_two_way_fidl_request(
            5249652665483729643,
            "fidl.clientsuite",
            msg,
            "",
        )

    def receive_ajar_events(
        self,
        *,
        target: int,
        reporter: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = RunnerReceiveAjarEventsRequest(
            target,
            reporter,
        )
        return self._send_two_way_fidl_request(
            889006526008657827,
            "fidl.clientsuite",
            msg,
            "",
        )

    def receive_open_events(
        self,
        *,
        target: int,
        reporter: int,
    ) -> typing.Coroutine[typing.Any, typing.Any, None]:
        msg = RunnerReceiveOpenEventsRequest(
            target,
            reporter,
        )
        return self._send_two_way_fidl_request(
            8765983170380094431,
            "fidl.clientsuite",
            msg,
            "",
        )


class RunnerEventHandler(fidl._client.EventHandlerBase, ABC):
    __fidl_kind__ = "event_handler"
    library = "fidl.clientsuite"
    method_map: typing.Dict[int, MethodInfo] = {}

    @staticmethod
    def construct_response_object(
        response_ident: str, response_obj: typing.Any
    ) -> typing.Any:
        return fidl._construct.construct_response_object(
            response_ident, response_obj
        )


RunnerMarker = fidl._library.ProtocolMarker("fidl.clientsuite.Runner")
