// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct AllInstants {
    pub monotonic: i64,

    pub boot: i64,

    pub monotonic_ticks: i64,

    pub boot_ticks: i64,
}

impl ::fidl_next::Encodable for AllInstants {
    type Encoded = WireAllInstants;
}

impl<___E> ::fidl_next::Encode<___E> for AllInstants
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                monotonic,
                boot,
                monotonic_ticks,
                boot_ticks,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.monotonic, encoder, monotonic)?;

        ::fidl_next::Encode::encode(&mut self.boot, encoder, boot)?;

        ::fidl_next::Encode::encode(&mut self.monotonic_ticks, encoder, monotonic_ticks)?;

        ::fidl_next::Encode::encode(&mut self.boot_ticks, encoder, boot_ticks)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<AllInstants> {
    type EncodedOption = ::fidl_next::WireBox<WireAllInstants>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<AllInstants>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    AllInstants: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireAllInstants> for AllInstants {
    fn take_from(from: &WireAllInstants) -> Self {
        Self {
            monotonic: ::fidl_next::TakeFrom::take_from(&from.monotonic),

            boot: ::fidl_next::TakeFrom::take_from(&from.boot),

            monotonic_ticks: ::fidl_next::TakeFrom::take_from(&from.monotonic_ticks),

            boot_ticks: ::fidl_next::TakeFrom::take_from(&from.boot_ticks),
        }
    }
}

/// The wire type corersponding to [`AllInstants`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireAllInstants {
    pub monotonic: ::fidl_next::i64_le,

    pub boot: ::fidl_next::i64_le,

    pub monotonic_ticks: ::fidl_next::i64_le,

    pub boot_ticks: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireAllInstants
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut monotonic,
                mut boot,
                mut monotonic_ticks,
                mut boot_ticks,

            } = slot;
        }

        ::fidl_next::Decode::decode(monotonic.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(boot.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(monotonic_ticks.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(boot_ticks.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ComplexInstants {
    pub monotonic: Option<[i64; 10]>,

    pub boot: Option<Vec<i64>>,

    pub monotonic_ticks: Option<[i64; 10]>,

    pub boot_ticks: Option<[i64; 10]>,
}

impl ComplexInstants {
    fn __max_ordinal(&self) -> usize {
        if self.monotonic.is_some() {
            return 1;
        }

        if self.boot.is_some() {
            return 2;
        }

        if self.monotonic_ticks.is_some() {
            return 3;
        }

        if self.boot_ticks.is_some() {
            return 4;
        }

        0
    }
}

impl ::fidl_next::Encodable for ComplexInstants {
    type Encoded = WireComplexInstants;
}

impl<___E> ::fidl_next::Encode<___E> for ComplexInstants
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireComplexInstants { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                4 => {
                    if let Some(boot_ticks) = &mut self.boot_ticks {
                        ::fidl_next::WireEnvelope::encode_value(
                            boot_ticks,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                3 => {
                    if let Some(monotonic_ticks) = &mut self.monotonic_ticks {
                        ::fidl_next::WireEnvelope::encode_value(
                            monotonic_ticks,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                2 => {
                    if let Some(boot) = &mut self.boot {
                        ::fidl_next::WireEnvelope::encode_value(
                            boot,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                1 => {
                    if let Some(monotonic) = &mut self.monotonic {
                        ::fidl_next::WireEnvelope::encode_value(
                            monotonic,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireComplexInstants> for ComplexInstants {
    fn take_from(from: &WireComplexInstants) -> Self {
        Self {
            monotonic: from.monotonic().map(::fidl_next::TakeFrom::take_from),

            boot: from.boot().map(::fidl_next::TakeFrom::take_from),

            monotonic_ticks: from.monotonic_ticks().map(::fidl_next::TakeFrom::take_from),

            boot_ticks: from.boot_ticks().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`ComplexInstants`].
#[repr(C)]
pub struct WireComplexInstants {
    table: ::fidl_next::WireTable,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireComplexInstants
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::i64_le; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<::fidl_next::i64_le>,
                    >(slot.as_mut(), decoder)?;

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::i64_le; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::i64_le; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireComplexInstants {
    pub fn monotonic(&self) -> Option<&[::fidl_next::i64_le; 10]> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn boot(&self) -> Option<&::fidl_next::WireVector<::fidl_next::i64_le>> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }

    pub fn monotonic_ticks(&self) -> Option<&[::fidl_next::i64_le; 10]> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn boot_ticks(&self) -> Option<&[::fidl_next::i64_le; 10]> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireComplexInstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ComplexInstants")
            .field("monotonic", &self.monotonic())
            .field("boot", &self.boot())
            .field("monotonic_ticks", &self.monotonic_ticks())
            .field("boot_ticks", &self.boot_ticks())
            .finish()
    }
}
