// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
#[repr(C)]
pub struct AllInstants {
    pub monotonic: i64,

    pub boot: i64,

    pub monotonic_ticks: i64,

    pub boot_ticks: i64,
}

impl ::fidl_next::Encodable for AllInstants {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireAllInstants> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled()
                && <i64 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireAllInstants;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for AllInstants
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                monotonic,
                boot,
                monotonic_ticks,
                boot_ticks,

            } = out;
        }

        ::fidl_next::Encode::encode(self.monotonic, encoder, monotonic)?;

        ::fidl_next::Encode::encode(self.boot, encoder, boot)?;

        ::fidl_next::Encode::encode(self.monotonic_ticks, encoder, monotonic_ticks)?;

        ::fidl_next::Encode::encode(self.boot_ticks, encoder, boot_ticks)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for AllInstants
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                monotonic,
                boot,
                monotonic_ticks,
                boot_ticks,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.monotonic, encoder, monotonic)?;

        ::fidl_next::EncodeRef::encode_ref(&self.boot, encoder, boot)?;

        ::fidl_next::EncodeRef::encode_ref(&self.monotonic_ticks, encoder, monotonic_ticks)?;

        ::fidl_next::EncodeRef::encode_ref(&self.boot_ticks, encoder, boot_ticks)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for AllInstants {
    type EncodedOption = ::fidl_next::WireBox<'static, WireAllInstants>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for AllInstants
where
    ___E: ::fidl_next::Encoder + ?Sized,
    AllInstants: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for AllInstants
where
    ___E: ::fidl_next::Encoder + ?Sized,
    AllInstants: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireAllInstants> for AllInstants {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireAllInstants, Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled()
                && <i64 as ::fidl_next::FromWire<::fidl_next::WireI64>>::COPY_OPTIMIZATION
                    .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireAllInstants) -> Self {
        Self {
            monotonic: ::fidl_next::FromWire::from_wire(wire.monotonic),

            boot: ::fidl_next::FromWire::from_wire(wire.boot),

            monotonic_ticks: ::fidl_next::FromWire::from_wire(wire.monotonic_ticks),

            boot_ticks: ::fidl_next::FromWire::from_wire(wire.boot_ticks),
        }
    }
}

impl ::fidl_next::FromWireRef<WireAllInstants> for AllInstants {
    #[inline]
    fn from_wire_ref(wire: &WireAllInstants) -> Self {
        Self {
            monotonic: ::fidl_next::FromWireRef::from_wire_ref(&wire.monotonic),

            boot: ::fidl_next::FromWireRef::from_wire_ref(&wire.boot),

            monotonic_ticks: ::fidl_next::FromWireRef::from_wire_ref(&wire.monotonic_ticks),

            boot_ticks: ::fidl_next::FromWireRef::from_wire_ref(&wire.boot_ticks),
        }
    }
}

/// The wire type corresponding to [`AllInstants`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireAllInstants {
    pub monotonic: ::fidl_next::WireI64,

    pub boot: ::fidl_next::WireI64,

    pub monotonic_ticks: ::fidl_next::WireI64,

    pub boot_ticks: ::fidl_next::WireI64,
}

unsafe impl ::fidl_next::Wire for WireAllInstants {
    type Decoded<'de> = WireAllInstants;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireAllInstants
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut monotonic,
                mut boot,
                mut monotonic_ticks,
                mut boot_ticks,

            } = slot;
        }

        ::fidl_next::Decode::decode(monotonic.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(boot.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(monotonic_ticks.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(boot_ticks.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct ComplexInstants {
    pub monotonic: Option<[i64; 10]>,

    pub boot: Option<Vec<i64>>,

    pub monotonic_ticks: Option<[i64; 10]>,

    pub boot_ticks: Option<[i64; 10]>,
}

impl ComplexInstants {
    fn __max_ordinal(&self) -> usize {
        if self.boot_ticks.is_some() {
            return 4;
        }

        if self.monotonic_ticks.is_some() {
            return 3;
        }

        if self.boot.is_some() {
            return 2;
        }

        if self.monotonic.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ComplexInstants {
    type Encoded = WireComplexInstants<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ComplexInstants
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireComplexInstants { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                4 => {
                    if let Some(boot_ticks) = self.boot_ticks.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            boot_ticks,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                3 => {
                    if let Some(monotonic_ticks) = self.monotonic_ticks.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            monotonic_ticks,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                2 => {
                    if let Some(boot) = self.boot.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            boot,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(monotonic) = self.monotonic.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            monotonic,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ComplexInstants
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireComplexInstants { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                4 => {
                    if let Some(boot_ticks) = &self.boot_ticks {
                        ::fidl_next::WireEnvelope::encode_value(
                            boot_ticks,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                3 => {
                    if let Some(monotonic_ticks) = &self.monotonic_ticks {
                        ::fidl_next::WireEnvelope::encode_value(
                            monotonic_ticks,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                2 => {
                    if let Some(boot) = &self.boot {
                        ::fidl_next::WireEnvelope::encode_value(
                            boot,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(monotonic) = &self.monotonic {
                        ::fidl_next::WireEnvelope::encode_value(
                            monotonic,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireComplexInstants<'de>> for ComplexInstants {
    #[inline]
    fn from_wire(wire: WireComplexInstants<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let monotonic = wire.table.get(1);

        let boot = wire.table.get(2);

        let monotonic_ticks = wire.table.get(3);

        let boot_ticks = wire.table.get(4);

        Self {
            monotonic: monotonic.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<[::fidl_next::WireI64; 10]>()
                })
            }),

            boot: boot.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireI64>>()
                })
            }),

            monotonic_ticks: monotonic_ticks.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<[::fidl_next::WireI64; 10]>()
                })
            }),

            boot_ticks: boot_ticks.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<[::fidl_next::WireI64; 10]>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireComplexInstants<'de>> for ComplexInstants {
    #[inline]
    fn from_wire_ref(wire: &WireComplexInstants<'de>) -> Self {
        Self {
            monotonic: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<[::fidl_next::WireI64; 10]>()
                })
            }),

            boot: wire.table.get(2).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireI64>>()
                })
            }),

            monotonic_ticks: wire.table.get(3).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<[::fidl_next::WireI64; 10]>()
                })
            }),

            boot_ticks: wire.table.get(4).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<[::fidl_next::WireI64; 10]>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`ComplexInstants`].
#[repr(C)]
pub struct WireComplexInstants<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireComplexInstants<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<[::fidl_next::WireI64; 10]>() });

        let _ = self.table.get(2).map(|envelope| unsafe {
            envelope.read_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireI64>>()
        });

        let _ = self
            .table
            .get(3)
            .map(|envelope| unsafe { envelope.read_unchecked::<[::fidl_next::WireI64; 10]>() });

        let _ = self
            .table
            .get(4)
            .map(|envelope| unsafe { envelope.read_unchecked::<[::fidl_next::WireI64; 10]>() });
    }
}

unsafe impl ::fidl_next::Wire for WireComplexInstants<'static> {
    type Decoded<'de> = WireComplexInstants<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireComplexInstants<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::WireI64; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
                    >(slot.as_mut(), decoder)?;

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::WireI64; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, [::fidl_next::WireI64; 10]>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireComplexInstants<'de> {
    pub fn monotonic(&self) -> Option<&[::fidl_next::WireI64; 10]> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn boot(&self) -> Option<&::fidl_next::WireVector<'de, ::fidl_next::WireI64>> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }

    pub fn monotonic_ticks(&self) -> Option<&[::fidl_next::WireI64; 10]> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn boot_ticks(&self) -> Option<&[::fidl_next::WireI64; 10]> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireComplexInstants<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ComplexInstants")
            .field("monotonic", &self.monotonic())
            .field("boot", &self.boot())
            .field("monotonic_ticks", &self.monotonic_ticks())
            .field("boot_ticks", &self.boot_ticks())
            .finish()
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::fidl_next::CompatFrom<crate::AllInstants> for ::fidl_test_time::AllInstants {
        #[inline]
        fn compat_from(value: crate::AllInstants) -> Self {
            Self {
                monotonic: ::fidl_next::CompatFrom::compat_from(value.monotonic),

                boot: ::fidl_next::CompatFrom::compat_from(value.boot),

                monotonic_ticks: ::fidl_next::CompatFrom::compat_from(value.monotonic_ticks),

                boot_ticks: ::fidl_next::CompatFrom::compat_from(value.boot_ticks),
            }
        }
    }

    impl ::fidl_next::CompatFrom<::fidl_test_time::AllInstants> for crate::AllInstants {
        #[inline]
        fn compat_from(value: ::fidl_test_time::AllInstants) -> Self {
            Self {
                monotonic: ::fidl_next::CompatFrom::compat_from(value.monotonic),

                boot: ::fidl_next::CompatFrom::compat_from(value.boot),

                monotonic_ticks: ::fidl_next::CompatFrom::compat_from(value.monotonic_ticks),

                boot_ticks: ::fidl_next::CompatFrom::compat_from(value.boot_ticks),
            }
        }
    }

    impl ::fidl_next::CompatFrom<crate::ComplexInstants> for ::fidl_test_time::ComplexInstants {
        fn compat_from(value: crate::ComplexInstants) -> Self {
            Self {
                monotonic: ::fidl_next::CompatFrom::compat_from(value.monotonic),

                boot: ::fidl_next::CompatFrom::compat_from(value.boot),

                monotonic_ticks: ::fidl_next::CompatFrom::compat_from(value.monotonic_ticks),

                boot_ticks: ::fidl_next::CompatFrom::compat_from(value.boot_ticks),

                __source_breaking: ::fidl::marker::SourceBreaking,
            }
        }
    }

    impl ::fidl_next::CompatFrom<::fidl_test_time::ComplexInstants> for crate::ComplexInstants {
        fn compat_from(value: ::fidl_test_time::ComplexInstants) -> Self {
            Self {
                monotonic: ::fidl_next::CompatFrom::compat_from(value.monotonic),

                boot: ::fidl_next::CompatFrom::compat_from(value.boot),

                monotonic_ticks: ::fidl_next::CompatFrom::compat_from(value.monotonic_ticks),

                boot_ticks: ::fidl_next::CompatFrom::compat_from(value.boot_ticks),
            }
        }
    }
}
