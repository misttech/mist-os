// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub const ANSWER: u16 = 42;

pub const ANSWER_IN_BINARY: u16 = 42;

pub const ANSWER_NARROWED: u8 = 42;

::fidl_next::bitflags! {

    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsType: u32 {
        const VALUE = 1;
        const TRUE = 2;

    }
}

impl ::fidl_next::Encodable for BitsType {
    type Encoded<'buf> = WireBitsType;
}

impl<___E> ::fidl_next::Encode<___E> for BitsType
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsType { mut value } = slot);
        *value = ::fidl_next::u32_le::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireBitsType> for BitsType {
    fn from(wire: WireBitsType) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBitsType> for BitsType {
    fn take_from(from: &mut WireBitsType) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`BitsType`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsType {
    value: ::fidl_next::u32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !BitsType::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: BitsType::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<BitsType> for WireBitsType {
    fn from(natural: BitsType) -> Self {
        Self { value: ::fidl_next::u32_le::from(natural.bits()) }
    }
}

pub const CONVERSION_FACTOR: f64 = 1.41421;

pub const DIAMOND: u64 = 1746410393481133080;

pub const ENABLED_FLAG: bool = true;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(i32)]
pub enum EnumType {
    Value = 1,
    True = 2,
}

impl ::fidl_next::Encodable for EnumType {
    type Encoded<'buf> = WireEnumType;
}

impl<___E> ::fidl_next::Encode<___E> for EnumType
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnumType { mut value } = slot);
        *value = ::fidl_next::i32_le::from(match *self {
            Self::Value => 1,

            Self::True => 2,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireEnumType> for EnumType {
    fn from(wire: WireEnumType) -> Self {
        match i32::from(wire.value) {
            1 => Self::Value,

            2 => Self::True,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireEnumType> for EnumType {
    fn take_from(from: &mut WireEnumType) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`EnumType`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnumType {
    value: ::fidl_next::i32_le,
}

impl WireEnumType {
    pub const VALUE: WireEnumType = WireEnumType { value: ::fidl_next::i32_le::from_native(1) };

    pub const TRUE: WireEnumType = WireEnumType { value: ::fidl_next::i32_le::from_native(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnumType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match i32::from(*value) {
            1 | 2 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<EnumType> for WireEnumType {
    fn from(natural: EnumType) -> Self {
        match natural {
            EnumType::Value => WireEnumType::VALUE,

            EnumType::True => WireEnumType::TRUE,
        }
    }
}

pub const FUCHSIA: u64 = 4054509061583223046;

pub const MIN_TEMP: f32 = -273.15;

pub const OFFSET: i8 = -33;

pub const POPULATION_USA_2018: u32 = 330000000;

pub const USERNAME: &str = "\"squeenze\"";

pub const ZX_CONST: u64 = 65536;

pub const ZX_OBJ_VAL: fidl_next::zx::ObjectType = fidl_next::zx::ObjectType::CHANNEL;

pub const ZX_RIGHTS_VAL: fidl_next::zx::Rights = fidl_next::zx::Rights::READ;

pub const BITS_PRIMITIVE_TRUE: u32 = 2;

pub const BITS_PRIMITIVE_VAL: u32 = 1;

pub const BITS_PRIMITIVE_VAL_NARROWED: u8 = 1;

pub const BITS_TRUE: crate::BitsType = crate::BitsType::TRUE;

pub const BITS_VAL: crate::BitsType = crate::BitsType::VALUE;

pub const ENUM_PRIMITIVE_TRUE: i32 = 2;

pub const ENUM_PRIMITIVE_VAL: i32 = 1;

pub const ENUM_PRIMITIVE_VAL_NARROWED: i8 = 1;

pub const ENUM_TRUE: crate::EnumType = crate::EnumType::True;

pub const ENUM_VAL: crate::EnumType = crate::EnumType::Value;
