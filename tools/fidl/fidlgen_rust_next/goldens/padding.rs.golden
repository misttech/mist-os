// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct Padding1ByteEnd {
    pub a: u16,

    pub b: u8,
}

impl ::fidl_next::Encodable for Padding1ByteEnd {
    type Encoded = WirePadding1ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding1ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding1ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding1ByteEnd> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding1ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding1ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding1ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding1ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding1ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding1ByteEnd> for Padding1ByteEnd {
    #[inline]
    fn take_from(from: &WirePadding1ByteEnd) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding1ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding1ByteEnd {
    pub a: ::fidl_next::WireU16,

    pub b: u8,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding1ByteEnd {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(3).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding1ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding1ByteMiddle {
    pub a: u8,

    pub b: u16,
}

impl ::fidl_next::Encodable for Padding1ByteMiddle {
    type Encoded = WirePadding1ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding1ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding1ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding1ByteMiddle> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding1ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding1ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding1ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding1ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding1ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding1ByteMiddle> for Padding1ByteMiddle {
    #[inline]
    fn take_from(from: &WirePadding1ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding1ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding1ByteMiddle {
    pub a: u8,

    pub b: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding1ByteMiddle {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding1ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding2ByteAlignmentLength6 {
    pub a: u8,

    pub b: u16,

    pub c: u8,
}

impl ::fidl_next::Encodable for Padding2ByteAlignmentLength6 {
    type Encoded = WirePadding2ByteAlignmentLength6;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding2ByteAlignmentLength6
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding2ByteAlignmentLength6
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding2ByteAlignmentLength6> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding2ByteAlignmentLength6>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding2ByteAlignmentLength6>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteAlignmentLength6: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding2ByteAlignmentLength6>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteAlignmentLength6: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding2ByteAlignmentLength6> for Padding2ByteAlignmentLength6 {
    #[inline]
    fn take_from(from: &WirePadding2ByteAlignmentLength6) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),

            c: ::fidl_next::TakeFrom::take_from(&from.c),
        }
    }
}

/// The wire type corresponding to [`Padding2ByteAlignmentLength6`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding2ByteAlignmentLength6 {
    pub a: u8,

    pub b: ::fidl_next::WireU16,

    pub c: u8,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding2ByteAlignmentLength6 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 1);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding2ByteAlignmentLength6
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding2ByteEnd {
    pub a: u32,

    pub b: u16,
}

impl ::fidl_next::Encodable for Padding2ByteEnd {
    type Encoded = WirePadding2ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding2ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding2ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding2ByteEnd> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding2ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding2ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding2ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding2ByteEnd> for Padding2ByteEnd {
    #[inline]
    fn take_from(from: &WirePadding2ByteEnd) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding2ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding2ByteEnd {
    pub a: ::fidl_next::WireU32,

    pub b: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding2ByteEnd {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(6).write_bytes(0, 2);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding2ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding2ByteMiddle {
    pub a: u16,

    pub b: u32,
}

impl ::fidl_next::Encodable for Padding2ByteMiddle {
    type Encoded = WirePadding2ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding2ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding2ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding2ByteMiddle> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding2ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding2ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding2ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding2ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding2ByteMiddle> for Padding2ByteMiddle {
    #[inline]
    fn take_from(from: &WirePadding2ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding2ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding2ByteMiddle {
    pub a: ::fidl_next::WireU16,

    pub b: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding2ByteMiddle {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(2).write_bytes(0, 2);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding2ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding3ByteEnd {
    pub a: u32,

    pub b: u8,
}

impl ::fidl_next::Encodable for Padding3ByteEnd {
    type Encoded = WirePadding3ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding3ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding3ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding3ByteEnd> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding3ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding3ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding3ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding3ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding3ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding3ByteEnd> for Padding3ByteEnd {
    #[inline]
    fn take_from(from: &WirePadding3ByteEnd) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding3ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding3ByteEnd {
    pub a: ::fidl_next::WireU32,

    pub b: u8,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding3ByteEnd {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding3ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding3ByteMiddle {
    pub a: u8,

    pub b: u32,
}

impl ::fidl_next::Encodable for Padding3ByteMiddle {
    type Encoded = WirePadding3ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding3ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding3ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding3ByteMiddle> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding3ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding3ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding3ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding3ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding3ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding3ByteMiddle> for Padding3ByteMiddle {
    #[inline]
    fn take_from(from: &WirePadding3ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding3ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding3ByteMiddle {
    pub a: u8,

    pub b: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding3ByteMiddle {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding3ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding4ByteAlignmentLength12 {
    pub a: u32,

    pub b: u8,

    pub c: u16,

    pub d: u16,
}

impl ::fidl_next::Encodable for Padding4ByteAlignmentLength12 {
    type Encoded = WirePadding4ByteAlignmentLength12;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding4ByteAlignmentLength12
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,
                d,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        ::fidl_next::Encode::encode(self.d, encoder, d)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding4ByteAlignmentLength12
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,
                d,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        ::fidl_next::EncodeRef::encode_ref(&self.d, encoder, d)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding4ByteAlignmentLength12> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding4ByteAlignmentLength12>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding4ByteAlignmentLength12>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteAlignmentLength12: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding4ByteAlignmentLength12>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteAlignmentLength12: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding4ByteAlignmentLength12> for Padding4ByteAlignmentLength12 {
    #[inline]
    fn take_from(from: &WirePadding4ByteAlignmentLength12) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),

            c: ::fidl_next::TakeFrom::take_from(&from.c),

            d: ::fidl_next::TakeFrom::take_from(&from.d),
        }
    }
}

/// The wire type corresponding to [`Padding4ByteAlignmentLength12`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding4ByteAlignmentLength12 {
    pub a: ::fidl_next::WireU32,

    pub b: u8,

    pub c: ::fidl_next::WireU16,

    pub d: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding4ByteAlignmentLength12 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(10).write_bytes(0, 2);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding4ByteAlignmentLength12
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,
                mut d,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(d.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding4ByteEnd {
    pub a: u64,

    pub b: u32,
}

impl ::fidl_next::Encodable for Padding4ByteEnd {
    type Encoded = WirePadding4ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding4ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding4ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding4ByteEnd> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding4ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding4ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding4ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding4ByteEnd> for Padding4ByteEnd {
    #[inline]
    fn take_from(from: &WirePadding4ByteEnd) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding4ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding4ByteEnd {
    pub a: ::fidl_next::WireU64,

    pub b: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding4ByteEnd {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(12).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding4ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding4ByteMiddle {
    pub a: u32,

    pub b: u64,
}

impl ::fidl_next::Encodable for Padding4ByteMiddle {
    type Encoded = WirePadding4ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding4ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding4ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding4ByteMiddle> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding4ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding4ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding4ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding4ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding4ByteMiddle> for Padding4ByteMiddle {
    #[inline]
    fn take_from(from: &WirePadding4ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding4ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding4ByteMiddle {
    pub a: ::fidl_next::WireU32,

    pub b: ::fidl_next::WireU64,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding4ByteMiddle {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(4).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding4ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding5ByteEnd {
    pub a: u64,

    pub b: u16,

    pub c: u8,
}

impl ::fidl_next::Encodable for Padding5ByteEnd {
    type Encoded = WirePadding5ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding5ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding5ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding5ByteEnd> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding5ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding5ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding5ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding5ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding5ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding5ByteEnd> for Padding5ByteEnd {
    #[inline]
    fn take_from(from: &WirePadding5ByteEnd) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),

            c: ::fidl_next::TakeFrom::take_from(&from.c),
        }
    }
}

/// The wire type corresponding to [`Padding5ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding5ByteEnd {
    pub a: ::fidl_next::WireU64,

    pub b: ::fidl_next::WireU16,

    pub c: u8,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding5ByteEnd {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(11).write_bytes(0, 5);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding5ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding5ByteMiddle {
    pub a: u16,

    pub b: u8,

    pub c: u64,
}

impl ::fidl_next::Encodable for Padding5ByteMiddle {
    type Encoded = WirePadding5ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding5ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        ::fidl_next::Encode::encode(self.c, encoder, c)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding5ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        ::fidl_next::EncodeRef::encode_ref(&self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding5ByteMiddle> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding5ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding5ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding5ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding5ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding5ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding5ByteMiddle> for Padding5ByteMiddle {
    #[inline]
    fn take_from(from: &WirePadding5ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),

            c: ::fidl_next::TakeFrom::take_from(&from.c),
        }
    }
}

/// The wire type corresponding to [`Padding5ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding5ByteMiddle {
    pub a: ::fidl_next::WireU16,

    pub b: u8,

    pub c: ::fidl_next::WireU64,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding5ByteMiddle {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(3).write_bytes(0, 5);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding5ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding6ByteEnd {
    pub a: u64,

    pub b: u16,
}

impl ::fidl_next::Encodable for Padding6ByteEnd {
    type Encoded = WirePadding6ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding6ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding6ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding6ByteEnd> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding6ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding6ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding6ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding6ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding6ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding6ByteEnd> for Padding6ByteEnd {
    #[inline]
    fn take_from(from: &WirePadding6ByteEnd) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding6ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding6ByteEnd {
    pub a: ::fidl_next::WireU64,

    pub b: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding6ByteEnd {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(10).write_bytes(0, 6);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding6ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding6ByteMiddle {
    pub a: u16,

    pub b: u64,
}

impl ::fidl_next::Encodable for Padding6ByteMiddle {
    type Encoded = WirePadding6ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding6ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding6ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding6ByteMiddle> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding6ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding6ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding6ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding6ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding6ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding6ByteMiddle> for Padding6ByteMiddle {
    #[inline]
    fn take_from(from: &WirePadding6ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding6ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding6ByteMiddle {
    pub a: ::fidl_next::WireU16,

    pub b: ::fidl_next::WireU64,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding6ByteMiddle {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(2).write_bytes(0, 6);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding6ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding7ByteEnd {
    pub a: u64,

    pub b: u8,
}

impl ::fidl_next::Encodable for Padding7ByteEnd {
    type Encoded = WirePadding7ByteEnd;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding7ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding7ByteEnd
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding7ByteEnd> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding7ByteEnd>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding7ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding7ByteEnd: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding7ByteEnd>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding7ByteEnd: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding7ByteEnd> for Padding7ByteEnd {
    #[inline]
    fn take_from(from: &WirePadding7ByteEnd) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding7ByteEnd`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding7ByteEnd {
    pub a: ::fidl_next::WireU64,

    pub b: u8,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding7ByteEnd {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(9).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding7ByteEnd
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Padding7ByteMiddle {
    pub a: u8,

    pub b: u64,
}

impl ::fidl_next::Encodable for Padding7ByteMiddle {
    type Encoded = WirePadding7ByteMiddle;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Padding7ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Padding7ByteMiddle
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Padding7ByteMiddle> {
    type EncodedOption = ::fidl_next::WireBox<WirePadding7ByteMiddle>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Padding7ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding7ByteMiddle: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, *inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Box<Padding7ByteMiddle>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Padding7ByteMiddle: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WirePadding7ByteMiddle> for Padding7ByteMiddle {
    #[inline]
    fn take_from(from: &WirePadding7ByteMiddle) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corresponding to [`Padding7ByteMiddle`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WirePadding7ByteMiddle {
    pub a: u8,

    pub b: ::fidl_next::WireU64,
}

unsafe impl ::fidl_next::ZeroPadding for WirePadding7ByteMiddle {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePadding7ByteMiddle
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::fidl_next::TakeFrom<crate::WirePadding1ByteEnd> for ::fidl_test_padding::Padding1ByteEnd {
        #[inline]
        fn take_from(from: &crate::WirePadding1ByteEnd) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding1ByteMiddle>
        for ::fidl_test_padding::Padding1ByteMiddle
    {
        #[inline]
        fn take_from(from: &crate::WirePadding1ByteMiddle) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding2ByteAlignmentLength6>
        for ::fidl_test_padding::Padding2ByteAlignmentLength6
    {
        #[inline]
        fn take_from(from: &crate::WirePadding2ByteAlignmentLength6) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),

                c: ::fidl_next::TakeFrom::take_from(&from.c),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding2ByteEnd> for ::fidl_test_padding::Padding2ByteEnd {
        #[inline]
        fn take_from(from: &crate::WirePadding2ByteEnd) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding2ByteMiddle>
        for ::fidl_test_padding::Padding2ByteMiddle
    {
        #[inline]
        fn take_from(from: &crate::WirePadding2ByteMiddle) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding3ByteEnd> for ::fidl_test_padding::Padding3ByteEnd {
        #[inline]
        fn take_from(from: &crate::WirePadding3ByteEnd) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding3ByteMiddle>
        for ::fidl_test_padding::Padding3ByteMiddle
    {
        #[inline]
        fn take_from(from: &crate::WirePadding3ByteMiddle) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding4ByteAlignmentLength12>
        for ::fidl_test_padding::Padding4ByteAlignmentLength12
    {
        #[inline]
        fn take_from(from: &crate::WirePadding4ByteAlignmentLength12) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),

                c: ::fidl_next::TakeFrom::take_from(&from.c),

                d: ::fidl_next::TakeFrom::take_from(&from.d),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding4ByteEnd> for ::fidl_test_padding::Padding4ByteEnd {
        #[inline]
        fn take_from(from: &crate::WirePadding4ByteEnd) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding4ByteMiddle>
        for ::fidl_test_padding::Padding4ByteMiddle
    {
        #[inline]
        fn take_from(from: &crate::WirePadding4ByteMiddle) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding5ByteEnd> for ::fidl_test_padding::Padding5ByteEnd {
        #[inline]
        fn take_from(from: &crate::WirePadding5ByteEnd) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),

                c: ::fidl_next::TakeFrom::take_from(&from.c),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding5ByteMiddle>
        for ::fidl_test_padding::Padding5ByteMiddle
    {
        #[inline]
        fn take_from(from: &crate::WirePadding5ByteMiddle) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),

                c: ::fidl_next::TakeFrom::take_from(&from.c),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding6ByteEnd> for ::fidl_test_padding::Padding6ByteEnd {
        #[inline]
        fn take_from(from: &crate::WirePadding6ByteEnd) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding6ByteMiddle>
        for ::fidl_test_padding::Padding6ByteMiddle
    {
        #[inline]
        fn take_from(from: &crate::WirePadding6ByteMiddle) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding7ByteEnd> for ::fidl_test_padding::Padding7ByteEnd {
        #[inline]
        fn take_from(from: &crate::WirePadding7ByteEnd) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WirePadding7ByteMiddle>
        for ::fidl_test_padding::Padding7ByteMiddle
    {
        #[inline]
        fn take_from(from: &crate::WirePadding7ByteMiddle) -> Self {
            Self {
                a: ::fidl_next::TakeFrom::take_from(&from.a),

                b: ::fidl_next::TakeFrom::take_from(&from.b),
            }
        }
    }
}
