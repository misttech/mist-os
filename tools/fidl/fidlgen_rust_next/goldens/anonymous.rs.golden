// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsMember: u32 {
        const BIT_ONE = 1;
        const BIT_TWO = 2;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for BitsMember {
    type Encoded = WireBitsMember;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for BitsMember
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for BitsMember
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsMember { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBitsMember> for BitsMember {
    fn from(wire: WireBitsMember) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::FromWire<WireBitsMember> for BitsMember {
    #[inline]
    fn from_wire(wire: WireBitsMember) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireBitsMember> for BitsMember {
    #[inline]
    fn from_wire_ref(wire: &WireBitsMember) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`BitsMember`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsMember {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireBitsMember {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsMember
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<BitsMember> for WireBitsMember {
    fn from(natural: BitsMember) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Op {
    Add = 1,
    Mul = 2,
    Div = 3,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for Op {
    type Encoded = WireOp;
}
impl ::std::convert::From<u32> for Op {
    fn from(value: u32) -> Self {
        match value {
            1 => Self::Add,
            2 => Self::Mul,
            3 => Self::Div,

            _ => Self::UnknownOrdinal_(value),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Op
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Op
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOp { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::Add => 1,

            Self::Mul => 2,

            Self::Div => 3,

            Self::UnknownOrdinal_(value) => value,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireOp> for Op {
    fn from(wire: WireOp) -> Self {
        match u32::from(wire.value) {
            1 => Self::Add,

            2 => Self::Mul,

            3 => Self::Div,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::FromWire<WireOp> for Op {
    #[inline]
    fn from_wire(wire: WireOp) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireOp> for Op {
    #[inline]
    fn from_wire_ref(wire: &WireOp) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`Op`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireOp {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireOp {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireOp {
    pub const ADD: WireOp = WireOp { value: ::fidl_next::WireU32(1) };

    pub const MUL: WireOp = WireOp { value: ::fidl_next::WireU32(2) };

    pub const DIV: WireOp = WireOp { value: ::fidl_next::WireU32(3) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOp
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Op> for WireOp {
    fn from(natural: Op) -> Self {
        match natural {
            Op::Add => WireOp::ADD,

            Op::Mul => WireOp::MUL,

            Op::Div => WireOp::DIV,

            Op::UnknownOrdinal_(value) => WireOp { value: ::fidl_next::WireU32::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
pub struct OverrideTest {
    pub op: crate::Op,

    pub left: Option<Box<crate::Expression>>,

    pub right: Option<Box<crate::Expression>>,
}

impl ::fidl_next::Encodable for OverrideTest {
    type Encoded = WireOverrideTest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OverrideTest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                op,
                left,
                right,

            } = out;
        }

        ::fidl_next::Encode::encode(self.op, encoder, op)?;

        ::fidl_next::Encode::encode(self.left, encoder, left)?;

        ::fidl_next::Encode::encode(self.right, encoder, right)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OverrideTest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                op,
                left,
                right,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.op, encoder, op)?;

        ::fidl_next::EncodeRef::encode_ref(&self.left, encoder, left)?;

        ::fidl_next::EncodeRef::encode_ref(&self.right, encoder, right)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for OverrideTest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireOverrideTest<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for OverrideTest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OverrideTest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for OverrideTest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OverrideTest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireOverrideTest<'de>> for OverrideTest {
    #[inline]
    fn from_wire(wire: WireOverrideTest<'de>) -> Self {
        Self {
            op: ::fidl_next::FromWire::from_wire(wire.op),

            left: ::fidl_next::FromWire::from_wire(wire.left),

            right: ::fidl_next::FromWire::from_wire(wire.right),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireOverrideTest<'de>> for OverrideTest {
    #[inline]
    fn from_wire_ref(wire: &WireOverrideTest<'de>) -> Self {
        Self {
            op: ::fidl_next::FromWireRef::from_wire_ref(&wire.op),

            left: ::fidl_next::FromWireRef::from_wire_ref(&wire.left),

            right: ::fidl_next::FromWireRef::from_wire_ref(&wire.right),
        }
    }
}

/// The wire type corresponding to [`OverrideTest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireOverrideTest<'de> {
    pub op: crate::WireOp,

    pub left: crate::WireOptionalExpression<'de>,

    pub right: crate::WireOptionalExpression<'de>,
}

unsafe impl ::fidl_next::Wire for WireOverrideTest<'static> {
    type Decoded<'de> = WireOverrideTest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(4).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOverrideTest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut op,
                mut left,
                mut right,

            } = slot;
        }

        ::fidl_next::Decode::decode(op.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(left.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(right.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Flags: u16 {
        const INLINE = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Flags {
    type Encoded = WireFlags;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Flags
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Flags
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlags { value } = out);
        let _ = value.write(::fidl_next::WireU16::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireFlags> for Flags {
    fn from(wire: WireFlags) -> Self {
        Self::from_bits_retain(u16::from(wire.value))
    }
}

impl ::fidl_next::FromWire<WireFlags> for Flags {
    #[inline]
    fn from_wire(wire: WireFlags) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireFlags> for Flags {
    #[inline]
    fn from_wire_ref(wire: &WireFlags) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`Flags`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireFlags {
    value: ::fidl_next::WireU16,
}

unsafe impl ::fidl_next::Wire for WireFlags {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlags
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Flags> for WireFlags {
    fn from(natural: Flags) -> Self {
        Self { value: ::fidl_next::WireU16::from(natural.bits()) }
    }
}

#[derive(Clone, Debug, Default)]
pub struct FunctionApplication {
    pub func: Option<String>,

    pub args: Option<Vec<Option<Box<crate::Expression>>>>,

    pub flags: Option<crate::Flags>,
}

impl FunctionApplication {
    fn __max_ordinal(&self) -> usize {
        if self.flags.is_some() {
            return 4;
        }

        if self.args.is_some() {
            return 3;
        }

        if self.func.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for FunctionApplication {
    type Encoded = WireFunctionApplication<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for FunctionApplication
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFunctionApplication { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                4 => {
                    if let Some(flags) = self.flags.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            flags,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                3 => {
                    if let Some(args) = self.args.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            args,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(func) = self.func.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            func,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for FunctionApplication
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFunctionApplication { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                4 => {
                    if let Some(flags) = &self.flags {
                        ::fidl_next::WireEnvelope::encode_value(
                            flags,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                3 => {
                    if let Some(args) = &self.args {
                        ::fidl_next::WireEnvelope::encode_value(
                            args,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                1 => {
                    if let Some(func) = &self.func {
                        ::fidl_next::WireEnvelope::encode_value(
                            func,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireFunctionApplication<'de>> for FunctionApplication {
    #[inline]
    fn from_wire(wire: WireFunctionApplication<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let func = wire.table.get(1);

        let args = wire.table.get(3);

        let flags = wire.table.get(4);

        Self {


                func: func.map(|envelope| ::fidl_next::FromWire::from_wire(
                    unsafe { envelope.read_unchecked::<::fidl_next::WireString<'de>>() }
                )),


                args: args.map(|envelope| ::fidl_next::FromWire::from_wire(
                    unsafe { envelope.read_unchecked::<::fidl_next::WireVector<'de, crate::WireOptionalExpression<'de>>>() }
                )),


                flags: flags.map(|envelope| ::fidl_next::FromWire::from_wire(
                    unsafe { envelope.read_unchecked::<crate::WireFlags>() }
                )),

        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireFunctionApplication<'de>> for FunctionApplication {
    #[inline]
    fn from_wire_ref(wire: &WireFunctionApplication<'de>) -> Self {
        Self {


                func: wire.table.get(1)
                    .map(|envelope| ::fidl_next::FromWireRef::from_wire_ref(
                        unsafe { envelope.deref_unchecked::<::fidl_next::WireString<'de>>() }
                    )),


                args: wire.table.get(3)
                    .map(|envelope| ::fidl_next::FromWireRef::from_wire_ref(
                        unsafe { envelope.deref_unchecked::<::fidl_next::WireVector<'de, crate::WireOptionalExpression<'de>>>() }
                    )),


                flags: wire.table.get(4)
                    .map(|envelope| ::fidl_next::FromWireRef::from_wire_ref(
                        unsafe { envelope.deref_unchecked::<crate::WireFlags>() }
                    )),

        }
    }
}

/// The wire type corresponding to [`FunctionApplication`].
#[repr(C)]
pub struct WireFunctionApplication<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireFunctionApplication<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireString<'de>>() });

        let _ = self.table.get(3).map(|envelope| unsafe {
            envelope
                .read_unchecked::<::fidl_next::WireVector<'de, crate::WireOptionalExpression<'de>>>(
                )
        });

        let _ = self
            .table
            .get(4)
            .map(|envelope| unsafe { envelope.read_unchecked::<crate::WireFlags>() });
    }
}

unsafe impl ::fidl_next::Wire for WireFunctionApplication<'static> {
    type Decoded<'de> = WireFunctionApplication<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFunctionApplication<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireString<'static>>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    let func = unsafe {
                        slot.deref_unchecked().deref_unchecked::<::fidl_next::WireString<'_>>()
                    };

                    if func.len() > 100 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: func.len() as u64,
                            limit: 100,
                        });
                    }

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<'static, crate::WireOptionalExpression<'static>>,
                    >(slot.as_mut(), decoder)?;

                    let args = unsafe {
                        slot
                                            .deref_unchecked()
                                            .deref_unchecked::<
                                                ::fidl_next::WireVector<'_, crate::WireOptionalExpression<'_>>
                                            >()
                    };

                    if args.len() > 5 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: args.len() as u64,
                            limit: 5,
                        });
                    }

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, crate::WireFlags>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireFunctionApplication<'de> {
    pub fn func(&self) -> Option<&::fidl_next::WireString<'de>> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn args(
        &self,
    ) -> Option<&::fidl_next::WireVector<'de, crate::WireOptionalExpression<'de>>> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn flags(&self) -> Option<&crate::WireFlags> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireFunctionApplication<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("FunctionApplication")
            .field("func", &self.func())
            .field("args", &self.args())
            .field("flags", &self.flags())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub enum Expression {
    Value(u64),

    BinOp(crate::OverrideTest),

    FunctionApplication(crate::FunctionApplication),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for Expression {
    type Encoded = WireExpression<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Expression
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExpression { raw, _phantom: _ } = out);

        match self {
            Self::Value(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u64>(value, 1, encoder, raw)?
            }

            Self::BinOp(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::OverrideTest>(
                    value, 2, encoder, raw,
                )?
            }

            Self::FunctionApplication(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::FunctionApplication,
            >(value, 3, encoder, raw)?,

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Expression
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExpression { raw, _phantom: _ } = out);

        match self {
            Self::Value(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &u64>(value, 1, encoder, raw)?
            }

            Self::BinOp(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::OverrideTest>(
                    value, 2, encoder, raw,
                )?
            }

            Self::FunctionApplication(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                &crate::FunctionApplication,
            >(value, 3, encoder, raw)?,

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Expression {
    type EncodedOption = WireOptionalExpression<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Expression
where
    ___E: ?Sized,
    Expression: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExpression { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Expression
where
    ___E: ?Sized,
    Expression: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExpression { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireExpression<'de>> for Expression {
    #[inline]
    fn from_wire(wire: WireExpression<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::Value(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireU64>()
            })),

            2 => Self::BinOp(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<crate::WireOverrideTest<'de>>()
            })),

            3 => Self::FunctionApplication(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<crate::WireFunctionApplication<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireExpression<'de>> for Expression {
    #[inline]
    fn from_wire_ref(wire: &WireExpression<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Value(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireU64>()
            })),

            2 => Self::BinOp(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WireOverrideTest<'de>>()
            })),

            3 => Self::FunctionApplication(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WireFunctionApplication<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalExpression<'de>> for Box<Expression> {
    #[inline]
    fn from_wire_option(wire: WireOptionalExpression<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalExpression<'de>> for Box<Expression> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalExpression<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Expression`].
#[repr(transparent)]
pub struct WireExpression<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

impl<'de> Drop for WireExpression<'de> {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireU64>() };
            }

            2 => {
                let _ = unsafe { self.raw.get().read_unchecked::<crate::WireOverrideTest<'de>>() };
            }

            3 => {
                let _ = unsafe {
                    self.raw.get().read_unchecked::<crate::WireFunctionApplication<'de>>()
                };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireExpression<'static> {
    type Decoded<'de> = WireExpression<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod expression {
    pub enum Ref<'de> {
        Value(&'de ::fidl_next::WireU64),

        BinOp(&'de crate::WireOverrideTest<'de>),

        FunctionApplication(&'de crate::WireFunctionApplication<'de>),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireExpression<'de> {
    pub fn as_ref(&self) -> crate::expression::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::expression::Ref::Value(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU64>()
            }),

            2 => crate::expression::Ref::BinOp(unsafe {
                self.raw.get().deref_unchecked::<crate::WireOverrideTest<'_>>()
            }),

            3 => crate::expression::Ref::FunctionApplication(unsafe {
                self.raw.get().deref_unchecked::<crate::WireFunctionApplication<'_>>()
            }),

            unknown => crate::expression::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExpression<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireU64>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireOverrideTest<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireFunctionApplication<'static>,
            >(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireExpression<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU64>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WireOverrideTest<'_>>().fmt(f) },
            3 => unsafe {
                self.raw.get().deref_unchecked::<crate::WireFunctionApplication<'_>>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExpression<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalExpression<'static> {
    type Decoded<'de> = WireOptionalExpression<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalExpression<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExpression<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireExpression<'de>> {
        if self.is_some() {
            Some(WireExpression { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExpression<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireU64>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireOverrideTest<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireFunctionApplication<'static>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalExpression<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnionMember {
    UnionData(u8),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnionMember {
    type Encoded = WireUnionMember;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnionMember
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionMember { raw, _phantom: _ } = out);

        match self {
            Self::UnionData(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u8>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for UnionMember
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionMember { raw, _phantom: _ } = out);

        match self {
            Self::UnionData(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &u8>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnionMember {
    type EncodedOption = WireOptionalUnionMember;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for UnionMember
where
    ___E: ?Sized,
    UnionMember: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionMember { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for UnionMember
where
    ___E: ?Sized,
    UnionMember: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionMember { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnionMember> for UnionMember {
    #[inline]
    fn from_wire(wire: WireUnionMember) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            2 => Self::UnionData(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<u8>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnionMember> for UnionMember {
    #[inline]
    fn from_wire_ref(wire: &WireUnionMember) -> Self {
        match wire.raw.ordinal() {
            2 => Self::UnionData(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<u8>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnionMember> for Box<UnionMember> {
    #[inline]
    fn from_wire_option(wire: WireOptionalUnionMember) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalUnionMember> for Box<UnionMember> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalUnionMember) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionMember`].
#[repr(transparent)]
pub struct WireUnionMember {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnionMember {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            2 => {
                let _ = unsafe { self.raw.get().read_unchecked::<u8>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnionMember {
    type Decoded<'de> = WireUnionMember;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union_member {
    pub enum Ref<'de> {
        UnionData(&'de u8),

        UnknownOrdinal_(u64),
    }
}

impl WireUnionMember {
    pub fn as_ref(&self) -> crate::union_member::Ref<'_> {
        match self.raw.ordinal() {
            2 => crate::union_member::Ref::UnionData(unsafe {
                self.raw.get().deref_unchecked::<u8>()
            }),

            unknown => crate::union_member::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnionMember {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            2 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<u8>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionMember
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, u8>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnionMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            2 => unsafe { self.raw.get().deref_unchecked::<u8>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionMember {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnionMember {
    type Decoded<'de> = WireOptionalUnionMember;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnionMember {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionMember> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnionMember> {
        if self.is_some() {
            Some(WireUnionMember { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnionMember {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnionMember {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            2 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<u8>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnionMember
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, u8>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnionMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct TableData {
    pub data: u8,
}

impl ::fidl_next::Encodable for TableData {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireTableData> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <u8 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireTableData;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for TableData
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                data,

            } = out;
        }

        ::fidl_next::Encode::encode(self.data, encoder, data)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for TableData
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                data,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.data, encoder, data)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for TableData {
    type EncodedOption = ::fidl_next::WireBox<'static, WireTableData>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for TableData
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TableData: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for TableData
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TableData: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireTableData> for TableData {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireTableData, Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <u8 as ::fidl_next::FromWire<u8>>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireTableData) -> Self {
        Self { data: ::fidl_next::FromWire::from_wire(wire.data) }
    }
}

impl ::fidl_next::FromWireRef<WireTableData> for TableData {
    #[inline]
    fn from_wire_ref(wire: &WireTableData) -> Self {
        Self { data: ::fidl_next::FromWireRef::from_wire_ref(&wire.data) }
    }
}

/// The wire type corresponding to [`TableData`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireTableData {
    pub data: u8,
}

unsafe impl ::fidl_next::Wire for WireTableData {
    type Decoded<'de> = WireTableData;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTableData
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut data,

            } = slot;
        }

        ::fidl_next::Decode::decode(data.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct TableMember {
    pub table_data: Option<Vec<crate::TableData>>,
}

impl TableMember {
    fn __max_ordinal(&self) -> usize {
        if self.table_data.is_some() {
            return 2;
        }

        0
    }
}

impl ::fidl_next::Encodable for TableMember {
    type Encoded = WireTableMember<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for TableMember
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTableMember { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                2 => {
                    if let Some(table_data) = self.table_data.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            table_data,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for TableMember
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTableMember { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                2 => {
                    if let Some(table_data) = &self.table_data {
                        ::fidl_next::WireEnvelope::encode_value(
                            table_data,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireTableMember<'de>> for TableMember {
    #[inline]
    fn from_wire(wire: WireTableMember<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let table_data = wire.table.get(2);

        Self {
            table_data: table_data.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireVector<'de, crate::WireTableData>>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireTableMember<'de>> for TableMember {
    #[inline]
    fn from_wire_ref(wire: &WireTableMember<'de>) -> Self {
        Self {
            table_data: wire.table.get(2).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireVector<'de, crate::WireTableData>>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`TableMember`].
#[repr(C)]
pub struct WireTableMember<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireTableMember<'de> {
    fn drop(&mut self) {
        let _ = self.table.get(2).map(|envelope| unsafe {
            envelope.read_unchecked::<::fidl_next::WireVector<'de, crate::WireTableData>>()
        });
    }
}

unsafe impl ::fidl_next::Wire for WireTableMember<'static> {
    type Decoded<'de> = WireTableMember<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTableMember<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<
                        ___D,
                        ::fidl_next::WireVector<'static, crate::WireTableData>,
                    >(slot.as_mut(), decoder)?;

                    let table_data = unsafe {
                        slot.deref_unchecked()
                            .deref_unchecked::<::fidl_next::WireVector<'_, crate::WireTableData>>()
                    };

                    if table_data.len() > 10 {
                        return Err(::fidl_next::DecodeError::VectorTooLong {
                            size: table_data.len() as u64,
                            limit: 10,
                        });
                    }

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireTableMember<'de> {
    pub fn table_data(&self) -> Option<&::fidl_next::WireVector<'de, crate::WireTableData>> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireTableMember<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("TableMember").field("table_data", &self.table_data()).finish()
    }
}

#[derive(Clone, Debug)]
pub struct SomeProtocolSomeMethodRequest {
    pub union_member: crate::UnionMember,

    pub table_member: crate::TableMember,
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodRequest {
    type Encoded = WireSomeProtocolSomeMethodRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                union_member,
                table_member,

            } = out;
        }

        ::fidl_next::Encode::encode(self.union_member, encoder, union_member)?;

        ::fidl_next::Encode::encode(self.table_member, encoder, table_member)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for SomeProtocolSomeMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                union_member,
                table_member,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.union_member, encoder, union_member)?;

        ::fidl_next::EncodeRef::encode_ref(&self.table_member, encoder, table_member)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for SomeProtocolSomeMethodRequest {
    type EncodedOption = ::fidl_next::WireBox<'static, WireSomeProtocolSomeMethodRequest<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for SomeProtocolSomeMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for SomeProtocolSomeMethodRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireSomeProtocolSomeMethodRequest<'de>>
    for SomeProtocolSomeMethodRequest
{
    #[inline]
    fn from_wire(wire: WireSomeProtocolSomeMethodRequest<'de>) -> Self {
        Self {
            union_member: ::fidl_next::FromWire::from_wire(wire.union_member),

            table_member: ::fidl_next::FromWire::from_wire(wire.table_member),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireSomeProtocolSomeMethodRequest<'de>>
    for SomeProtocolSomeMethodRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireSomeProtocolSomeMethodRequest<'de>) -> Self {
        Self {
            union_member: ::fidl_next::FromWireRef::from_wire_ref(&wire.union_member),

            table_member: ::fidl_next::FromWireRef::from_wire_ref(&wire.table_member),
        }
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireSomeProtocolSomeMethodRequest<'de> {
    pub union_member: crate::WireUnionMember,

    pub table_member: crate::WireTableMember<'de>,
}

unsafe impl ::fidl_next::Wire for WireSomeProtocolSomeMethodRequest<'static> {
    type Decoded<'de> = WireSomeProtocolSomeMethodRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodRequest<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut union_member,
                mut table_member,

            } = slot;
        }

        ::fidl_next::Decode::decode(union_member.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table_member.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct SomeProtocolSomeMethodResponse {
    pub bits_member: crate::BitsMember,
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireSomeProtocolSomeMethodResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <crate::BitsMember as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireSomeProtocolSomeMethodResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits_member,

            } = out;
        }

        ::fidl_next::Encode::encode(self.bits_member, encoder, bits_member)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for SomeProtocolSomeMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits_member,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.bits_member, encoder, bits_member)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for SomeProtocolSomeMethodResponse {
    type EncodedOption = ::fidl_next::WireBox<'static, WireSomeProtocolSomeMethodResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for SomeProtocolSomeMethodResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for SomeProtocolSomeMethodResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SomeProtocolSomeMethodResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireSomeProtocolSomeMethodResponse> for SomeProtocolSomeMethodResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireSomeProtocolSomeMethodResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::BitsMember as ::fidl_next::FromWire<crate::WireBitsMember>
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn from_wire(wire: WireSomeProtocolSomeMethodResponse) -> Self {
        Self { bits_member: ::fidl_next::FromWire::from_wire(wire.bits_member) }
    }
}

impl ::fidl_next::FromWireRef<WireSomeProtocolSomeMethodResponse>
    for SomeProtocolSomeMethodResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireSomeProtocolSomeMethodResponse) -> Self {
        Self { bits_member: ::fidl_next::FromWireRef::from_wire_ref(&wire.bits_member) }
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireSomeProtocolSomeMethodResponse {
    pub bits_member: crate::WireBitsMember,
}

unsafe impl ::fidl_next::Wire for WireSomeProtocolSomeMethodResponse {
    type Decoded<'de> = WireSomeProtocolSomeMethodResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits_member,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits_member.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum SomeProtocolSomeMethodError {
    ErrorOne = 1,
    ErrorTwo = 2,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for SomeProtocolSomeMethodError {
    type Encoded = WireSomeProtocolSomeMethodError;
}
impl ::std::convert::From<u32> for SomeProtocolSomeMethodError {
    fn from(value: u32) -> Self {
        match value {
            1 => Self::ErrorOne,
            2 => Self::ErrorTwo,

            _ => Self::UnknownOrdinal_(value),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for SomeProtocolSomeMethodError
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for SomeProtocolSomeMethodError
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSomeProtocolSomeMethodError { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::ErrorOne => 1,

            Self::ErrorTwo => 2,

            Self::UnknownOrdinal_(value) => value,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    fn from(wire: WireSomeProtocolSomeMethodError) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrorOne,

            2 => Self::ErrorTwo,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::FromWire<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    #[inline]
    fn from_wire(wire: WireSomeProtocolSomeMethodError) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireSomeProtocolSomeMethodError> for SomeProtocolSomeMethodError {
    #[inline]
    fn from_wire_ref(wire: &WireSomeProtocolSomeMethodError) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`SomeProtocolSomeMethodError`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireSomeProtocolSomeMethodError {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireSomeProtocolSomeMethodError {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireSomeProtocolSomeMethodError {
    pub const ERROR_ONE: WireSomeProtocolSomeMethodError =
        WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32(1) };

    pub const ERROR_TWO: WireSomeProtocolSomeMethodError =
        WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSomeProtocolSomeMethodError
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<SomeProtocolSomeMethodError> for WireSomeProtocolSomeMethodError {
    fn from(natural: SomeProtocolSomeMethodError) -> Self {
        match natural {
            SomeProtocolSomeMethodError::ErrorOne => WireSomeProtocolSomeMethodError::ERROR_ONE,

            SomeProtocolSomeMethodError::ErrorTwo => WireSomeProtocolSomeMethodError::ERROR_TWO,

            SomeProtocolSomeMethodError::UnknownOrdinal_(value) => {
                WireSomeProtocolSomeMethodError { value: ::fidl_next::WireU32::from(value) }
            }
        }
    }
}

/// The type corresponding to the SomeProtocol protocol.
#[derive(Debug)]
pub struct SomeProtocol;

pub mod some_protocol {
    pub mod prelude {
        pub use crate::{
            some_protocol, SomeProtocol, SomeProtocolClientHandler, SomeProtocolClientSender,
            SomeProtocolServerHandler, SomeProtocolServerSender,
        };

        pub use crate::SomeProtocolSomeMethodRequest;

        pub use crate::SomeProtocolSomeMethodError;

        pub use crate::SomeProtocolSomeMethodResponse;
    }

    pub struct SomeMethod;

    impl ::fidl_next::Method for SomeMethod {
        const ORDINAL: u64 = 2515914517457749720;

        type Protocol = crate::SomeProtocol;

        type Request = crate::WireSomeProtocolSomeMethodRequest<'static>;

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireSomeProtocolSomeMethodResponse,
            crate::WireSomeProtocolSomeMethodError,
        >;
    }
}

/// A helper trait for the `SomeProtocol` client sender.
pub trait SomeProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn some_method<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, some_protocol::SomeMethod, Self::Transport>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireSomeProtocolSomeMethodRequest<'static>,
        >;
}

impl<___T> SomeProtocolClientSender for ::fidl_next::ClientSender<SomeProtocol, ___T>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn some_method<___R>(
        &self,
        request: ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, some_protocol::SomeMethod, Self::Transport>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireSomeProtocolSomeMethodRequest<'static>,
        >,
    {
        self.as_untyped()
            .send_two_way(2515914517457749720, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the SomeProtocol protocol.
///
/// See [`SomeProtocol`] for more details.
pub trait SomeProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for SomeProtocol
where
    ___H: SomeProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <some_protocol::SomeMethod as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `SomeProtocol` server sender.
pub trait SomeProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> SomeProtocolServerSender for ::fidl_next::ServerSender<SomeProtocol, ___T>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the SomeProtocol protocol.
///
/// See [`SomeProtocol`] for more details.
pub trait SomeProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn some_method(
        &mut self,
        sender: &::fidl_next::ServerSender<SomeProtocol, ___T>,

        request: ::fidl_next::Request<some_protocol::SomeMethod, ___T>,

        responder: ::fidl_next::Responder<some_protocol::SomeMethod>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for SomeProtocol
where
    ___H: SomeProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <some_protocol::SomeMethod as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2515914517457749720 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.some_method(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::core::convert::From<crate::BitsMember> for ::fidl_test_anonymous::BitsMember {
        #[inline]
        fn from(from: crate::BitsMember) -> Self {
            Self::from_bits_retain(from.bits())
        }
    }

    impl ::core::convert::From<crate::Op> for ::fidl_test_anonymous::Op {
        #[inline]
        fn from(from: crate::Op) -> Self {
            match crate::Op::from(from) {
                crate::Op::Add => Self::Add,

                crate::Op::Mul => Self::Mul,

                crate::Op::Div => Self::Div,

                crate::Op::UnknownOrdinal_(value) => {
                    Self::__SourceBreaking { unknown_ordinal: value }
                }
            }
        }
    }

    impl ::core::convert::From<crate::Flags> for ::fidl_test_anonymous::Flags {
        #[inline]
        fn from(from: crate::Flags) -> Self {
            Self::from_bits_retain(from.bits())
        }
    }

    impl ::core::convert::From<crate::SomeProtocolSomeMethodError>
        for ::fidl_test_anonymous::SomeProtocolSomeMethodError
    {
        #[inline]
        fn from(from: crate::SomeProtocolSomeMethodError) -> Self {
            match crate::SomeProtocolSomeMethodError::from(from) {
                crate::SomeProtocolSomeMethodError::ErrorOne => Self::ErrorOne,

                crate::SomeProtocolSomeMethodError::ErrorTwo => Self::ErrorTwo,

                crate::SomeProtocolSomeMethodError::UnknownOrdinal_(value) => {
                    Self::__SourceBreaking { unknown_ordinal: value }
                }
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `SomeProtocol`
    /// protocol.
    pub type SomeProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::SomeProtocol>;

    impl ::core::convert::From<crate::SomeProtocol> for ::fidl_test_anonymous::SomeProtocolMarker {
        #[inline]
        fn from(_: crate::SomeProtocol) -> Self {
            Self
        }
    }
}
