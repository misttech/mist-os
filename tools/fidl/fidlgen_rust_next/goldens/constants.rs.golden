// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub const BOOL: bool = true;

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Bits: u32 {
        const B = 8;

    }
}

impl ::fidl_next::Encodable for Bits {
    type Encoded = WireBits;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBits { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBits> for Bits {
    fn from(wire: WireBits) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBits> for Bits {
    #[inline]
    fn take_from(from: &WireBits) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Bits`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBits {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireBits {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBits
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !Bits::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: Bits::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<Bits> for WireBits {
    fn from(natural: Bits) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

pub const UINT32: u32 = 4;

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct BitsType: u32 {
        const VALUE = 1;
        const SECOND_VALUE = 4;
        const THIRD_VALUE = 2;

    }
}

impl ::fidl_next::Encodable for BitsType {
    type Encoded = WireBitsType;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for BitsType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBitsType { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBitsType> for BitsType {
    fn from(wire: WireBitsType) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBitsType> for BitsType {
    #[inline]
    fn take_from(from: &WireBitsType) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`BitsType`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBitsType {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireBitsType {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBitsType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !BitsType::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: BitsType::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<BitsType> for WireBitsType {
    fn from(natural: BitsType) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Enum {
    E = 170,
}

impl ::fidl_next::Encodable for Enum {
    type Encoded = WireEnum;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::E => 170,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnum> for Enum {
    fn from(wire: WireEnum) -> Self {
        match u32::from(wire.value) {
            170 => Self::E,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireEnum> for Enum {
    #[inline]
    fn take_from(from: &WireEnum) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Enum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireEnum {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnum {
    pub const E: WireEnum = WireEnum { value: ::fidl_next::WireU32(170) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            170 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<Enum> for WireEnum {
    fn from(natural: Enum) -> Self {
        match natural {
            Enum::E => WireEnum::E,
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(i32)]
pub enum EnumType {
    Value = 3,
    SecondValue = 4,
}

impl ::fidl_next::Encodable for EnumType {
    type Encoded = WireEnumType;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for EnumType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnumType { value } = out);
        let _ = value.write(::fidl_next::WireI32::from(match *self {
            Self::Value => 3,

            Self::SecondValue => 4,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnumType> for EnumType {
    fn from(wire: WireEnumType) -> Self {
        match i32::from(wire.value) {
            3 => Self::Value,

            4 => Self::SecondValue,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireEnumType> for EnumType {
    #[inline]
    fn take_from(from: &WireEnumType) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`EnumType`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnumType {
    value: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireEnumType {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnumType {
    pub const VALUE: WireEnumType = WireEnumType { value: ::fidl_next::WireI32(3) };

    pub const SECOND_VALUE: WireEnumType = WireEnumType { value: ::fidl_next::WireI32(4) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnumType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match i32::from(*value) {
            3 | 4 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<EnumType> for WireEnumType {
    fn from(natural: EnumType) -> Self {
        match natural {
            EnumType::Value => WireEnumType::VALUE,

            EnumType::SecondValue => WireEnumType::SECOND_VALUE,
        }
    }
}

pub const FLOAT32: f32 = 3.14159;

pub const FLOAT64: f64 = 3.14159;

pub const INT16: i16 = 4;

pub const INT32: i32 = 4;

pub const INT64: i64 = 4;

pub const INT8: i8 = 4;

pub const STRING: &str = "string";

#[derive(Clone, Debug)]
pub struct Struct {
    pub int64_with_default: i64,

    pub string_with_default: String,

    pub bool_with_default: bool,

    pub enum_with_default: crate::Enum,

    pub bits_with_default: crate::Bits,
}

impl ::fidl_next::Encodable for Struct {
    type Encoded = WireStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                int64_with_default,
                string_with_default,
                bool_with_default,
                enum_with_default,
                bits_with_default,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.int64_with_default, encoder, int64_with_default)?;

        ::fidl_next::Encode::encode(&mut self.string_with_default, encoder, string_with_default)?;

        ::fidl_next::Encode::encode(&mut self.bool_with_default, encoder, bool_with_default)?;

        ::fidl_next::Encode::encode(&mut self.enum_with_default, encoder, enum_with_default)?;

        ::fidl_next::Encode::encode(&mut self.bits_with_default, encoder, bits_with_default)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Struct> {
    type EncodedOption = ::fidl_next::WireBox<WireStruct>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Struct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStruct> for Struct {
    #[inline]
    fn take_from(from: &WireStruct) -> Self {
        Self {
            int64_with_default: ::fidl_next::TakeFrom::take_from(&from.int64_with_default),

            string_with_default: ::fidl_next::TakeFrom::take_from(&from.string_with_default),

            bool_with_default: ::fidl_next::TakeFrom::take_from(&from.bool_with_default),

            enum_with_default: ::fidl_next::TakeFrom::take_from(&from.enum_with_default),

            bits_with_default: ::fidl_next::TakeFrom::take_from(&from.bits_with_default),
        }
    }
}

/// The wire type corersponding to [`Struct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireStruct {
    pub int64_with_default: ::fidl_next::WireI64,

    pub string_with_default: ::fidl_next::WireString,

    pub bool_with_default: bool,

    pub enum_with_default: crate::WireEnum,

    pub bits_with_default: crate::WireBits,
}

unsafe impl ::fidl_next::ZeroPadding for WireStruct {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(36).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(25).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut int64_with_default,
                mut string_with_default,
                mut bool_with_default,
                mut enum_with_default,
                mut bits_with_default,

            } = slot;
        }

        ::fidl_next::Decode::decode(int64_with_default.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(string_with_default.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(bool_with_default.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(enum_with_default.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(bits_with_default.as_mut(), decoder)?;

        Ok(())
    }
}

pub const UINT16: u16 = 4;

pub const UINT64: u64 = 4;

pub const UINT8: u8 = 4;

pub const BITS_PRIMITIVE_VAL: u32 = 1;

pub const BITS_VAL: crate::BitsType = crate::BitsType::VALUE;

pub const ENUM_PRIMITIVE_VAL: i32 = 3;

pub const ENUM_VAL: crate::EnumType = crate::EnumType::Value;

pub const OR_RESULT: crate::BitsType = crate::BitsType::from_bits_retain(7);

pub const OR_RESULT_PRIMITIVE_VAL: u32 = 5;

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {}
