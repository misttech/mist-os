// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(
    unused_parens,
    unused_variables,
    unused_mut,
    unused_imports,
    unreachable_code,
    nonstandard_style
)]

#[derive(Clone, Debug)]
pub struct Int16Int8 {
    pub a: i16,
    pub b: i8,
}

impl ::fidl::Encodable for Int16Int8 {
    type Encoded<'buf> = WireInt16Int8;
}

impl<___E> ::fidl::Encode<___E> for Int16Int8
where
    i16: ::fidl::Encode<___E>,
    i8: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<Int16Int8> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireInt16Int8>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<Int16Int8>
where
    ___E: ::fidl::Encoder + ?Sized,
    Int16Int8: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireInt16Int8> for Int16Int8 {
    fn take_from(from: &mut WireInt16Int8) -> Self {
        Self {
            a: ::fidl::TakeFrom::take_from(&mut from.a),
            b: ::fidl::TakeFrom::take_from(&mut from.b),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireInt16Int8 {
    pub a: ::fidl::i16_le,
    pub b: i8,
}

unsafe impl<___D> ::fidl::Decode<___D> for WireInt16Int8
where
    ___D: ?Sized,

    ::fidl::i16_le: ::fidl::Decode<___D>,
    i8: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut a,
                mut b,
            } = slot;
        }
        ::fidl::Decode::decode(a.as_mut(), decoder)?;
        ::fidl::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ArrayInt16Int8 {
    pub arr: [crate::Int16Int8; 3],
}

impl ::fidl::Encodable for ArrayInt16Int8 {
    type Encoded<'buf> = WireArrayInt16Int8;
}

impl<___E> ::fidl::Encode<___E> for ArrayInt16Int8
where
    [crate::Int16Int8; 3]: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                arr,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.arr, encoder, arr)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<ArrayInt16Int8> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireArrayInt16Int8>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<ArrayInt16Int8>
where
    ___E: ::fidl::Encoder + ?Sized,
    ArrayInt16Int8: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireArrayInt16Int8> for ArrayInt16Int8 {
    fn take_from(from: &mut WireArrayInt16Int8) -> Self {
        Self { arr: ::fidl::TakeFrom::take_from(&mut from.arr) }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireArrayInt16Int8 {
    pub arr: [crate::WireInt16Int8; 3],
}

unsafe impl<___D> ::fidl::Decode<___D> for WireArrayInt16Int8
where
    ___D: ?Sized,

    [crate::WireInt16Int8; 3]: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut arr,
            } = slot;
        }
        ::fidl::Decode::decode(arr.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Int8Int32 {
    pub a: i8,
    pub b: i32,
}

impl ::fidl::Encodable for Int8Int32 {
    type Encoded<'buf> = WireInt8Int32;
}

impl<___E> ::fidl::Encode<___E> for Int8Int32
where
    i8: ::fidl::Encode<___E>,
    i32: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<Int8Int32> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireInt8Int32>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<Int8Int32>
where
    ___E: ::fidl::Encoder + ?Sized,
    Int8Int32: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireInt8Int32> for Int8Int32 {
    fn take_from(from: &mut WireInt8Int32) -> Self {
        Self {
            a: ::fidl::TakeFrom::take_from(&mut from.a),
            b: ::fidl::TakeFrom::take_from(&mut from.b),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireInt8Int32 {
    pub a: i8,
    pub b: ::fidl::i32_le,
}

unsafe impl<___D> ::fidl::Decode<___D> for WireInt8Int32
where
    ___D: ?Sized,

    i8: ::fidl::Decode<___D>,
    ::fidl::i32_le: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut a,
                mut b,
            } = slot;
        }
        ::fidl::Decode::decode(a.as_mut(), decoder)?;
        ::fidl::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct NonInlineStructTestStruct {
    pub element: Option<Box<crate::Int16Int8>>,
    pub h: ::fidl::Handle,
}

impl ::fidl::Encodable for NonInlineStructTestStruct {
    type Encoded<'buf> = WireNonInlineStructTestStruct<'buf>;
}

impl<___E> ::fidl::Encode<___E> for NonInlineStructTestStruct
where
    Option<Box<crate::Int16Int8>>: ::fidl::Encode<___E>,
    ::fidl::Handle: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                element,
                h,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.element, encoder, element)?;
        ::fidl::Encode::encode(&mut self.h, encoder, h)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<NonInlineStructTestStruct> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireNonInlineStructTestStruct<'buf>>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<NonInlineStructTestStruct>
where
    ___E: ::fidl::Encoder + ?Sized,
    NonInlineStructTestStruct: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireNonInlineStructTestStruct<'buf>> for NonInlineStructTestStruct {
    fn take_from(from: &mut WireNonInlineStructTestStruct<'buf>) -> Self {
        Self {
            element: ::fidl::TakeFrom::take_from(&mut from.element),
            h: ::fidl::TakeFrom::take_from(&mut from.h),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireNonInlineStructTestStruct<'buf> {
    pub element: ::fidl::WireBox<'buf, crate::WireInt16Int8>,
    pub h: ::fidl::WireHandle,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireNonInlineStructTestStruct<'buf>
where
    ___D: ?Sized,

    ::fidl::WireBox<'buf, crate::WireInt16Int8>: ::fidl::Decode<___D>,
    ::fidl::WireHandle: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut element,
                mut h,
            } = slot;
        }
        ::fidl::Decode::decode(element.as_mut(), decoder)?;
        ::fidl::Decode::decode(h.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct StructPaddingTestStruct {
    pub trailing: crate::Int16Int8,
    pub inner: crate::Int8Int32,
    pub array: crate::ArrayInt16Int8,
}

impl ::fidl::Encodable for StructPaddingTestStruct {
    type Encoded<'buf> = WireStructPaddingTestStruct;
}

impl<___E> ::fidl::Encode<___E> for StructPaddingTestStruct
where
    crate::Int16Int8: ::fidl::Encode<___E>,
    crate::Int8Int32: ::fidl::Encode<___E>,
    crate::ArrayInt16Int8: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                trailing,
                inner,
                array,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.trailing, encoder, trailing)?;
        ::fidl::Encode::encode(&mut self.inner, encoder, inner)?;
        ::fidl::Encode::encode(&mut self.array, encoder, array)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<StructPaddingTestStruct> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireStructPaddingTestStruct>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<StructPaddingTestStruct>
where
    ___E: ::fidl::Encoder + ?Sized,
    StructPaddingTestStruct: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireStructPaddingTestStruct> for StructPaddingTestStruct {
    fn take_from(from: &mut WireStructPaddingTestStruct) -> Self {
        Self {
            trailing: ::fidl::TakeFrom::take_from(&mut from.trailing),
            inner: ::fidl::TakeFrom::take_from(&mut from.inner),
            array: ::fidl::TakeFrom::take_from(&mut from.array),
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireStructPaddingTestStruct {
    pub trailing: crate::WireInt16Int8,
    pub inner: crate::WireInt8Int32,
    pub array: crate::WireArrayInt16Int8,
}

unsafe impl<___D> ::fidl::Decode<___D> for WireStructPaddingTestStruct
where
    ___D: ?Sized,

    crate::WireInt16Int8: ::fidl::Decode<___D>,
    crate::WireInt8Int32: ::fidl::Decode<___D>,
    crate::WireArrayInt16Int8: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut trailing,
                mut inner,
                mut array,
            } = slot;
        }
        ::fidl::Decode::decode(trailing.as_mut(), decoder)?;
        ::fidl::Decode::decode(inner.as_mut(), decoder)?;
        ::fidl::Decode::decode(array.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct TopLevelStruct {
    pub a: crate::StructPaddingTestStruct,
    pub b: crate::NonInlineStructTestStruct,
}

impl ::fidl::Encodable for TopLevelStruct {
    type Encoded<'buf> = WireTopLevelStruct<'buf>;
}

impl<___E> ::fidl::Encode<___E> for TopLevelStruct
where
    crate::StructPaddingTestStruct: ::fidl::Encode<___E>,
    crate::NonInlineStructTestStruct: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<TopLevelStruct> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireTopLevelStruct<'buf>>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<TopLevelStruct>
where
    ___E: ::fidl::Encoder + ?Sized,
    TopLevelStruct: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireTopLevelStruct<'buf>> for TopLevelStruct {
    fn take_from(from: &mut WireTopLevelStruct<'buf>) -> Self {
        Self {
            a: ::fidl::TakeFrom::take_from(&mut from.a),
            b: ::fidl::TakeFrom::take_from(&mut from.b),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireTopLevelStruct<'buf> {
    pub a: crate::WireStructPaddingTestStruct,
    pub b: crate::WireNonInlineStructTestStruct<'buf>,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireTopLevelStruct<'buf>
where
    ___D: ?Sized,

    crate::WireStructPaddingTestStruct: ::fidl::Decode<___D>,
    crate::WireNonInlineStructTestStruct<'buf>: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut a,
                mut b,
            } = slot;
        }
        ::fidl::Decode::decode(a.as_mut(), decoder)?;
        ::fidl::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}
