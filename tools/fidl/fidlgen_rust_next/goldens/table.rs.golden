// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct EmptyTable {}

impl EmptyTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for EmptyTable {
    type Encoded = WireEmptyTable;
}

impl<___E> ::fidl_next::Encode<___E> for EmptyTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEmptyTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireEmptyTable> for EmptyTable {
    fn take_from(from: &WireEmptyTable) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`EmptyTable`].
#[repr(C)]
pub struct WireEmptyTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireEmptyTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireEmptyTable {}

impl ::core::fmt::Debug for WireEmptyTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("EmptyTable").finish()
    }
}

#[derive(Clone, Debug)]
pub struct ExtensionTable {}

impl ExtensionTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for ExtensionTable {
    type Encoded = WireExtensionTable;
}

impl<___E> ::fidl_next::Encode<___E> for ExtensionTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExtensionTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExtensionTable> for ExtensionTable {
    fn take_from(from: &WireExtensionTable) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`ExtensionTable`].
#[repr(C)]
pub struct WireExtensionTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireExtensionTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireExtensionTable {}

impl ::core::fmt::Debug for WireExtensionTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ExtensionTable").finish()
    }
}

#[derive(Clone, Debug)]
pub struct NewerSimpleTable {
    pub x: Option<i64>,

    pub y: Option<i64>,

    pub z: Option<i64>,
}

impl NewerSimpleTable {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        if self.y.is_some() {
            return 5;
        }

        if self.z.is_some() {
            return 6;
        }

        0
    }
}

impl ::fidl_next::Encodable for NewerSimpleTable {
    type Encoded = WireNewerSimpleTable;
}

impl<___E> ::fidl_next::Encode<___E> for NewerSimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireNewerSimpleTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                6 => {
                    if let Some(z) = &mut self.z {
                        ::fidl_next::WireEnvelope::encode_value(
                            z,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                5 => {
                    if let Some(y) = &mut self.y {
                        ::fidl_next::WireEnvelope::encode_value(
                            y,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                1 => {
                    if let Some(x) = &mut self.x {
                        ::fidl_next::WireEnvelope::encode_value(
                            x,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireNewerSimpleTable> for NewerSimpleTable {
    fn take_from(from: &WireNewerSimpleTable) -> Self {
        Self {
            x: from.x().map(::fidl_next::TakeFrom::take_from),

            y: from.y().map(::fidl_next::TakeFrom::take_from),

            z: from.z().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`NewerSimpleTable`].
#[repr(C)]
pub struct WireNewerSimpleTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireNewerSimpleTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                5 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                6 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireNewerSimpleTable {
    pub fn x(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn y(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(5)?.deref_unchecked()) }
    }

    pub fn z(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(6)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireNewerSimpleTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("NewerSimpleTable")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct OlderSimpleTable {
    pub x: Option<i64>,
}

impl OlderSimpleTable {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for OlderSimpleTable {
    type Encoded = WireOlderSimpleTable;
}

impl<___E> ::fidl_next::Encode<___E> for OlderSimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOlderSimpleTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(x) = &mut self.x {
                        ::fidl_next::WireEnvelope::encode_value(
                            x,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOlderSimpleTable> for OlderSimpleTable {
    fn take_from(from: &WireOlderSimpleTable) -> Self {
        Self { x: from.x().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`OlderSimpleTable`].
#[repr(C)]
pub struct WireOlderSimpleTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOlderSimpleTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireOlderSimpleTable {
    pub fn x(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireOlderSimpleTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OlderSimpleTable").field("x", &self.x()).finish()
    }
}

#[derive(Clone, Debug)]
pub struct ReverseOrdinalTable {
    pub z: Option<i64>,

    pub y: Option<i64>,

    pub x: Option<i64>,
}

impl ReverseOrdinalTable {
    fn __max_ordinal(&self) -> usize {
        if self.z.is_some() {
            return 1;
        }

        if self.y.is_some() {
            return 2;
        }

        if self.x.is_some() {
            return 3;
        }

        0
    }
}

impl ::fidl_next::Encodable for ReverseOrdinalTable {
    type Encoded = WireReverseOrdinalTable;
}

impl<___E> ::fidl_next::Encode<___E> for ReverseOrdinalTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireReverseOrdinalTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                3 => {
                    if let Some(x) = &mut self.x {
                        ::fidl_next::WireEnvelope::encode_value(
                            x,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                2 => {
                    if let Some(y) = &mut self.y {
                        ::fidl_next::WireEnvelope::encode_value(
                            y,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                1 => {
                    if let Some(z) = &mut self.z {
                        ::fidl_next::WireEnvelope::encode_value(
                            z,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireReverseOrdinalTable> for ReverseOrdinalTable {
    fn take_from(from: &WireReverseOrdinalTable) -> Self {
        Self {
            z: from.z().map(::fidl_next::TakeFrom::take_from),

            y: from.y().map(::fidl_next::TakeFrom::take_from),

            x: from.x().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`ReverseOrdinalTable`].
#[repr(C)]
pub struct WireReverseOrdinalTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireReverseOrdinalTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireReverseOrdinalTable {
    pub fn z(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn y(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }

    pub fn x(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireReverseOrdinalTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ReverseOrdinalTable")
            .field("z", &self.z())
            .field("y", &self.y())
            .field("x", &self.x())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct SimpleTable {
    pub x: Option<i64>,

    pub y: Option<i64>,
}

impl SimpleTable {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        if self.y.is_some() {
            return 5;
        }

        0
    }
}

impl ::fidl_next::Encodable for SimpleTable {
    type Encoded = WireSimpleTable;
}

impl<___E> ::fidl_next::Encode<___E> for SimpleTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSimpleTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                5 => {
                    if let Some(y) = &mut self.y {
                        ::fidl_next::WireEnvelope::encode_value(
                            y,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                1 => {
                    if let Some(x) = &mut self.x {
                        ::fidl_next::WireEnvelope::encode_value(
                            x,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSimpleTable> for SimpleTable {
    fn take_from(from: &WireSimpleTable) -> Self {
        Self {
            x: from.x().map(::fidl_next::TakeFrom::take_from),

            y: from.y().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`SimpleTable`].
#[repr(C)]
pub struct WireSimpleTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireSimpleTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                5 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireSimpleTable {
    pub fn x(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn y(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(5)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireSimpleTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("SimpleTable").field("x", &self.x()).field("y", &self.y()).finish()
    }
}

#[derive(Clone, Debug)]
pub struct SixtyFourOrdinalTable {
    pub v1: Option<i64>,

    pub v2: Option<i64>,

    pub v3: Option<i64>,

    pub v4: Option<i64>,

    pub v5: Option<i64>,

    pub v6: Option<i64>,

    pub v7: Option<i64>,

    pub v8: Option<i64>,

    pub v9: Option<i64>,

    pub v10: Option<i64>,

    pub v11: Option<i64>,

    pub v12: Option<i64>,

    pub v13: Option<i64>,

    pub v14: Option<i64>,

    pub v15: Option<i64>,

    pub v16: Option<i64>,

    pub v17: Option<i64>,

    pub v18: Option<i64>,

    pub v19: Option<i64>,

    pub v20: Option<i64>,

    pub v21: Option<i64>,

    pub v22: Option<i64>,

    pub v23: Option<i64>,

    pub v24: Option<i64>,

    pub v25: Option<i64>,

    pub v26: Option<i64>,

    pub v27: Option<i64>,

    pub v28: Option<i64>,

    pub v29: Option<i64>,

    pub v30: Option<i64>,

    pub v31: Option<i64>,

    pub v32: Option<i64>,

    pub v33: Option<i64>,

    pub v34: Option<i64>,

    pub v35: Option<i64>,

    pub v36: Option<i64>,

    pub v37: Option<i64>,

    pub v38: Option<i64>,

    pub v39: Option<i64>,

    pub v40: Option<i64>,

    pub v41: Option<i64>,

    pub v42: Option<i64>,

    pub v43: Option<i64>,

    pub v44: Option<i64>,

    pub v45: Option<i64>,

    pub v46: Option<i64>,

    pub v47: Option<i64>,

    pub v48: Option<i64>,

    pub v49: Option<i64>,

    pub v50: Option<i64>,

    pub v51: Option<i64>,

    pub v52: Option<i64>,

    pub v53: Option<i64>,

    pub v54: Option<i64>,

    pub v55: Option<i64>,

    pub v56: Option<i64>,

    pub v57: Option<i64>,

    pub v58: Option<i64>,

    pub v59: Option<i64>,

    pub v60: Option<i64>,

    pub v61: Option<i64>,

    pub v62: Option<i64>,

    pub v63: Option<i64>,

    pub v64: Option<crate::ExtensionTable>,
}

impl SixtyFourOrdinalTable {
    fn __max_ordinal(&self) -> usize {
        if self.v1.is_some() {
            return 1;
        }

        if self.v2.is_some() {
            return 2;
        }

        if self.v3.is_some() {
            return 3;
        }

        if self.v4.is_some() {
            return 4;
        }

        if self.v5.is_some() {
            return 5;
        }

        if self.v6.is_some() {
            return 6;
        }

        if self.v7.is_some() {
            return 7;
        }

        if self.v8.is_some() {
            return 8;
        }

        if self.v9.is_some() {
            return 9;
        }

        if self.v10.is_some() {
            return 10;
        }

        if self.v11.is_some() {
            return 11;
        }

        if self.v12.is_some() {
            return 12;
        }

        if self.v13.is_some() {
            return 13;
        }

        if self.v14.is_some() {
            return 14;
        }

        if self.v15.is_some() {
            return 15;
        }

        if self.v16.is_some() {
            return 16;
        }

        if self.v17.is_some() {
            return 17;
        }

        if self.v18.is_some() {
            return 18;
        }

        if self.v19.is_some() {
            return 19;
        }

        if self.v20.is_some() {
            return 20;
        }

        if self.v21.is_some() {
            return 21;
        }

        if self.v22.is_some() {
            return 22;
        }

        if self.v23.is_some() {
            return 23;
        }

        if self.v24.is_some() {
            return 24;
        }

        if self.v25.is_some() {
            return 25;
        }

        if self.v26.is_some() {
            return 26;
        }

        if self.v27.is_some() {
            return 27;
        }

        if self.v28.is_some() {
            return 28;
        }

        if self.v29.is_some() {
            return 29;
        }

        if self.v30.is_some() {
            return 30;
        }

        if self.v31.is_some() {
            return 31;
        }

        if self.v32.is_some() {
            return 32;
        }

        if self.v33.is_some() {
            return 33;
        }

        if self.v34.is_some() {
            return 34;
        }

        if self.v35.is_some() {
            return 35;
        }

        if self.v36.is_some() {
            return 36;
        }

        if self.v37.is_some() {
            return 37;
        }

        if self.v38.is_some() {
            return 38;
        }

        if self.v39.is_some() {
            return 39;
        }

        if self.v40.is_some() {
            return 40;
        }

        if self.v41.is_some() {
            return 41;
        }

        if self.v42.is_some() {
            return 42;
        }

        if self.v43.is_some() {
            return 43;
        }

        if self.v44.is_some() {
            return 44;
        }

        if self.v45.is_some() {
            return 45;
        }

        if self.v46.is_some() {
            return 46;
        }

        if self.v47.is_some() {
            return 47;
        }

        if self.v48.is_some() {
            return 48;
        }

        if self.v49.is_some() {
            return 49;
        }

        if self.v50.is_some() {
            return 50;
        }

        if self.v51.is_some() {
            return 51;
        }

        if self.v52.is_some() {
            return 52;
        }

        if self.v53.is_some() {
            return 53;
        }

        if self.v54.is_some() {
            return 54;
        }

        if self.v55.is_some() {
            return 55;
        }

        if self.v56.is_some() {
            return 56;
        }

        if self.v57.is_some() {
            return 57;
        }

        if self.v58.is_some() {
            return 58;
        }

        if self.v59.is_some() {
            return 59;
        }

        if self.v60.is_some() {
            return 60;
        }

        if self.v61.is_some() {
            return 61;
        }

        if self.v62.is_some() {
            return 62;
        }

        if self.v63.is_some() {
            return 63;
        }

        if self.v64.is_some() {
            return 64;
        }

        0
    }
}

impl ::fidl_next::Encodable for SixtyFourOrdinalTable {
    type Encoded = WireSixtyFourOrdinalTable;
}

impl<___E> ::fidl_next::Encode<___E> for SixtyFourOrdinalTable
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireSixtyFourOrdinalTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                64 => {
                    if let Some(v64) = &mut self.v64 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v64,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                63 => {
                    if let Some(v63) = &mut self.v63 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v63,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                62 => {
                    if let Some(v62) = &mut self.v62 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v62,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                61 => {
                    if let Some(v61) = &mut self.v61 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v61,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                60 => {
                    if let Some(v60) = &mut self.v60 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v60,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                59 => {
                    if let Some(v59) = &mut self.v59 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v59,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                58 => {
                    if let Some(v58) = &mut self.v58 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v58,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                57 => {
                    if let Some(v57) = &mut self.v57 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v57,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                56 => {
                    if let Some(v56) = &mut self.v56 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v56,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                55 => {
                    if let Some(v55) = &mut self.v55 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v55,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                54 => {
                    if let Some(v54) = &mut self.v54 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v54,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                53 => {
                    if let Some(v53) = &mut self.v53 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v53,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                52 => {
                    if let Some(v52) = &mut self.v52 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v52,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                51 => {
                    if let Some(v51) = &mut self.v51 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v51,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                50 => {
                    if let Some(v50) = &mut self.v50 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v50,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                49 => {
                    if let Some(v49) = &mut self.v49 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v49,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                48 => {
                    if let Some(v48) = &mut self.v48 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v48,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                47 => {
                    if let Some(v47) = &mut self.v47 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v47,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                46 => {
                    if let Some(v46) = &mut self.v46 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v46,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                45 => {
                    if let Some(v45) = &mut self.v45 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v45,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                44 => {
                    if let Some(v44) = &mut self.v44 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v44,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                43 => {
                    if let Some(v43) = &mut self.v43 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v43,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                42 => {
                    if let Some(v42) = &mut self.v42 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v42,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                41 => {
                    if let Some(v41) = &mut self.v41 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v41,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                40 => {
                    if let Some(v40) = &mut self.v40 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v40,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                39 => {
                    if let Some(v39) = &mut self.v39 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v39,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                38 => {
                    if let Some(v38) = &mut self.v38 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v38,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                37 => {
                    if let Some(v37) = &mut self.v37 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v37,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                36 => {
                    if let Some(v36) = &mut self.v36 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v36,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                35 => {
                    if let Some(v35) = &mut self.v35 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v35,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                34 => {
                    if let Some(v34) = &mut self.v34 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v34,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                33 => {
                    if let Some(v33) = &mut self.v33 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v33,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                32 => {
                    if let Some(v32) = &mut self.v32 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v32,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                31 => {
                    if let Some(v31) = &mut self.v31 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v31,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                30 => {
                    if let Some(v30) = &mut self.v30 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v30,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                29 => {
                    if let Some(v29) = &mut self.v29 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v29,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                28 => {
                    if let Some(v28) = &mut self.v28 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v28,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                27 => {
                    if let Some(v27) = &mut self.v27 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v27,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                26 => {
                    if let Some(v26) = &mut self.v26 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v26,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                25 => {
                    if let Some(v25) = &mut self.v25 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v25,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                24 => {
                    if let Some(v24) = &mut self.v24 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v24,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                23 => {
                    if let Some(v23) = &mut self.v23 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v23,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                22 => {
                    if let Some(v22) = &mut self.v22 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v22,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                21 => {
                    if let Some(v21) = &mut self.v21 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v21,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                20 => {
                    if let Some(v20) = &mut self.v20 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v20,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                19 => {
                    if let Some(v19) = &mut self.v19 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v19,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                18 => {
                    if let Some(v18) = &mut self.v18 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v18,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                17 => {
                    if let Some(v17) = &mut self.v17 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v17,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                16 => {
                    if let Some(v16) = &mut self.v16 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v16,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                15 => {
                    if let Some(v15) = &mut self.v15 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v15,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                14 => {
                    if let Some(v14) = &mut self.v14 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v14,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                13 => {
                    if let Some(v13) = &mut self.v13 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v13,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                12 => {
                    if let Some(v12) = &mut self.v12 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v12,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                11 => {
                    if let Some(v11) = &mut self.v11 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v11,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                10 => {
                    if let Some(v10) = &mut self.v10 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v10,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                9 => {
                    if let Some(v9) = &mut self.v9 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v9,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                8 => {
                    if let Some(v8) = &mut self.v8 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v8,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                7 => {
                    if let Some(v7) = &mut self.v7 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v7,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                6 => {
                    if let Some(v6) = &mut self.v6 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v6,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                5 => {
                    if let Some(v5) = &mut self.v5 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v5,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                4 => {
                    if let Some(v4) = &mut self.v4 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v4,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                3 => {
                    if let Some(v3) = &mut self.v3 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v3,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                2 => {
                    if let Some(v2) = &mut self.v2 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v2,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                1 => {
                    if let Some(v1) = &mut self.v1 {
                        ::fidl_next::WireEnvelope::encode_value(
                            v1,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSixtyFourOrdinalTable> for SixtyFourOrdinalTable {
    fn take_from(from: &WireSixtyFourOrdinalTable) -> Self {
        Self {
            v1: from.v1().map(::fidl_next::TakeFrom::take_from),

            v2: from.v2().map(::fidl_next::TakeFrom::take_from),

            v3: from.v3().map(::fidl_next::TakeFrom::take_from),

            v4: from.v4().map(::fidl_next::TakeFrom::take_from),

            v5: from.v5().map(::fidl_next::TakeFrom::take_from),

            v6: from.v6().map(::fidl_next::TakeFrom::take_from),

            v7: from.v7().map(::fidl_next::TakeFrom::take_from),

            v8: from.v8().map(::fidl_next::TakeFrom::take_from),

            v9: from.v9().map(::fidl_next::TakeFrom::take_from),

            v10: from.v10().map(::fidl_next::TakeFrom::take_from),

            v11: from.v11().map(::fidl_next::TakeFrom::take_from),

            v12: from.v12().map(::fidl_next::TakeFrom::take_from),

            v13: from.v13().map(::fidl_next::TakeFrom::take_from),

            v14: from.v14().map(::fidl_next::TakeFrom::take_from),

            v15: from.v15().map(::fidl_next::TakeFrom::take_from),

            v16: from.v16().map(::fidl_next::TakeFrom::take_from),

            v17: from.v17().map(::fidl_next::TakeFrom::take_from),

            v18: from.v18().map(::fidl_next::TakeFrom::take_from),

            v19: from.v19().map(::fidl_next::TakeFrom::take_from),

            v20: from.v20().map(::fidl_next::TakeFrom::take_from),

            v21: from.v21().map(::fidl_next::TakeFrom::take_from),

            v22: from.v22().map(::fidl_next::TakeFrom::take_from),

            v23: from.v23().map(::fidl_next::TakeFrom::take_from),

            v24: from.v24().map(::fidl_next::TakeFrom::take_from),

            v25: from.v25().map(::fidl_next::TakeFrom::take_from),

            v26: from.v26().map(::fidl_next::TakeFrom::take_from),

            v27: from.v27().map(::fidl_next::TakeFrom::take_from),

            v28: from.v28().map(::fidl_next::TakeFrom::take_from),

            v29: from.v29().map(::fidl_next::TakeFrom::take_from),

            v30: from.v30().map(::fidl_next::TakeFrom::take_from),

            v31: from.v31().map(::fidl_next::TakeFrom::take_from),

            v32: from.v32().map(::fidl_next::TakeFrom::take_from),

            v33: from.v33().map(::fidl_next::TakeFrom::take_from),

            v34: from.v34().map(::fidl_next::TakeFrom::take_from),

            v35: from.v35().map(::fidl_next::TakeFrom::take_from),

            v36: from.v36().map(::fidl_next::TakeFrom::take_from),

            v37: from.v37().map(::fidl_next::TakeFrom::take_from),

            v38: from.v38().map(::fidl_next::TakeFrom::take_from),

            v39: from.v39().map(::fidl_next::TakeFrom::take_from),

            v40: from.v40().map(::fidl_next::TakeFrom::take_from),

            v41: from.v41().map(::fidl_next::TakeFrom::take_from),

            v42: from.v42().map(::fidl_next::TakeFrom::take_from),

            v43: from.v43().map(::fidl_next::TakeFrom::take_from),

            v44: from.v44().map(::fidl_next::TakeFrom::take_from),

            v45: from.v45().map(::fidl_next::TakeFrom::take_from),

            v46: from.v46().map(::fidl_next::TakeFrom::take_from),

            v47: from.v47().map(::fidl_next::TakeFrom::take_from),

            v48: from.v48().map(::fidl_next::TakeFrom::take_from),

            v49: from.v49().map(::fidl_next::TakeFrom::take_from),

            v50: from.v50().map(::fidl_next::TakeFrom::take_from),

            v51: from.v51().map(::fidl_next::TakeFrom::take_from),

            v52: from.v52().map(::fidl_next::TakeFrom::take_from),

            v53: from.v53().map(::fidl_next::TakeFrom::take_from),

            v54: from.v54().map(::fidl_next::TakeFrom::take_from),

            v55: from.v55().map(::fidl_next::TakeFrom::take_from),

            v56: from.v56().map(::fidl_next::TakeFrom::take_from),

            v57: from.v57().map(::fidl_next::TakeFrom::take_from),

            v58: from.v58().map(::fidl_next::TakeFrom::take_from),

            v59: from.v59().map(::fidl_next::TakeFrom::take_from),

            v60: from.v60().map(::fidl_next::TakeFrom::take_from),

            v61: from.v61().map(::fidl_next::TakeFrom::take_from),

            v62: from.v62().map(::fidl_next::TakeFrom::take_from),

            v63: from.v63().map(::fidl_next::TakeFrom::take_from),

            v64: from.v64().map(::fidl_next::TakeFrom::take_from),
        }
    }
}

/// The wire type corresponding to [`SixtyFourOrdinalTable`].
#[repr(C)]
pub struct WireSixtyFourOrdinalTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireSixtyFourOrdinalTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                2 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                3 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                4 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                5 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                6 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                7 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                8 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                9 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                10 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                11 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                12 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                13 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                14 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                15 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                16 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                17 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                18 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                19 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                20 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                21 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                22 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                23 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                24 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                25 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                26 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                27 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                28 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                29 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                30 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                31 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                32 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                33 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                34 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                35 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                36 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                37 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                38 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                39 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                40 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                41 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                42 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                43 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                44 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                45 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                46 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                47 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                48 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                49 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                50 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                51 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                52 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                53 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                54 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                55 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                56 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                57 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                58 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                59 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                60 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                61 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                62 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                63 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                64 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, crate::WireExtensionTable>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireSixtyFourOrdinalTable {
    pub fn v1(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }

    pub fn v2(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(2)?.deref_unchecked()) }
    }

    pub fn v3(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(3)?.deref_unchecked()) }
    }

    pub fn v4(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(4)?.deref_unchecked()) }
    }

    pub fn v5(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(5)?.deref_unchecked()) }
    }

    pub fn v6(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(6)?.deref_unchecked()) }
    }

    pub fn v7(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(7)?.deref_unchecked()) }
    }

    pub fn v8(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(8)?.deref_unchecked()) }
    }

    pub fn v9(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(9)?.deref_unchecked()) }
    }

    pub fn v10(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(10)?.deref_unchecked()) }
    }

    pub fn v11(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(11)?.deref_unchecked()) }
    }

    pub fn v12(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(12)?.deref_unchecked()) }
    }

    pub fn v13(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(13)?.deref_unchecked()) }
    }

    pub fn v14(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(14)?.deref_unchecked()) }
    }

    pub fn v15(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(15)?.deref_unchecked()) }
    }

    pub fn v16(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(16)?.deref_unchecked()) }
    }

    pub fn v17(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(17)?.deref_unchecked()) }
    }

    pub fn v18(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(18)?.deref_unchecked()) }
    }

    pub fn v19(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(19)?.deref_unchecked()) }
    }

    pub fn v20(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(20)?.deref_unchecked()) }
    }

    pub fn v21(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(21)?.deref_unchecked()) }
    }

    pub fn v22(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(22)?.deref_unchecked()) }
    }

    pub fn v23(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(23)?.deref_unchecked()) }
    }

    pub fn v24(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(24)?.deref_unchecked()) }
    }

    pub fn v25(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(25)?.deref_unchecked()) }
    }

    pub fn v26(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(26)?.deref_unchecked()) }
    }

    pub fn v27(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(27)?.deref_unchecked()) }
    }

    pub fn v28(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(28)?.deref_unchecked()) }
    }

    pub fn v29(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(29)?.deref_unchecked()) }
    }

    pub fn v30(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(30)?.deref_unchecked()) }
    }

    pub fn v31(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(31)?.deref_unchecked()) }
    }

    pub fn v32(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(32)?.deref_unchecked()) }
    }

    pub fn v33(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(33)?.deref_unchecked()) }
    }

    pub fn v34(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(34)?.deref_unchecked()) }
    }

    pub fn v35(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(35)?.deref_unchecked()) }
    }

    pub fn v36(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(36)?.deref_unchecked()) }
    }

    pub fn v37(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(37)?.deref_unchecked()) }
    }

    pub fn v38(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(38)?.deref_unchecked()) }
    }

    pub fn v39(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(39)?.deref_unchecked()) }
    }

    pub fn v40(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(40)?.deref_unchecked()) }
    }

    pub fn v41(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(41)?.deref_unchecked()) }
    }

    pub fn v42(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(42)?.deref_unchecked()) }
    }

    pub fn v43(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(43)?.deref_unchecked()) }
    }

    pub fn v44(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(44)?.deref_unchecked()) }
    }

    pub fn v45(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(45)?.deref_unchecked()) }
    }

    pub fn v46(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(46)?.deref_unchecked()) }
    }

    pub fn v47(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(47)?.deref_unchecked()) }
    }

    pub fn v48(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(48)?.deref_unchecked()) }
    }

    pub fn v49(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(49)?.deref_unchecked()) }
    }

    pub fn v50(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(50)?.deref_unchecked()) }
    }

    pub fn v51(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(51)?.deref_unchecked()) }
    }

    pub fn v52(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(52)?.deref_unchecked()) }
    }

    pub fn v53(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(53)?.deref_unchecked()) }
    }

    pub fn v54(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(54)?.deref_unchecked()) }
    }

    pub fn v55(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(55)?.deref_unchecked()) }
    }

    pub fn v56(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(56)?.deref_unchecked()) }
    }

    pub fn v57(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(57)?.deref_unchecked()) }
    }

    pub fn v58(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(58)?.deref_unchecked()) }
    }

    pub fn v59(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(59)?.deref_unchecked()) }
    }

    pub fn v60(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(60)?.deref_unchecked()) }
    }

    pub fn v61(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(61)?.deref_unchecked()) }
    }

    pub fn v62(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(62)?.deref_unchecked()) }
    }

    pub fn v63(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(63)?.deref_unchecked()) }
    }

    pub fn v64(&self) -> Option<&crate::WireExtensionTable> {
        unsafe { Some(self.table.get(64)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireSixtyFourOrdinalTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("SixtyFourOrdinalTable")
            .field("v1", &self.v1())
            .field("v2", &self.v2())
            .field("v3", &self.v3())
            .field("v4", &self.v4())
            .field("v5", &self.v5())
            .field("v6", &self.v6())
            .field("v7", &self.v7())
            .field("v8", &self.v8())
            .field("v9", &self.v9())
            .field("v10", &self.v10())
            .field("v11", &self.v11())
            .field("v12", &self.v12())
            .field("v13", &self.v13())
            .field("v14", &self.v14())
            .field("v15", &self.v15())
            .field("v16", &self.v16())
            .field("v17", &self.v17())
            .field("v18", &self.v18())
            .field("v19", &self.v19())
            .field("v20", &self.v20())
            .field("v21", &self.v21())
            .field("v22", &self.v22())
            .field("v23", &self.v23())
            .field("v24", &self.v24())
            .field("v25", &self.v25())
            .field("v26", &self.v26())
            .field("v27", &self.v27())
            .field("v28", &self.v28())
            .field("v29", &self.v29())
            .field("v30", &self.v30())
            .field("v31", &self.v31())
            .field("v32", &self.v32())
            .field("v33", &self.v33())
            .field("v34", &self.v34())
            .field("v35", &self.v35())
            .field("v36", &self.v36())
            .field("v37", &self.v37())
            .field("v38", &self.v38())
            .field("v39", &self.v39())
            .field("v40", &self.v40())
            .field("v41", &self.v41())
            .field("v42", &self.v42())
            .field("v43", &self.v43())
            .field("v44", &self.v44())
            .field("v45", &self.v45())
            .field("v46", &self.v46())
            .field("v47", &self.v47())
            .field("v48", &self.v48())
            .field("v49", &self.v49())
            .field("v50", &self.v50())
            .field("v51", &self.v51())
            .field("v52", &self.v52())
            .field("v53", &self.v53())
            .field("v54", &self.v54())
            .field("v55", &self.v55())
            .field("v56", &self.v56())
            .field("v57", &self.v57())
            .field("v58", &self.v58())
            .field("v59", &self.v59())
            .field("v60", &self.v60())
            .field("v61", &self.v61())
            .field("v62", &self.v62())
            .field("v63", &self.v63())
            .field("v64", &self.v64())
            .finish()
    }
}

#[derive(Clone, Debug)]
pub struct TableWithAttributes {
    pub x: Option<i64>,
}

impl TableWithAttributes {
    fn __max_ordinal(&self) -> usize {
        if self.x.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for TableWithAttributes {
    type Encoded = WireTableWithAttributes;
}

impl<___E> ::fidl_next::Encode<___E> for TableWithAttributes
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTableWithAttributes { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                1 => {
                    if let Some(x) = &mut self.x {
                        ::fidl_next::WireEnvelope::encode_value(
                            x,
                            preallocated.encoder,
                            slot.as_mut(),
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(slot.as_mut())
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTableWithAttributes> for TableWithAttributes {
    fn take_from(from: &WireTableWithAttributes) -> Self {
        Self { x: from.x().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`TableWithAttributes`].
#[repr(C)]
pub struct WireTableWithAttributes {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireTableWithAttributes
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::i64_le>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireTableWithAttributes {
    pub fn x(&self) -> Option<&::fidl_next::i64_le> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireTableWithAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("TableWithAttributes").field("x", &self.x()).finish()
    }
}
