// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],

    pub array_uint16: [u16; 5],

    pub array_uint32: [u32; 5],

    pub array_uint64: [u64; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [i16; 5],

    pub array_int32: [i32; 5],

    pub array_int64: [i64; 5],

    pub array_float32: [f32; 5],

    pub array_float64: [f64; 5],

    pub array_string: [String; 5],

    pub array_opt_string: [Option<String>; 5],
}

impl ::fidl_next::Encodable for ArrayBasic {
    type Encoded = WireArrayBasic<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(self.array_uint8, encoder, array_uint8)?;

        ::fidl_next::Encode::encode(self.array_uint16, encoder, array_uint16)?;

        ::fidl_next::Encode::encode(self.array_uint32, encoder, array_uint32)?;

        ::fidl_next::Encode::encode(self.array_uint64, encoder, array_uint64)?;

        ::fidl_next::Encode::encode(self.array_int8, encoder, array_int8)?;

        ::fidl_next::Encode::encode(self.array_int16, encoder, array_int16)?;

        ::fidl_next::Encode::encode(self.array_int32, encoder, array_int32)?;

        ::fidl_next::Encode::encode(self.array_int64, encoder, array_int64)?;

        ::fidl_next::Encode::encode(self.array_float32, encoder, array_float32)?;

        ::fidl_next::Encode::encode(self.array_float64, encoder, array_float64)?;

        ::fidl_next::Encode::encode(self.array_string, encoder, array_string)?;

        ::fidl_next::Encode::encode(self.array_opt_string, encoder, array_opt_string)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ArrayBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.array_uint8, encoder, array_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_uint16, encoder, array_uint16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_uint32, encoder, array_uint32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_uint64, encoder, array_uint64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_int8, encoder, array_int8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_int16, encoder, array_int16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_int32, encoder, array_int32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_int64, encoder, array_int64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_float32, encoder, array_float32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_float64, encoder, array_float64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_string, encoder, array_string)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_opt_string, encoder, array_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ArrayBasic {
    type EncodedOption = ::fidl_next::WireBox<'static, WireArrayBasic<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ArrayBasic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayBasic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ArrayBasic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayBasic: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireArrayBasic<'de>> for ArrayBasic {
    #[inline]
    fn from_wire(wire: WireArrayBasic<'de>) -> Self {
        Self {
            array_uint8: ::fidl_next::FromWire::from_wire(wire.array_uint8),

            array_uint16: ::fidl_next::FromWire::from_wire(wire.array_uint16),

            array_uint32: ::fidl_next::FromWire::from_wire(wire.array_uint32),

            array_uint64: ::fidl_next::FromWire::from_wire(wire.array_uint64),

            array_int8: ::fidl_next::FromWire::from_wire(wire.array_int8),

            array_int16: ::fidl_next::FromWire::from_wire(wire.array_int16),

            array_int32: ::fidl_next::FromWire::from_wire(wire.array_int32),

            array_int64: ::fidl_next::FromWire::from_wire(wire.array_int64),

            array_float32: ::fidl_next::FromWire::from_wire(wire.array_float32),

            array_float64: ::fidl_next::FromWire::from_wire(wire.array_float64),

            array_string: ::fidl_next::FromWire::from_wire(wire.array_string),

            array_opt_string: ::fidl_next::FromWire::from_wire(wire.array_opt_string),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireArrayBasic<'de>> for ArrayBasic {
    #[inline]
    fn from_wire_ref(wire: &WireArrayBasic<'de>) -> Self {
        Self {
            array_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_uint8),

            array_uint16: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_uint16),

            array_uint32: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_uint32),

            array_uint64: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_uint64),

            array_int8: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_int8),

            array_int16: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_int16),

            array_int32: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_int32),

            array_int64: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_int64),

            array_float32: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_float32),

            array_float64: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_float64),

            array_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_string),

            array_opt_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_opt_string),
        }
    }
}

/// The wire type corresponding to [`ArrayBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayBasic<'de> {
    pub array_uint8: [u8; 5],

    pub array_uint16: [::fidl_next::WireU16; 5],

    pub array_uint32: [::fidl_next::WireU32; 5],

    pub array_uint64: [::fidl_next::WireU64; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [::fidl_next::WireI16; 5],

    pub array_int32: [::fidl_next::WireI32; 5],

    pub array_int64: [::fidl_next::WireI64; 5],

    pub array_float32: [::fidl_next::WireF32; 5],

    pub array_float64: [::fidl_next::WireF64; 5],

    pub array_string: [::fidl_next::WireString<'de>; 5],

    pub array_opt_string: [::fidl_next::WireOptionalString<'de>; 5],
}

unsafe impl ::fidl_next::Wire for WireArrayBasic<'static> {
    type Decoded<'de> = WireArrayBasic<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(180).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(116).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(85).write_bytes(0, 1);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(36).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayBasic<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_uint8,
                mut array_uint16,
                mut array_uint32,
                mut array_uint64,
                mut array_int8,
                mut array_int16,
                mut array_int32,
                mut array_int64,
                mut array_float32,
                mut array_float64,
                mut array_string,
                mut array_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Bits: u32 {
        const VAL = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Bits {
    type Encoded = WireBits;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBits { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBits> for Bits {
    fn from(wire: WireBits) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::FromWire<WireBits> for Bits {
    #[inline]
    fn from_wire(wire: WireBits) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireBits> for Bits {
    #[inline]
    fn from_wire_ref(wire: &WireBits) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`Bits`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBits {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireBits {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBits
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Bits> for WireBits {
    fn from(natural: Bits) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Enum {
    Val = 1,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for Enum {
    type Encoded = WireEnum;
}
impl ::std::convert::From<u32> for Enum {
    fn from(value: u32) -> Self {
        match value {
            1 => Self::Val,

            _ => Self::UnknownOrdinal_(value),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::EncodeRef::encode_ref(&self, encoder, out)
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::Val => 1,

            Self::UnknownOrdinal_(value) => value,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnum> for Enum {
    fn from(wire: WireEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::Val,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::FromWire<WireEnum> for Enum {
    #[inline]
    fn from_wire(wire: WireEnum) -> Self {
        Self::from(wire)
    }
}

impl ::fidl_next::FromWireRef<WireEnum> for Enum {
    #[inline]
    fn from_wire_ref(wire: &WireEnum) -> Self {
        Self::from(*wire)
    }
}

/// The wire type corresponding to [`Enum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireEnum {
    type Decoded<'de> = Self;

    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnum {
    pub const VAL: WireEnum = WireEnum { value: ::fidl_next::WireU32(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Enum> for WireEnum {
    fn from(natural: Enum) -> Self {
        match natural {
            Enum::Val => WireEnum::VAL,

            Enum::UnknownOrdinal_(value) => WireEnum { value: ::fidl_next::WireU32::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct Struct {}

impl ::fidl_next::Encodable for Struct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireStruct> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Struct {
    type EncodedOption = ::fidl_next::WireBox<'static, WireStruct>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Struct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Struct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireStruct> for Struct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireStruct, Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn from_wire(wire: WireStruct) -> Self {
        Self {}
    }
}

impl ::fidl_next::FromWireRef<WireStruct> for Struct {
    #[inline]
    fn from_wire_ref(wire: &WireStruct) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Struct`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireStruct {}

unsafe impl ::fidl_next::Wire for WireStruct {
    type Decoded<'de> = WireStruct;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct Table {}

impl Table {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for Table {
    type Encoded = WireTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Table
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Table
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireTable<'de>> for Table {
    #[inline]
    fn from_wire(wire: WireTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        Self {}
    }
}

impl<'de> ::fidl_next::FromWireRef<WireTable<'de>> for Table {
    #[inline]
    fn from_wire_ref(wire: &WireTable<'de>) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Table`].
#[repr(C)]
pub struct WireTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireTable<'de> {
    fn drop(&mut self) {}
}

unsafe impl ::fidl_next::Wire for WireTable<'static> {
    type Decoded<'de> = WireTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireTable<'de> {}

impl<'de> ::core::fmt::Debug for WireTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("Table").finish()
    }
}

#[derive(Clone, Debug)]
pub enum Union {
    B(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for Union {
    type Encoded = WireUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw, _phantom: _ } = out);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw, _phantom: _ } = out);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Union {
    type EncodedOption = WireOptionalUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Union
where
    ___E: ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Union
where
    ___E: ?Sized,
    Union: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnion> for Union {
    #[inline]
    fn from_wire(wire: WireUnion) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::B(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnion> for Union {
    #[inline]
    fn from_wire_ref(wire: &WireUnion) -> Self {
        match wire.raw.ordinal() {
            1 => Self::B(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnion> for Box<Union> {
    #[inline]
    fn from_wire_option(wire: WireOptionalUnion) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalUnion> for Box<Union> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalUnion) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnion {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<bool>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnion {
    type Decoded<'de> = WireUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union {
    pub enum Ref<'de> {
        B(&'de bool),

        UnknownOrdinal_(u64),
    }
}

impl WireUnion {
    pub fn as_ref(&self) -> crate::union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union::Ref::B(unsafe { self.raw.get().deref_unchecked::<bool>() }),

            unknown => crate::union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnion {
    type Decoded<'de> = WireOptionalUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnion> {
        if self.is_some() {
            Some(WireUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnion {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<bool>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct ArrayCompound {
    pub array_bits: [crate::Bits; 5],

    pub array_enum: [crate::Enum; 5],

    pub array_struct: [crate::Struct; 5],

    pub array_table: [crate::Table; 5],

    pub array_union: [crate::Union; 5],

    pub array_opt_struct: [Option<Box<crate::Struct>>; 5],

    pub array_opt_union: [Option<Box<crate::Union>>; 5],
}

impl ::fidl_next::Encodable for ArrayCompound {
    type Encoded = WireArrayCompound<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.array_bits, encoder, array_bits)?;

        ::fidl_next::Encode::encode(self.array_enum, encoder, array_enum)?;

        ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(self.array_opt_struct, encoder, array_opt_struct)?;

        ::fidl_next::Encode::encode(self.array_opt_union, encoder, array_opt_union)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ArrayCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.array_bits, encoder, array_bits)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_enum, encoder, array_enum)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_struct, encoder, array_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_table, encoder, array_table)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_union, encoder, array_union)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_opt_struct, encoder, array_opt_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_opt_union, encoder, array_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ArrayCompound {
    type EncodedOption = ::fidl_next::WireBox<'static, WireArrayCompound<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ArrayCompound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayCompound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ArrayCompound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayCompound: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireArrayCompound<'de>> for ArrayCompound {
    #[inline]
    fn from_wire(wire: WireArrayCompound<'de>) -> Self {
        Self {
            array_bits: ::fidl_next::FromWire::from_wire(wire.array_bits),

            array_enum: ::fidl_next::FromWire::from_wire(wire.array_enum),

            array_struct: ::fidl_next::FromWire::from_wire(wire.array_struct),

            array_table: ::fidl_next::FromWire::from_wire(wire.array_table),

            array_union: ::fidl_next::FromWire::from_wire(wire.array_union),

            array_opt_struct: ::fidl_next::FromWire::from_wire(wire.array_opt_struct),

            array_opt_union: ::fidl_next::FromWire::from_wire(wire.array_opt_union),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireArrayCompound<'de>> for ArrayCompound {
    #[inline]
    fn from_wire_ref(wire: &WireArrayCompound<'de>) -> Self {
        Self {
            array_bits: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_bits),

            array_enum: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_enum),

            array_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_struct),

            array_table: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_table),

            array_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_union),

            array_opt_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_opt_struct),

            array_opt_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_opt_union),
        }
    }
}

/// The wire type corresponding to [`ArrayCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayCompound<'de> {
    pub array_bits: [crate::WireBits; 5],

    pub array_enum: [crate::WireEnum; 5],

    pub array_struct: [crate::WireStruct; 5],

    pub array_table: [crate::WireTable<'de>; 5],

    pub array_union: [crate::WireUnion; 5],

    pub array_opt_struct: [::fidl_next::WireBox<'de, crate::WireStruct>; 5],

    pub array_opt_union: [crate::WireOptionalUnion; 5],
}

unsafe impl ::fidl_next::Wire for WireArrayCompound<'static> {
    type Decoded<'de> = WireArrayCompound<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(45).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayCompound<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_bits,
                mut array_enum,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut array_opt_struct,
                mut array_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ArrayVectorNested {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [Vec<u8>; 5],

    pub vector_array_uint8: Vec<[u8; 5]>,

    pub vector_vector_uint8: Vec<Vec<u8>>,
}

impl ::fidl_next::Encodable for ArrayVectorNested {
    type Encoded = WireArrayVectorNested<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,

            } = out;
        }

        ::fidl_next::Encode::encode(self.array_array_uint8, encoder, array_array_uint8)?;

        ::fidl_next::Encode::encode(self.array_vector_uint8, encoder, array_vector_uint8)?;

        ::fidl_next::Encode::encode(self.vector_array_uint8, encoder, vector_array_uint8)?;

        ::fidl_next::Encode::encode(self.vector_vector_uint8, encoder, vector_vector_uint8)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.array_array_uint8, encoder, array_array_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.array_vector_uint8, encoder, array_vector_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_array_uint8, encoder, vector_array_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.vector_vector_uint8,
            encoder,
            vector_vector_uint8,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ArrayVectorNested {
    type EncodedOption = ::fidl_next::WireBox<'static, WireArrayVectorNested<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayVectorNested: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayVectorNested: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireArrayVectorNested<'de>> for ArrayVectorNested {
    #[inline]
    fn from_wire(wire: WireArrayVectorNested<'de>) -> Self {
        Self {
            array_array_uint8: ::fidl_next::FromWire::from_wire(wire.array_array_uint8),

            array_vector_uint8: ::fidl_next::FromWire::from_wire(wire.array_vector_uint8),

            vector_array_uint8: ::fidl_next::FromWire::from_wire(wire.vector_array_uint8),

            vector_vector_uint8: ::fidl_next::FromWire::from_wire(wire.vector_vector_uint8),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireArrayVectorNested<'de>> for ArrayVectorNested {
    #[inline]
    fn from_wire_ref(wire: &WireArrayVectorNested<'de>) -> Self {
        Self {
            array_array_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_array_uint8),

            array_vector_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.array_vector_uint8),

            vector_array_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_array_uint8),

            vector_vector_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_vector_uint8),
        }
    }
}

/// The wire type corresponding to [`ArrayVectorNested`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayVectorNested<'de> {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [::fidl_next::WireVector<'de, u8>; 5],

    pub vector_array_uint8: ::fidl_next::WireVector<'de, [u8; 5]>,

    pub vector_vector_uint8: ::fidl_next::WireVector<'de, ::fidl_next::WireVector<'de, u8>>,
}

unsafe impl ::fidl_next::Wire for WireArrayVectorNested<'static> {
    type Decoded<'de> = WireArrayVectorNested<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(25).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayVectorNested<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_array_uint8,
                mut array_vector_uint8,
                mut vector_array_uint8,
                mut vector_vector_uint8,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vector_uint8.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Basic {
    pub uint8: u8,

    pub uint16: u16,

    pub uint32: u32,

    pub uint64: u64,

    pub int8: i8,

    pub int16: i16,

    pub int32: i32,

    pub int64: i64,

    pub float32: f32,

    pub float64: f64,

    pub string: String,

    pub opt_string: Option<String>,
}

impl ::fidl_next::Encodable for Basic {
    type Encoded = WireBasic<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Basic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(self.uint8, encoder, uint8)?;

        ::fidl_next::Encode::encode(self.uint16, encoder, uint16)?;

        ::fidl_next::Encode::encode(self.uint32, encoder, uint32)?;

        ::fidl_next::Encode::encode(self.uint64, encoder, uint64)?;

        ::fidl_next::Encode::encode(self.int8, encoder, int8)?;

        ::fidl_next::Encode::encode(self.int16, encoder, int16)?;

        ::fidl_next::Encode::encode(self.int32, encoder, int32)?;

        ::fidl_next::Encode::encode(self.int64, encoder, int64)?;

        ::fidl_next::Encode::encode(self.float32, encoder, float32)?;

        ::fidl_next::Encode::encode(self.float64, encoder, float64)?;

        ::fidl_next::Encode::encode(self.string, encoder, string)?;

        ::fidl_next::Encode::encode(self.opt_string, encoder, opt_string)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Basic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.uint8, encoder, uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.uint16, encoder, uint16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.uint32, encoder, uint32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.uint64, encoder, uint64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.int8, encoder, int8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.int16, encoder, int16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.int32, encoder, int32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.int64, encoder, int64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.float32, encoder, float32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.float64, encoder, float64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.string, encoder, string)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_string, encoder, opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Basic {
    type EncodedOption = ::fidl_next::WireBox<'static, WireBasic<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Basic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Basic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Basic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Basic: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireBasic<'de>> for Basic {
    #[inline]
    fn from_wire(wire: WireBasic<'de>) -> Self {
        Self {
            uint8: ::fidl_next::FromWire::from_wire(wire.uint8),

            uint16: ::fidl_next::FromWire::from_wire(wire.uint16),

            uint32: ::fidl_next::FromWire::from_wire(wire.uint32),

            uint64: ::fidl_next::FromWire::from_wire(wire.uint64),

            int8: ::fidl_next::FromWire::from_wire(wire.int8),

            int16: ::fidl_next::FromWire::from_wire(wire.int16),

            int32: ::fidl_next::FromWire::from_wire(wire.int32),

            int64: ::fidl_next::FromWire::from_wire(wire.int64),

            float32: ::fidl_next::FromWire::from_wire(wire.float32),

            float64: ::fidl_next::FromWire::from_wire(wire.float64),

            string: ::fidl_next::FromWire::from_wire(wire.string),

            opt_string: ::fidl_next::FromWire::from_wire(wire.opt_string),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireBasic<'de>> for Basic {
    #[inline]
    fn from_wire_ref(wire: &WireBasic<'de>) -> Self {
        Self {
            uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.uint8),

            uint16: ::fidl_next::FromWireRef::from_wire_ref(&wire.uint16),

            uint32: ::fidl_next::FromWireRef::from_wire_ref(&wire.uint32),

            uint64: ::fidl_next::FromWireRef::from_wire_ref(&wire.uint64),

            int8: ::fidl_next::FromWireRef::from_wire_ref(&wire.int8),

            int16: ::fidl_next::FromWireRef::from_wire_ref(&wire.int16),

            int32: ::fidl_next::FromWireRef::from_wire_ref(&wire.int32),

            int64: ::fidl_next::FromWireRef::from_wire_ref(&wire.int64),

            float32: ::fidl_next::FromWireRef::from_wire_ref(&wire.float32),

            float64: ::fidl_next::FromWireRef::from_wire_ref(&wire.float64),

            string: ::fidl_next::FromWireRef::from_wire_ref(&wire.string),

            opt_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_string),
        }
    }
}

/// The wire type corresponding to [`Basic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireBasic<'de> {
    pub uint8: u8,

    pub uint16: ::fidl_next::WireU16,

    pub uint32: ::fidl_next::WireU32,

    pub uint64: ::fidl_next::WireU64,

    pub int8: i8,

    pub int16: ::fidl_next::WireI16,

    pub int32: ::fidl_next::WireI32,

    pub int64: ::fidl_next::WireI64,

    pub float32: ::fidl_next::WireF32,

    pub float64: ::fidl_next::WireF64,

    pub string: ::fidl_next::WireString<'de>,

    pub opt_string: ::fidl_next::WireOptionalString<'de>,
}

unsafe impl ::fidl_next::Wire for WireBasic<'static> {
    type Decoded<'de> = WireBasic<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(36).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(17).write_bytes(0, 1);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBasic<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut uint8,
                mut uint16,
                mut uint32,
                mut uint64,
                mut int8,
                mut int16,
                mut int32,
                mut int64,
                mut float32,
                mut float64,
                mut string,
                mut opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Compound {
    pub bits: crate::Bits,

    pub enum_: crate::Enum,

    pub struct_: crate::Struct,

    pub table: crate::Table,

    pub union: crate::Union,

    pub opt_struct: Option<Box<crate::Struct>>,

    pub opt_union: Option<Box<crate::Union>>,
}

impl ::fidl_next::Encodable for Compound {
    type Encoded = WireCompound<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Compound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits,
                enum_,
                struct_,
                table,
                union,
                opt_struct,
                opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.bits, encoder, bits)?;

        ::fidl_next::Encode::encode(self.enum_, encoder, enum_)?;

        ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

        ::fidl_next::Encode::encode(self.table, encoder, table)?;

        ::fidl_next::Encode::encode(self.union, encoder, union)?;

        ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Compound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits,
                enum_,
                struct_,
                table,
                union,
                opt_struct,
                opt_union,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.bits, encoder, bits)?;

        ::fidl_next::EncodeRef::encode_ref(&self.enum_, encoder, enum_)?;

        ::fidl_next::EncodeRef::encode_ref(&self.struct_, encoder, struct_)?;

        ::fidl_next::EncodeRef::encode_ref(&self.table, encoder, table)?;

        ::fidl_next::EncodeRef::encode_ref(&self.union, encoder, union)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_union, encoder, opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Compound {
    type EncodedOption = ::fidl_next::WireBox<'static, WireCompound<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Compound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Compound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Compound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Compound: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireCompound<'de>> for Compound {
    #[inline]
    fn from_wire(wire: WireCompound<'de>) -> Self {
        Self {
            bits: ::fidl_next::FromWire::from_wire(wire.bits),

            enum_: ::fidl_next::FromWire::from_wire(wire.enum_),

            struct_: ::fidl_next::FromWire::from_wire(wire.struct_),

            table: ::fidl_next::FromWire::from_wire(wire.table),

            union: ::fidl_next::FromWire::from_wire(wire.union),

            opt_struct: ::fidl_next::FromWire::from_wire(wire.opt_struct),

            opt_union: ::fidl_next::FromWire::from_wire(wire.opt_union),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireCompound<'de>> for Compound {
    #[inline]
    fn from_wire_ref(wire: &WireCompound<'de>) -> Self {
        Self {
            bits: ::fidl_next::FromWireRef::from_wire_ref(&wire.bits),

            enum_: ::fidl_next::FromWireRef::from_wire_ref(&wire.enum_),

            struct_: ::fidl_next::FromWireRef::from_wire_ref(&wire.struct_),

            table: ::fidl_next::FromWireRef::from_wire_ref(&wire.table),

            union: ::fidl_next::FromWireRef::from_wire_ref(&wire.union),

            opt_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_struct),

            opt_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_union),
        }
    }
}

/// The wire type corresponding to [`Compound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireCompound<'de> {
    pub bits: crate::WireBits,

    pub enum_: crate::WireEnum,

    pub struct_: crate::WireStruct,

    pub table: crate::WireTable<'de>,

    pub union: crate::WireUnion,

    pub opt_struct: ::fidl_next::WireBox<'de, crate::WireStruct>,

    pub opt_union: crate::WireOptionalUnion,
}

unsafe impl ::fidl_next::Wire for WireCompound<'static> {
    type Decoded<'de> = WireCompound<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(9).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireCompound<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits,
                mut enum_,
                mut struct_,
                mut table,
                mut union,
                mut opt_struct,
                mut opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(enum_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(struct_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,

    pub vector_uint16: Vec<u16>,

    pub vector_uint32: Vec<u32>,

    pub vector_uint64: Vec<u64>,

    pub vector_int8: Vec<i8>,

    pub vector_int16: Vec<i16>,

    pub vector_int32: Vec<i32>,

    pub vector_int64: Vec<i64>,

    pub vector_float32: Vec<f32>,

    pub vector_float64: Vec<f64>,

    pub vector_string: Vec<String>,

    pub vector_opt_string: Vec<Option<String>>,
}

impl ::fidl_next::Encodable for VectorBasic {
    type Encoded = WireVectorBasic<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(self.vector_uint8, encoder, vector_uint8)?;

        ::fidl_next::Encode::encode(self.vector_uint16, encoder, vector_uint16)?;

        ::fidl_next::Encode::encode(self.vector_uint32, encoder, vector_uint32)?;

        ::fidl_next::Encode::encode(self.vector_uint64, encoder, vector_uint64)?;

        ::fidl_next::Encode::encode(self.vector_int8, encoder, vector_int8)?;

        ::fidl_next::Encode::encode(self.vector_int16, encoder, vector_int16)?;

        ::fidl_next::Encode::encode(self.vector_int32, encoder, vector_int32)?;

        ::fidl_next::Encode::encode(self.vector_int64, encoder, vector_int64)?;

        ::fidl_next::Encode::encode(self.vector_float32, encoder, vector_float32)?;

        ::fidl_next::Encode::encode(self.vector_float64, encoder, vector_float64)?;

        ::fidl_next::Encode::encode(self.vector_string, encoder, vector_string)?;

        ::fidl_next::Encode::encode(self.vector_opt_string, encoder, vector_opt_string)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for VectorBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.vector_uint8, encoder, vector_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_uint16, encoder, vector_uint16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_uint32, encoder, vector_uint32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_uint64, encoder, vector_uint64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_int8, encoder, vector_int8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_int16, encoder, vector_int16)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_int32, encoder, vector_int32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_int64, encoder, vector_int64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_float32, encoder, vector_float32)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_float64, encoder, vector_float64)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_string, encoder, vector_string)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_opt_string, encoder, vector_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for VectorBasic {
    type EncodedOption = ::fidl_next::WireBox<'static, WireVectorBasic<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for VectorBasic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorBasic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for VectorBasic
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorBasic: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireVectorBasic<'de>> for VectorBasic {
    #[inline]
    fn from_wire(wire: WireVectorBasic<'de>) -> Self {
        Self {
            vector_uint8: ::fidl_next::FromWire::from_wire(wire.vector_uint8),

            vector_uint16: ::fidl_next::FromWire::from_wire(wire.vector_uint16),

            vector_uint32: ::fidl_next::FromWire::from_wire(wire.vector_uint32),

            vector_uint64: ::fidl_next::FromWire::from_wire(wire.vector_uint64),

            vector_int8: ::fidl_next::FromWire::from_wire(wire.vector_int8),

            vector_int16: ::fidl_next::FromWire::from_wire(wire.vector_int16),

            vector_int32: ::fidl_next::FromWire::from_wire(wire.vector_int32),

            vector_int64: ::fidl_next::FromWire::from_wire(wire.vector_int64),

            vector_float32: ::fidl_next::FromWire::from_wire(wire.vector_float32),

            vector_float64: ::fidl_next::FromWire::from_wire(wire.vector_float64),

            vector_string: ::fidl_next::FromWire::from_wire(wire.vector_string),

            vector_opt_string: ::fidl_next::FromWire::from_wire(wire.vector_opt_string),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireVectorBasic<'de>> for VectorBasic {
    #[inline]
    fn from_wire_ref(wire: &WireVectorBasic<'de>) -> Self {
        Self {
            vector_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_uint8),

            vector_uint16: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_uint16),

            vector_uint32: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_uint32),

            vector_uint64: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_uint64),

            vector_int8: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_int8),

            vector_int16: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_int16),

            vector_int32: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_int32),

            vector_int64: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_int64),

            vector_float32: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_float32),

            vector_float64: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_float64),

            vector_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_string),

            vector_opt_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_opt_string),
        }
    }
}

/// The wire type corresponding to [`VectorBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorBasic<'de> {
    pub vector_uint8: ::fidl_next::WireVector<'de, u8>,

    pub vector_uint16: ::fidl_next::WireVector<'de, ::fidl_next::WireU16>,

    pub vector_uint32: ::fidl_next::WireVector<'de, ::fidl_next::WireU32>,

    pub vector_uint64: ::fidl_next::WireVector<'de, ::fidl_next::WireU64>,

    pub vector_int8: ::fidl_next::WireVector<'de, i8>,

    pub vector_int16: ::fidl_next::WireVector<'de, ::fidl_next::WireI16>,

    pub vector_int32: ::fidl_next::WireVector<'de, ::fidl_next::WireI32>,

    pub vector_int64: ::fidl_next::WireVector<'de, ::fidl_next::WireI64>,

    pub vector_float32: ::fidl_next::WireVector<'de, ::fidl_next::WireF32>,

    pub vector_float64: ::fidl_next::WireVector<'de, ::fidl_next::WireF64>,

    pub vector_string: ::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>,

    pub vector_opt_string: ::fidl_next::WireVector<'de, ::fidl_next::WireOptionalString<'de>>,
}

unsafe impl ::fidl_next::Wire for WireVectorBasic<'static> {
    type Decoded<'de> = WireVectorBasic<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorBasic<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_uint8,
                mut vector_uint16,
                mut vector_uint32,
                mut vector_uint64,
                mut vector_int8,
                mut vector_int16,
                mut vector_int32,
                mut vector_int64,
                mut vector_float32,
                mut vector_float64,
                mut vector_string,
                mut vector_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorCompound {
    pub vector_bits: Vec<crate::Bits>,

    pub vector_enum: Vec<crate::Enum>,

    pub vector_struct: Vec<crate::Struct>,

    pub vector_table: Vec<crate::Table>,

    pub vector_union: Vec<crate::Union>,

    pub vector_opt_struct: Vec<Option<Box<crate::Struct>>>,

    pub vector_opt_union: Vec<Option<Box<crate::Union>>>,
}

impl ::fidl_next::Encodable for VectorCompound {
    type Encoded = WireVectorCompound<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.vector_bits, encoder, vector_bits)?;

        ::fidl_next::Encode::encode(self.vector_enum, encoder, vector_enum)?;

        ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

        ::fidl_next::Encode::encode(self.vector_opt_struct, encoder, vector_opt_struct)?;

        ::fidl_next::Encode::encode(self.vector_opt_union, encoder, vector_opt_union)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for VectorCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.vector_bits, encoder, vector_bits)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_enum, encoder, vector_enum)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_table, encoder, vector_table)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_union, encoder, vector_union)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_opt_struct, encoder, vector_opt_struct)?;

        ::fidl_next::EncodeRef::encode_ref(&self.vector_opt_union, encoder, vector_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for VectorCompound {
    type EncodedOption = ::fidl_next::WireBox<'static, WireVectorCompound<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for VectorCompound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorCompound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for VectorCompound
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorCompound: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireVectorCompound<'de>> for VectorCompound {
    #[inline]
    fn from_wire(wire: WireVectorCompound<'de>) -> Self {
        Self {
            vector_bits: ::fidl_next::FromWire::from_wire(wire.vector_bits),

            vector_enum: ::fidl_next::FromWire::from_wire(wire.vector_enum),

            vector_struct: ::fidl_next::FromWire::from_wire(wire.vector_struct),

            vector_table: ::fidl_next::FromWire::from_wire(wire.vector_table),

            vector_union: ::fidl_next::FromWire::from_wire(wire.vector_union),

            vector_opt_struct: ::fidl_next::FromWire::from_wire(wire.vector_opt_struct),

            vector_opt_union: ::fidl_next::FromWire::from_wire(wire.vector_opt_union),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireVectorCompound<'de>> for VectorCompound {
    #[inline]
    fn from_wire_ref(wire: &WireVectorCompound<'de>) -> Self {
        Self {
            vector_bits: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_bits),

            vector_enum: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_enum),

            vector_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_struct),

            vector_table: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_table),

            vector_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_union),

            vector_opt_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_opt_struct),

            vector_opt_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.vector_opt_union),
        }
    }
}

/// The wire type corresponding to [`VectorCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorCompound<'de> {
    pub vector_bits: ::fidl_next::WireVector<'de, crate::WireBits>,

    pub vector_enum: ::fidl_next::WireVector<'de, crate::WireEnum>,

    pub vector_struct: ::fidl_next::WireVector<'de, crate::WireStruct>,

    pub vector_table: ::fidl_next::WireVector<'de, crate::WireTable<'de>>,

    pub vector_union: ::fidl_next::WireVector<'de, crate::WireUnion>,

    pub vector_opt_struct:
        ::fidl_next::WireVector<'de, ::fidl_next::WireBox<'de, crate::WireStruct>>,

    pub vector_opt_union: ::fidl_next::WireVector<'de, crate::WireOptionalUnion>,
}

unsafe impl ::fidl_next::Wire for WireVectorCompound<'static> {
    type Decoded<'de> = WireVectorCompound<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorCompound<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_bits,
                mut vector_enum,
                mut vector_struct,
                mut vector_table,
                mut vector_union,
                mut vector_opt_struct,
                mut vector_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,

    pub opt_vector_string: Option<Vec<String>>,

    pub opt_vector_struct: Option<Vec<crate::Struct>>,

    pub opt_vector_opt_struct: Option<Vec<Option<Box<crate::Struct>>>>,
}

impl ::fidl_next::Encodable for VectorOptional {
    type Encoded = WireVectorOptional<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorOptional
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,

            } = out;
        }

        ::fidl_next::Encode::encode(self.opt_vector_uint8, encoder, opt_vector_uint8)?;

        ::fidl_next::Encode::encode(self.opt_vector_string, encoder, opt_vector_string)?;

        ::fidl_next::Encode::encode(self.opt_vector_struct, encoder, opt_vector_struct)?;

        ::fidl_next::Encode::encode(self.opt_vector_opt_struct, encoder, opt_vector_opt_struct)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for VectorOptional
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.opt_vector_uint8, encoder, opt_vector_uint8)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_vector_string, encoder, opt_vector_string)?;

        ::fidl_next::EncodeRef::encode_ref(&self.opt_vector_struct, encoder, opt_vector_struct)?;

        ::fidl_next::EncodeRef::encode_ref(
            &self.opt_vector_opt_struct,
            encoder,
            opt_vector_opt_struct,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for VectorOptional {
    type EncodedOption = ::fidl_next::WireBox<'static, WireVectorOptional<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for VectorOptional
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorOptional: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for VectorOptional
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorOptional: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireVectorOptional<'de>> for VectorOptional {
    #[inline]
    fn from_wire(wire: WireVectorOptional<'de>) -> Self {
        Self {
            opt_vector_uint8: ::fidl_next::FromWire::from_wire(wire.opt_vector_uint8),

            opt_vector_string: ::fidl_next::FromWire::from_wire(wire.opt_vector_string),

            opt_vector_struct: ::fidl_next::FromWire::from_wire(wire.opt_vector_struct),

            opt_vector_opt_struct: ::fidl_next::FromWire::from_wire(wire.opt_vector_opt_struct),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireVectorOptional<'de>> for VectorOptional {
    #[inline]
    fn from_wire_ref(wire: &WireVectorOptional<'de>) -> Self {
        Self {
            opt_vector_uint8: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_vector_uint8),

            opt_vector_string: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_vector_string),

            opt_vector_struct: ::fidl_next::FromWireRef::from_wire_ref(&wire.opt_vector_struct),

            opt_vector_opt_struct: ::fidl_next::FromWireRef::from_wire_ref(
                &wire.opt_vector_opt_struct,
            ),
        }
    }
}

/// The wire type corresponding to [`VectorOptional`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorOptional<'de> {
    pub opt_vector_uint8: ::fidl_next::WireOptionalVector<'de, u8>,

    pub opt_vector_string: ::fidl_next::WireOptionalVector<'de, ::fidl_next::WireString<'de>>,

    pub opt_vector_struct: ::fidl_next::WireOptionalVector<'de, crate::WireStruct>,

    pub opt_vector_opt_struct:
        ::fidl_next::WireOptionalVector<'de, ::fidl_next::WireBox<'de, crate::WireStruct>>,
}

unsafe impl ::fidl_next::Wire for WireVectorOptional<'static> {
    type Decoded<'de> = WireVectorOptional<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorOptional<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut opt_vector_uint8,
                mut opt_vector_string,
                mut opt_vector_struct,
                mut opt_vector_opt_struct,

            } = slot;
        }

        ::fidl_next::Decode::decode(opt_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_opt_struct.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ResourceStruct {}

impl ::fidl_next::Encodable for ResourceStruct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireResourceStruct> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireResourceStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ResourceStruct {
    type EncodedOption = ::fidl_next::WireBox<'static, WireResourceStruct>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ResourceStruct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ResourceStruct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireResourceStruct> for ResourceStruct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireResourceStruct, Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn from_wire(wire: WireResourceStruct) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`ResourceStruct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResourceStruct {}

unsafe impl ::fidl_next::Wire for WireResourceStruct {
    type Decoded<'de> = WireResourceStruct;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct ResourceTable {}

impl ResourceTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for ResourceTable {
    type Encoded = WireResourceTable<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceTable
where
    ___E: ::fidl_next::Encoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireResourceTable<'de>> for ResourceTable {
    #[inline]
    fn from_wire(wire: WireResourceTable<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        Self {}
    }
}

/// The wire type corresponding to [`ResourceTable`].
#[repr(C)]
pub struct WireResourceTable<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireResourceTable<'de> {
    fn drop(&mut self) {}
}

unsafe impl ::fidl_next::Wire for WireResourceTable<'static> {
    type Decoded<'de> = WireResourceTable<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceTable<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireResourceTable<'de> {}

impl<'de> ::core::fmt::Debug for WireResourceTable<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ResourceTable").finish()
    }
}

#[derive(Debug)]
pub enum ResourceUnion {
    B(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ResourceUnion {
    type Encoded = WireResourceUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceUnion { raw, _phantom: _ } = out);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ResourceUnion {
    type EncodedOption = WireOptionalResourceUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ResourceUnion
where
    ___E: ?Sized,
    ResourceUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalResourceUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireResourceUnion> for ResourceUnion {
    #[inline]
    fn from_wire(wire: WireResourceUnion) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::B(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalResourceUnion> for Box<ResourceUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalResourceUnion) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ResourceUnion`].
#[repr(transparent)]
pub struct WireResourceUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireResourceUnion {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<bool>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireResourceUnion {
    type Decoded<'de> = WireResourceUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod resource_union {
    pub enum Ref<'de> {
        B(&'de bool),

        UnknownOrdinal_(u64),
    }
}

impl WireResourceUnion {
    pub fn as_ref(&self) -> crate::resource_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::resource_union::Ref::B(unsafe { self.raw.get().deref_unchecked::<bool>() }),

            unknown => crate::resource_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalResourceUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalResourceUnion {
    type Decoded<'de> = WireOptionalResourceUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalResourceUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireResourceUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireResourceUnion> {
        if self.is_some() {
            Some(WireResourceUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalResourceUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct Resource {
    pub handle: ::fidl_next::fuchsia::zx::Handle,

    pub vmo: ::fidl_next::fuchsia::zx::Handle,

    pub client_end: ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::zx::Channel>,

    pub server_end: ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::zx::Channel>,

    pub struct_: crate::ResourceStruct,

    pub table: crate::ResourceTable,

    pub union: crate::ResourceUnion,

    pub opt_handle: Option<::fidl_next::fuchsia::zx::Handle>,

    pub opt_vmo: Option<::fidl_next::fuchsia::zx::Handle>,

    pub opt_client_end:
        Option<::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::zx::Channel>>,

    pub opt_server_end:
        Option<::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::zx::Channel>>,

    pub opt_struct: Option<Box<crate::ResourceStruct>>,

    pub opt_union: Option<Box<crate::ResourceUnion>>,

    pub array_handle: [::fidl_next::fuchsia::zx::Handle; 5],

    pub array_vmo: [::fidl_next::fuchsia::zx::Handle; 5],

    pub array_client_end:
        [::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::zx::Channel>; 5],

    pub array_server_end:
        [::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::zx::Channel>; 5],

    pub array_struct: [crate::ResourceStruct; 5],

    pub array_table: [crate::ResourceTable; 5],

    pub array_union: [crate::ResourceUnion; 5],

    pub vector_handle: Vec<::fidl_next::fuchsia::zx::Handle>,

    pub vector_vmo: Vec<::fidl_next::fuchsia::zx::Handle>,

    pub vector_client_end:
        Vec<::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::zx::Channel>>,

    pub vector_server_end:
        Vec<::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::zx::Channel>>,

    pub vector_struct: Vec<crate::ResourceStruct>,

    pub vector_table: Vec<crate::ResourceTable>,

    pub vector_union: Vec<crate::ResourceUnion>,
}

impl ::fidl_next::Encodable for Resource {
    type Encoded = WireResource<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Resource
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.handle, encoder, handle)?;

        ::fidl_next::Encode::encode(self.vmo, encoder, vmo)?;

        ::fidl_next::Encode::encode(self.client_end, encoder, client_end)?;

        ::fidl_next::Encode::encode(self.server_end, encoder, server_end)?;

        ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

        ::fidl_next::Encode::encode(self.table, encoder, table)?;

        ::fidl_next::Encode::encode(self.union, encoder, union)?;

        ::fidl_next::Encode::encode(self.opt_handle, encoder, opt_handle)?;

        ::fidl_next::Encode::encode(self.opt_vmo, encoder, opt_vmo)?;

        ::fidl_next::Encode::encode(self.opt_client_end, encoder, opt_client_end)?;

        ::fidl_next::Encode::encode(self.opt_server_end, encoder, opt_server_end)?;

        ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

        ::fidl_next::Encode::encode(self.array_handle, encoder, array_handle)?;

        ::fidl_next::Encode::encode(self.array_vmo, encoder, array_vmo)?;

        ::fidl_next::Encode::encode(self.array_client_end, encoder, array_client_end)?;

        ::fidl_next::Encode::encode(self.array_server_end, encoder, array_server_end)?;

        ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(self.vector_handle, encoder, vector_handle)?;

        ::fidl_next::Encode::encode(self.vector_vmo, encoder, vector_vmo)?;

        ::fidl_next::Encode::encode(self.vector_client_end, encoder, vector_client_end)?;

        ::fidl_next::Encode::encode(self.vector_server_end, encoder, vector_server_end)?;

        ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Resource {
    type EncodedOption = ::fidl_next::WireBox<'static, WireResource<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Resource
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Resource: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireResource<'de>> for Resource {
    #[inline]
    fn from_wire(wire: WireResource<'de>) -> Self {
        Self {
            handle: ::fidl_next::FromWire::from_wire(wire.handle),

            vmo: ::fidl_next::FromWire::from_wire(wire.vmo),

            client_end: ::fidl_next::FromWire::from_wire(wire.client_end),

            server_end: ::fidl_next::FromWire::from_wire(wire.server_end),

            struct_: ::fidl_next::FromWire::from_wire(wire.struct_),

            table: ::fidl_next::FromWire::from_wire(wire.table),

            union: ::fidl_next::FromWire::from_wire(wire.union),

            opt_handle: ::fidl_next::FromWire::from_wire(wire.opt_handle),

            opt_vmo: ::fidl_next::FromWire::from_wire(wire.opt_vmo),

            opt_client_end: ::fidl_next::FromWire::from_wire(wire.opt_client_end),

            opt_server_end: ::fidl_next::FromWire::from_wire(wire.opt_server_end),

            opt_struct: ::fidl_next::FromWire::from_wire(wire.opt_struct),

            opt_union: ::fidl_next::FromWire::from_wire(wire.opt_union),

            array_handle: ::fidl_next::FromWire::from_wire(wire.array_handle),

            array_vmo: ::fidl_next::FromWire::from_wire(wire.array_vmo),

            array_client_end: ::fidl_next::FromWire::from_wire(wire.array_client_end),

            array_server_end: ::fidl_next::FromWire::from_wire(wire.array_server_end),

            array_struct: ::fidl_next::FromWire::from_wire(wire.array_struct),

            array_table: ::fidl_next::FromWire::from_wire(wire.array_table),

            array_union: ::fidl_next::FromWire::from_wire(wire.array_union),

            vector_handle: ::fidl_next::FromWire::from_wire(wire.vector_handle),

            vector_vmo: ::fidl_next::FromWire::from_wire(wire.vector_vmo),

            vector_client_end: ::fidl_next::FromWire::from_wire(wire.vector_client_end),

            vector_server_end: ::fidl_next::FromWire::from_wire(wire.vector_server_end),

            vector_struct: ::fidl_next::FromWire::from_wire(wire.vector_struct),

            vector_table: ::fidl_next::FromWire::from_wire(wire.vector_table),

            vector_union: ::fidl_next::FromWire::from_wire(wire.vector_union),
        }
    }
}

/// The wire type corresponding to [`Resource`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResource<'de> {
    pub handle: ::fidl_next::fuchsia::WireHandle,

    pub vmo: ::fidl_next::fuchsia::WireHandle,

    pub client_end: ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,

    pub server_end: ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,

    pub struct_: crate::WireResourceStruct,

    pub table: crate::WireResourceTable<'de>,

    pub union: crate::WireResourceUnion,

    pub opt_handle: ::fidl_next::fuchsia::WireOptionalHandle,

    pub opt_vmo: ::fidl_next::fuchsia::WireOptionalHandle,

    pub opt_client_end:
        ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireOptionalChannel>,

    pub opt_server_end:
        ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireOptionalChannel>,

    pub opt_struct: ::fidl_next::WireBox<'de, crate::WireResourceStruct>,

    pub opt_union: crate::WireOptionalResourceUnion,

    pub array_handle: [::fidl_next::fuchsia::WireHandle; 5],

    pub array_vmo: [::fidl_next::fuchsia::WireHandle; 5],

    pub array_client_end:
        [::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>; 5],

    pub array_server_end:
        [::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>; 5],

    pub array_struct: [crate::WireResourceStruct; 5],

    pub array_table: [crate::WireResourceTable<'de>; 5],

    pub array_union: [crate::WireResourceUnion; 5],

    pub vector_handle: ::fidl_next::WireVector<'de, ::fidl_next::fuchsia::WireHandle>,

    pub vector_vmo: ::fidl_next::WireVector<'de, ::fidl_next::fuchsia::WireHandle>,

    pub vector_client_end: ::fidl_next::WireVector<
        'de,
        ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
    >,

    pub vector_server_end: ::fidl_next::WireVector<
        'de,
        ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
    >,

    pub vector_struct: ::fidl_next::WireVector<'de, crate::WireResourceStruct>,

    pub vector_table: ::fidl_next::WireVector<'de, crate::WireResourceTable<'de>>,

    pub vector_union: ::fidl_next::WireVector<'de, crate::WireResourceUnion>,
}

unsafe impl ::fidl_next::Wire for WireResource<'static> {
    type Decoded<'de> = WireResource<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(181).write_bytes(0, 3);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(17).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResource<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut handle,
                mut vmo,
                mut client_end,
                mut server_end,
                mut struct_,
                mut table,
                mut union,
                mut opt_handle,
                mut opt_vmo,
                mut opt_client_end,
                mut opt_server_end,
                mut opt_struct,
                mut opt_union,
                mut array_handle,
                mut array_vmo,
                mut array_client_end,
                mut array_server_end,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut vector_handle,
                mut vector_vmo,
                mut vector_client_end,
                mut vector_server_end,
                mut vector_struct,
                mut vector_table,
                mut vector_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(struct_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the Protocol protocol.
#[derive(Debug)]
pub struct Protocol;

pub mod protocol {
    pub mod prelude {
        pub use crate::{protocol, Protocol, ProtocolClientHandler, ProtocolServerHandler};

        pub use crate::ArrayBasic;

        pub use crate::ArrayCompound;

        pub use crate::ArrayVectorNested;

        pub use crate::Basic;

        pub use crate::Compound;

        pub use crate::Resource;

        pub use crate::VectorBasic;

        pub use crate::VectorCompound;

        pub use crate::VectorOptional;
    }

    pub struct OneWayBasic;

    impl ::fidl_next::Method for OneWayBasic {
        const ORDINAL: u64 = 8948968077914418681;

        type Protocol = crate::Protocol;

        type Request = crate::WireBasic<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayBasic;

    impl ::fidl_next::Method for TwoWayBasic {
        const ORDINAL: u64 = 2331618702752598159;

        type Protocol = crate::Protocol;

        type Request = crate::WireBasic<'static>;

        type Response = crate::WireBasic<'static>;
    }

    pub struct ErrorBasic;

    impl ::fidl_next::Method for ErrorBasic {
        const ORDINAL: u64 = 5016634351643393939;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireBasic<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventBasic;

    impl ::fidl_next::Method for EventBasic {
        const ORDINAL: u64 = 5892309624949902400;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireBasic<'static>;
    }

    pub struct OneWayCompound;

    impl ::fidl_next::Method for OneWayCompound {
        const ORDINAL: u64 = 3153289648860022476;

        type Protocol = crate::Protocol;

        type Request = crate::WireCompound<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayCompound;

    impl ::fidl_next::Method for TwoWayCompound {
        const ORDINAL: u64 = 8787219719097524529;

        type Protocol = crate::Protocol;

        type Request = crate::WireCompound<'static>;

        type Response = crate::WireCompound<'static>;
    }

    pub struct ErrorCompound;

    impl ::fidl_next::Method for ErrorCompound {
        const ORDINAL: u64 = 2990809657626249085;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireCompound<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventCompound;

    impl ::fidl_next::Method for EventCompound {
        const ORDINAL: u64 = 7024581948727571669;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireCompound<'static>;
    }

    pub struct OneWayArrayBasic;

    impl ::fidl_next::Method for OneWayArrayBasic {
        const ORDINAL: u64 = 7125516817014311449;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayBasic<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayBasic;

    impl ::fidl_next::Method for TwoWayArrayBasic {
        const ORDINAL: u64 = 5309034178175279380;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayBasic<'static>;

        type Response = crate::WireArrayBasic<'static>;
    }

    pub struct ErrorArrayBasic;

    impl ::fidl_next::Method for ErrorArrayBasic {
        const ORDINAL: u64 = 1084731895342694265;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireArrayBasic<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventArrayBasic;

    impl ::fidl_next::Method for EventArrayBasic {
        const ORDINAL: u64 = 5888282827283820590;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayBasic<'static>;
    }

    pub struct OneWayArrayCompound;

    impl ::fidl_next::Method for OneWayArrayCompound {
        const ORDINAL: u64 = 5064659223443251357;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayCompound<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayCompound;

    impl ::fidl_next::Method for TwoWayArrayCompound {
        const ORDINAL: u64 = 849744466051983995;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayCompound<'static>;

        type Response = crate::WireArrayCompound<'static>;
    }

    pub struct ErrorArrayCompound;

    impl ::fidl_next::Method for ErrorArrayCompound {
        const ORDINAL: u64 = 5919277476782807556;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireArrayCompound<'static>,
            ::fidl_next::WireU32,
        >;
    }

    pub struct EventArrayCompound;

    impl ::fidl_next::Method for EventArrayCompound {
        const ORDINAL: u64 = 2189769767733851157;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayCompound<'static>;
    }

    pub struct OneWayVectorBasic;

    impl ::fidl_next::Method for OneWayVectorBasic {
        const ORDINAL: u64 = 5733220720079947351;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorBasic<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorBasic;

    impl ::fidl_next::Method for TwoWayVectorBasic {
        const ORDINAL: u64 = 8674156353091415668;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorBasic<'static>;

        type Response = crate::WireVectorBasic<'static>;
    }

    pub struct ErrorVectorBasic;

    impl ::fidl_next::Method for ErrorVectorBasic {
        const ORDINAL: u64 = 875941614196965234;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireVectorBasic<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventVectorBasic;

    impl ::fidl_next::Method for EventVectorBasic {
        const ORDINAL: u64 = 4583890770109526006;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorBasic<'static>;
    }

    pub struct OneWayVectorCompound;

    impl ::fidl_next::Method for OneWayVectorCompound {
        const ORDINAL: u64 = 1853985797298830992;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorCompound<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorCompound;

    impl ::fidl_next::Method for TwoWayVectorCompound {
        const ORDINAL: u64 = 3968024057912959924;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorCompound<'static>;

        type Response = crate::WireVectorCompound<'static>;
    }

    pub struct ErrorVectorCompound;

    impl ::fidl_next::Method for ErrorVectorCompound {
        const ORDINAL: u64 = 8506780203315865989;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireVectorCompound<'static>,
            ::fidl_next::WireU32,
        >;
    }

    pub struct EventVectorCompound;

    impl ::fidl_next::Method for EventVectorCompound {
        const ORDINAL: u64 = 6026375226599919603;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorCompound<'static>;
    }

    pub struct OneWayVectorOptional;

    impl ::fidl_next::Method for OneWayVectorOptional {
        const ORDINAL: u64 = 1530215841195476271;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorOptional<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorOptional;

    impl ::fidl_next::Method for TwoWayVectorOptional {
        const ORDINAL: u64 = 1030024737742222323;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorOptional<'static>;

        type Response = crate::WireVectorOptional<'static>;
    }

    pub struct ErrorVectorOptional;

    impl ::fidl_next::Method for ErrorVectorOptional {
        const ORDINAL: u64 = 6406191217027936606;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireVectorOptional<'static>,
            ::fidl_next::WireU32,
        >;
    }

    pub struct EventVectorOptional;

    impl ::fidl_next::Method for EventVectorOptional {
        const ORDINAL: u64 = 1684763340073130077;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorOptional<'static>;
    }

    pub struct OneWayArrayVectorNested;

    impl ::fidl_next::Method for OneWayArrayVectorNested {
        const ORDINAL: u64 = 5912603762133524183;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayVectorNested<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayVectorNested;

    impl ::fidl_next::Method for TwoWayArrayVectorNested {
        const ORDINAL: u64 = 5351275678438791132;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayVectorNested<'static>;

        type Response = crate::WireArrayVectorNested<'static>;
    }

    pub struct ErrorArrayVectorNested;

    impl ::fidl_next::Method for ErrorArrayVectorNested {
        const ORDINAL: u64 = 9085604921605802151;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireArrayVectorNested<'static>,
            ::fidl_next::WireU32,
        >;
    }

    pub struct EventArrayVectorNested;

    impl ::fidl_next::Method for EventArrayVectorNested {
        const ORDINAL: u64 = 1228201560727880574;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayVectorNested<'static>;
    }

    pub struct OneWayResource;

    impl ::fidl_next::Method for OneWayResource {
        const ORDINAL: u64 = 6553996787849601058;

        type Protocol = crate::Protocol;

        type Request = crate::WireResource<'static>;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayResource;

    impl ::fidl_next::Method for TwoWayResource {
        const ORDINAL: u64 = 1802709005492464987;

        type Protocol = crate::Protocol;

        type Request = crate::WireResource<'static>;

        type Response = crate::WireResource<'static>;
    }

    pub struct ErrorResource;

    impl ::fidl_next::Method for ErrorResource {
        const ORDINAL: u64 = 6568609240497354166;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<'static, crate::WireResource<'static>, ::fidl_next::WireU32>;
    }

    pub struct EventResource;

    impl ::fidl_next::Method for EventResource {
        const ORDINAL: u64 = 5745997765922613643;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireResource<'static>;
    }

    mod ___detail {

        pub struct OneWayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            uint8: T0,

            uint16: T1,

            uint32: T2,

            uint64: T3,

            int8: T4,

            int16: T5,

            int32: T6,

            int64: T7,

            float32: T8,

            float64: T9,

            string: T10,

            opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for OneWayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = u8>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU16>,

            T2: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU32>,

            T3: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU64>,

            T4: ::fidl_next::Encodable<Encoded = i8>,

            T5: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI16>,

            T6: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI32>,

            T7: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,

            T8: ::fidl_next::Encodable<Encoded = ::fidl_next::WireF32>,

            T9: ::fidl_next::Encodable<Encoded = ::fidl_next::WireF64>,

            T10: ::fidl_next::Encodable<Encoded = ::fidl_next::WireString<'static>>,

            T11: ::fidl_next::Encodable<Encoded = ::fidl_next::WireOptionalString<'static>>,
        {
            type Encoded = crate::WireBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for OneWayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = u8>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU16>,

            T2: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU32>,

            T3: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU64>,

            T4: ::fidl_next::Encode<___E, Encoded = i8>,

            T5: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI16>,

            T6: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI32>,

            T7: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,

            T8: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireF32>,

            T9: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireF64>,

            T10: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireString<'static>>,

            T11: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireOptionalString<'static>>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        uint8,
                        uint16,
                        uint32,
                        uint64,
                        int8,
                        int16,
                        int32,
                        int64,
                        float32,
                        float64,
                        string,
                        opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.uint8, encoder, uint8)?;

                ::fidl_next::Encode::encode(self.uint16, encoder, uint16)?;

                ::fidl_next::Encode::encode(self.uint32, encoder, uint32)?;

                ::fidl_next::Encode::encode(self.uint64, encoder, uint64)?;

                ::fidl_next::Encode::encode(self.int8, encoder, int8)?;

                ::fidl_next::Encode::encode(self.int16, encoder, int16)?;

                ::fidl_next::Encode::encode(self.int32, encoder, int32)?;

                ::fidl_next::Encode::encode(self.int64, encoder, int64)?;

                ::fidl_next::Encode::encode(self.float32, encoder, float32)?;

                ::fidl_next::Encode::encode(self.float64, encoder, float64)?;

                ::fidl_next::Encode::encode(self.string, encoder, string)?;

                ::fidl_next::Encode::encode(self.opt_string, encoder, opt_string)?;

                Ok(())
            }
        }

        pub struct TwoWayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            uint8: T0,

            uint16: T1,

            uint32: T2,

            uint64: T3,

            int8: T4,

            int16: T5,

            int32: T6,

            int64: T7,

            float32: T8,

            float64: T9,

            string: T10,

            opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for TwoWayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = u8>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU16>,

            T2: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU32>,

            T3: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU64>,

            T4: ::fidl_next::Encodable<Encoded = i8>,

            T5: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI16>,

            T6: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI32>,

            T7: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,

            T8: ::fidl_next::Encodable<Encoded = ::fidl_next::WireF32>,

            T9: ::fidl_next::Encodable<Encoded = ::fidl_next::WireF64>,

            T10: ::fidl_next::Encodable<Encoded = ::fidl_next::WireString<'static>>,

            T11: ::fidl_next::Encodable<Encoded = ::fidl_next::WireOptionalString<'static>>,
        {
            type Encoded = crate::WireBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for TwoWayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = u8>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU16>,

            T2: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU32>,

            T3: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU64>,

            T4: ::fidl_next::Encode<___E, Encoded = i8>,

            T5: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI16>,

            T6: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI32>,

            T7: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,

            T8: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireF32>,

            T9: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireF64>,

            T10: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireString<'static>>,

            T11: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireOptionalString<'static>>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        uint8,
                        uint16,
                        uint32,
                        uint64,
                        int8,
                        int16,
                        int32,
                        int64,
                        float32,
                        float64,
                        string,
                        opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.uint8, encoder, uint8)?;

                ::fidl_next::Encode::encode(self.uint16, encoder, uint16)?;

                ::fidl_next::Encode::encode(self.uint32, encoder, uint32)?;

                ::fidl_next::Encode::encode(self.uint64, encoder, uint64)?;

                ::fidl_next::Encode::encode(self.int8, encoder, int8)?;

                ::fidl_next::Encode::encode(self.int16, encoder, int16)?;

                ::fidl_next::Encode::encode(self.int32, encoder, int32)?;

                ::fidl_next::Encode::encode(self.int64, encoder, int64)?;

                ::fidl_next::Encode::encode(self.float32, encoder, float32)?;

                ::fidl_next::Encode::encode(self.float64, encoder, float64)?;

                ::fidl_next::Encode::encode(self.string, encoder, string)?;

                ::fidl_next::Encode::encode(self.opt_string, encoder, opt_string)?;

                Ok(())
            }
        }

        pub struct EventBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            uint8: T0,

            uint16: T1,

            uint32: T2,

            uint64: T3,

            int8: T4,

            int16: T5,

            int32: T6,

            int64: T7,

            float32: T8,

            float64: T9,

            string: T10,

            opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for EventBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = u8>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU16>,

            T2: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU32>,

            T3: ::fidl_next::Encodable<Encoded = ::fidl_next::WireU64>,

            T4: ::fidl_next::Encodable<Encoded = i8>,

            T5: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI16>,

            T6: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI32>,

            T7: ::fidl_next::Encodable<Encoded = ::fidl_next::WireI64>,

            T8: ::fidl_next::Encodable<Encoded = ::fidl_next::WireF32>,

            T9: ::fidl_next::Encodable<Encoded = ::fidl_next::WireF64>,

            T10: ::fidl_next::Encodable<Encoded = ::fidl_next::WireString<'static>>,

            T11: ::fidl_next::Encodable<Encoded = ::fidl_next::WireOptionalString<'static>>,
        {
            type Encoded = crate::WireBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for EventBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = u8>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU16>,

            T2: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU32>,

            T3: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireU64>,

            T4: ::fidl_next::Encode<___E, Encoded = i8>,

            T5: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI16>,

            T6: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI32>,

            T7: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireI64>,

            T8: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireF32>,

            T9: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireF64>,

            T10: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireString<'static>>,

            T11: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireOptionalString<'static>>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        uint8,
                        uint16,
                        uint32,
                        uint64,
                        int8,
                        int16,
                        int32,
                        int64,
                        float32,
                        float64,
                        string,
                        opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.uint8, encoder, uint8)?;

                ::fidl_next::Encode::encode(self.uint16, encoder, uint16)?;

                ::fidl_next::Encode::encode(self.uint32, encoder, uint32)?;

                ::fidl_next::Encode::encode(self.uint64, encoder, uint64)?;

                ::fidl_next::Encode::encode(self.int8, encoder, int8)?;

                ::fidl_next::Encode::encode(self.int16, encoder, int16)?;

                ::fidl_next::Encode::encode(self.int32, encoder, int32)?;

                ::fidl_next::Encode::encode(self.int64, encoder, int64)?;

                ::fidl_next::Encode::encode(self.float32, encoder, float32)?;

                ::fidl_next::Encode::encode(self.float64, encoder, float64)?;

                ::fidl_next::Encode::encode(self.string, encoder, string)?;

                ::fidl_next::Encode::encode(self.opt_string, encoder, opt_string)?;

                Ok(())
            }
        }

        pub struct OneWayCompound<T0, T1, T2, T3, T4, T5, T6> {
            bits: T0,

            enum_: T1,

            struct_: T2,

            table: T3,

            union: T4,

            opt_struct: T5,

            opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for OneWayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = crate::WireBits>,

            T1: ::fidl_next::Encodable<Encoded = crate::WireEnum>,

            T2: ::fidl_next::Encodable<Encoded = crate::WireStruct>,

            T3: ::fidl_next::Encodable<Encoded = crate::WireTable<'static>>,

            T4: ::fidl_next::Encodable<Encoded = crate::WireUnion>,

            T5: ::fidl_next::Encodable<Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>>,

            T6: ::fidl_next::Encodable<Encoded = crate::WireOptionalUnion>,
        {
            type Encoded = crate::WireCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for OneWayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = crate::WireBits>,

            T1: ::fidl_next::Encode<___E, Encoded = crate::WireEnum>,

            T2: ::fidl_next::Encode<___E, Encoded = crate::WireStruct>,

            T3: ::fidl_next::Encode<___E, Encoded = crate::WireTable<'static>>,

            T4: ::fidl_next::Encode<___E, Encoded = crate::WireUnion>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>,
            >,

            T6: ::fidl_next::Encode<___E, Encoded = crate::WireOptionalUnion>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        bits,
                        enum_,
                        struct_,
                        table,
                        union,
                        opt_struct,
                        opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.bits, encoder, bits)?;

                ::fidl_next::Encode::encode(self.enum_, encoder, enum_)?;

                ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

                ::fidl_next::Encode::encode(self.table, encoder, table)?;

                ::fidl_next::Encode::encode(self.union, encoder, union)?;

                ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

                ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

                Ok(())
            }
        }

        pub struct TwoWayCompound<T0, T1, T2, T3, T4, T5, T6> {
            bits: T0,

            enum_: T1,

            struct_: T2,

            table: T3,

            union: T4,

            opt_struct: T5,

            opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for TwoWayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = crate::WireBits>,

            T1: ::fidl_next::Encodable<Encoded = crate::WireEnum>,

            T2: ::fidl_next::Encodable<Encoded = crate::WireStruct>,

            T3: ::fidl_next::Encodable<Encoded = crate::WireTable<'static>>,

            T4: ::fidl_next::Encodable<Encoded = crate::WireUnion>,

            T5: ::fidl_next::Encodable<Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>>,

            T6: ::fidl_next::Encodable<Encoded = crate::WireOptionalUnion>,
        {
            type Encoded = crate::WireCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for TwoWayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = crate::WireBits>,

            T1: ::fidl_next::Encode<___E, Encoded = crate::WireEnum>,

            T2: ::fidl_next::Encode<___E, Encoded = crate::WireStruct>,

            T3: ::fidl_next::Encode<___E, Encoded = crate::WireTable<'static>>,

            T4: ::fidl_next::Encode<___E, Encoded = crate::WireUnion>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>,
            >,

            T6: ::fidl_next::Encode<___E, Encoded = crate::WireOptionalUnion>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        bits,
                        enum_,
                        struct_,
                        table,
                        union,
                        opt_struct,
                        opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.bits, encoder, bits)?;

                ::fidl_next::Encode::encode(self.enum_, encoder, enum_)?;

                ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

                ::fidl_next::Encode::encode(self.table, encoder, table)?;

                ::fidl_next::Encode::encode(self.union, encoder, union)?;

                ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

                ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

                Ok(())
            }
        }

        pub struct EventCompound<T0, T1, T2, T3, T4, T5, T6> {
            bits: T0,

            enum_: T1,

            struct_: T2,

            table: T3,

            union: T4,

            opt_struct: T5,

            opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for EventCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = crate::WireBits>,

            T1: ::fidl_next::Encodable<Encoded = crate::WireEnum>,

            T2: ::fidl_next::Encodable<Encoded = crate::WireStruct>,

            T3: ::fidl_next::Encodable<Encoded = crate::WireTable<'static>>,

            T4: ::fidl_next::Encodable<Encoded = crate::WireUnion>,

            T5: ::fidl_next::Encodable<Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>>,

            T6: ::fidl_next::Encodable<Encoded = crate::WireOptionalUnion>,
        {
            type Encoded = crate::WireCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for EventCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = crate::WireBits>,

            T1: ::fidl_next::Encode<___E, Encoded = crate::WireEnum>,

            T2: ::fidl_next::Encode<___E, Encoded = crate::WireStruct>,

            T3: ::fidl_next::Encode<___E, Encoded = crate::WireTable<'static>>,

            T4: ::fidl_next::Encode<___E, Encoded = crate::WireUnion>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>,
            >,

            T6: ::fidl_next::Encode<___E, Encoded = crate::WireOptionalUnion>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        bits,
                        enum_,
                        struct_,
                        table,
                        union,
                        opt_struct,
                        opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.bits, encoder, bits)?;

                ::fidl_next::Encode::encode(self.enum_, encoder, enum_)?;

                ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

                ::fidl_next::Encode::encode(self.table, encoder, table)?;

                ::fidl_next::Encode::encode(self.union, encoder, union)?;

                ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

                ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

                Ok(())
            }
        }

        pub struct OneWayArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            array_uint8: T0,

            array_uint16: T1,

            array_uint32: T2,

            array_uint64: T3,

            array_int8: T4,

            array_int16: T5,

            array_int32: T6,

            array_int64: T7,

            array_float32: T8,

            array_float64: T9,

            array_string: T10,

            array_opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for OneWayArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = [u8; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU16; 5]>,

            T2: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU32; 5]>,

            T3: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU64; 5]>,

            T4: ::fidl_next::Encodable<Encoded = [i8; 5]>,

            T5: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI16; 5]>,

            T6: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI32; 5]>,

            T7: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI64; 5]>,

            T8: ::fidl_next::Encodable<Encoded = [::fidl_next::WireF32; 5]>,

            T9: ::fidl_next::Encodable<Encoded = [::fidl_next::WireF64; 5]>,

            T10: ::fidl_next::Encodable<Encoded = [::fidl_next::WireString<'static>; 5]>,

            T11: ::fidl_next::Encodable<Encoded = [::fidl_next::WireOptionalString<'static>; 5]>,
        {
            type Encoded = crate::WireArrayBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for OneWayArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [u8; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU16; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU32; 5]>,

            T3: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU64; 5]>,

            T4: ::fidl_next::Encode<___E, Encoded = [i8; 5]>,

            T5: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI16; 5]>,

            T6: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI32; 5]>,

            T7: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI64; 5]>,

            T8: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireF32; 5]>,

            T9: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireF64; 5]>,

            T10: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireString<'static>; 5]>,

            T11: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireOptionalString<'static>; 5]>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_uint8,
                        array_uint16,
                        array_uint32,
                        array_uint64,
                        array_int8,
                        array_int16,
                        array_int32,
                        array_int64,
                        array_float32,
                        array_float64,
                        array_string,
                        array_opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_uint8, encoder, array_uint8)?;

                ::fidl_next::Encode::encode(self.array_uint16, encoder, array_uint16)?;

                ::fidl_next::Encode::encode(self.array_uint32, encoder, array_uint32)?;

                ::fidl_next::Encode::encode(self.array_uint64, encoder, array_uint64)?;

                ::fidl_next::Encode::encode(self.array_int8, encoder, array_int8)?;

                ::fidl_next::Encode::encode(self.array_int16, encoder, array_int16)?;

                ::fidl_next::Encode::encode(self.array_int32, encoder, array_int32)?;

                ::fidl_next::Encode::encode(self.array_int64, encoder, array_int64)?;

                ::fidl_next::Encode::encode(self.array_float32, encoder, array_float32)?;

                ::fidl_next::Encode::encode(self.array_float64, encoder, array_float64)?;

                ::fidl_next::Encode::encode(self.array_string, encoder, array_string)?;

                ::fidl_next::Encode::encode(self.array_opt_string, encoder, array_opt_string)?;

                Ok(())
            }
        }

        pub struct TwoWayArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            array_uint8: T0,

            array_uint16: T1,

            array_uint32: T2,

            array_uint64: T3,

            array_int8: T4,

            array_int16: T5,

            array_int32: T6,

            array_int64: T7,

            array_float32: T8,

            array_float64: T9,

            array_string: T10,

            array_opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for TwoWayArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = [u8; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU16; 5]>,

            T2: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU32; 5]>,

            T3: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU64; 5]>,

            T4: ::fidl_next::Encodable<Encoded = [i8; 5]>,

            T5: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI16; 5]>,

            T6: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI32; 5]>,

            T7: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI64; 5]>,

            T8: ::fidl_next::Encodable<Encoded = [::fidl_next::WireF32; 5]>,

            T9: ::fidl_next::Encodable<Encoded = [::fidl_next::WireF64; 5]>,

            T10: ::fidl_next::Encodable<Encoded = [::fidl_next::WireString<'static>; 5]>,

            T11: ::fidl_next::Encodable<Encoded = [::fidl_next::WireOptionalString<'static>; 5]>,
        {
            type Encoded = crate::WireArrayBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for TwoWayArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [u8; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU16; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU32; 5]>,

            T3: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU64; 5]>,

            T4: ::fidl_next::Encode<___E, Encoded = [i8; 5]>,

            T5: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI16; 5]>,

            T6: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI32; 5]>,

            T7: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI64; 5]>,

            T8: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireF32; 5]>,

            T9: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireF64; 5]>,

            T10: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireString<'static>; 5]>,

            T11: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireOptionalString<'static>; 5]>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_uint8,
                        array_uint16,
                        array_uint32,
                        array_uint64,
                        array_int8,
                        array_int16,
                        array_int32,
                        array_int64,
                        array_float32,
                        array_float64,
                        array_string,
                        array_opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_uint8, encoder, array_uint8)?;

                ::fidl_next::Encode::encode(self.array_uint16, encoder, array_uint16)?;

                ::fidl_next::Encode::encode(self.array_uint32, encoder, array_uint32)?;

                ::fidl_next::Encode::encode(self.array_uint64, encoder, array_uint64)?;

                ::fidl_next::Encode::encode(self.array_int8, encoder, array_int8)?;

                ::fidl_next::Encode::encode(self.array_int16, encoder, array_int16)?;

                ::fidl_next::Encode::encode(self.array_int32, encoder, array_int32)?;

                ::fidl_next::Encode::encode(self.array_int64, encoder, array_int64)?;

                ::fidl_next::Encode::encode(self.array_float32, encoder, array_float32)?;

                ::fidl_next::Encode::encode(self.array_float64, encoder, array_float64)?;

                ::fidl_next::Encode::encode(self.array_string, encoder, array_string)?;

                ::fidl_next::Encode::encode(self.array_opt_string, encoder, array_opt_string)?;

                Ok(())
            }
        }

        pub struct EventArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            array_uint8: T0,

            array_uint16: T1,

            array_uint32: T2,

            array_uint64: T3,

            array_int8: T4,

            array_int16: T5,

            array_int32: T6,

            array_int64: T7,

            array_float32: T8,

            array_float64: T9,

            array_string: T10,

            array_opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for EventArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = [u8; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU16; 5]>,

            T2: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU32; 5]>,

            T3: ::fidl_next::Encodable<Encoded = [::fidl_next::WireU64; 5]>,

            T4: ::fidl_next::Encodable<Encoded = [i8; 5]>,

            T5: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI16; 5]>,

            T6: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI32; 5]>,

            T7: ::fidl_next::Encodable<Encoded = [::fidl_next::WireI64; 5]>,

            T8: ::fidl_next::Encodable<Encoded = [::fidl_next::WireF32; 5]>,

            T9: ::fidl_next::Encodable<Encoded = [::fidl_next::WireF64; 5]>,

            T10: ::fidl_next::Encodable<Encoded = [::fidl_next::WireString<'static>; 5]>,

            T11: ::fidl_next::Encodable<Encoded = [::fidl_next::WireOptionalString<'static>; 5]>,
        {
            type Encoded = crate::WireArrayBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for EventArrayBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [u8; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU16; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU32; 5]>,

            T3: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireU64; 5]>,

            T4: ::fidl_next::Encode<___E, Encoded = [i8; 5]>,

            T5: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI16; 5]>,

            T6: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI32; 5]>,

            T7: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireI64; 5]>,

            T8: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireF32; 5]>,

            T9: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireF64; 5]>,

            T10: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireString<'static>; 5]>,

            T11: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireOptionalString<'static>; 5]>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_uint8,
                        array_uint16,
                        array_uint32,
                        array_uint64,
                        array_int8,
                        array_int16,
                        array_int32,
                        array_int64,
                        array_float32,
                        array_float64,
                        array_string,
                        array_opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_uint8, encoder, array_uint8)?;

                ::fidl_next::Encode::encode(self.array_uint16, encoder, array_uint16)?;

                ::fidl_next::Encode::encode(self.array_uint32, encoder, array_uint32)?;

                ::fidl_next::Encode::encode(self.array_uint64, encoder, array_uint64)?;

                ::fidl_next::Encode::encode(self.array_int8, encoder, array_int8)?;

                ::fidl_next::Encode::encode(self.array_int16, encoder, array_int16)?;

                ::fidl_next::Encode::encode(self.array_int32, encoder, array_int32)?;

                ::fidl_next::Encode::encode(self.array_int64, encoder, array_int64)?;

                ::fidl_next::Encode::encode(self.array_float32, encoder, array_float32)?;

                ::fidl_next::Encode::encode(self.array_float64, encoder, array_float64)?;

                ::fidl_next::Encode::encode(self.array_string, encoder, array_string)?;

                ::fidl_next::Encode::encode(self.array_opt_string, encoder, array_opt_string)?;

                Ok(())
            }
        }

        pub struct OneWayArrayCompound<T0, T1, T2, T3, T4, T5, T6> {
            array_bits: T0,

            array_enum: T1,

            array_struct: T2,

            array_table: T3,

            array_union: T4,

            array_opt_struct: T5,

            array_opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for OneWayArrayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = [crate::WireBits; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [crate::WireEnum; 5]>,

            T2: ::fidl_next::Encodable<Encoded = [crate::WireStruct; 5]>,

            T3: ::fidl_next::Encodable<Encoded = [crate::WireTable<'static>; 5]>,

            T4: ::fidl_next::Encodable<Encoded = [crate::WireUnion; 5]>,

            T5: ::fidl_next::Encodable<
                Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
            >,

            T6: ::fidl_next::Encodable<Encoded = [crate::WireOptionalUnion; 5]>,
        {
            type Encoded = crate::WireArrayCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for OneWayArrayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [crate::WireBits; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [crate::WireEnum; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = [crate::WireStruct; 5]>,

            T3: ::fidl_next::Encode<___E, Encoded = [crate::WireTable<'static>; 5]>,

            T4: ::fidl_next::Encode<___E, Encoded = [crate::WireUnion; 5]>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
            >,

            T6: ::fidl_next::Encode<___E, Encoded = [crate::WireOptionalUnion; 5]>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_bits,
                        array_enum,
                        array_struct,
                        array_table,
                        array_union,
                        array_opt_struct,
                        array_opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_bits, encoder, array_bits)?;

                ::fidl_next::Encode::encode(self.array_enum, encoder, array_enum)?;

                ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

                ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

                ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

                ::fidl_next::Encode::encode(self.array_opt_struct, encoder, array_opt_struct)?;

                ::fidl_next::Encode::encode(self.array_opt_union, encoder, array_opt_union)?;

                Ok(())
            }
        }

        pub struct TwoWayArrayCompound<T0, T1, T2, T3, T4, T5, T6> {
            array_bits: T0,

            array_enum: T1,

            array_struct: T2,

            array_table: T3,

            array_union: T4,

            array_opt_struct: T5,

            array_opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for TwoWayArrayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = [crate::WireBits; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [crate::WireEnum; 5]>,

            T2: ::fidl_next::Encodable<Encoded = [crate::WireStruct; 5]>,

            T3: ::fidl_next::Encodable<Encoded = [crate::WireTable<'static>; 5]>,

            T4: ::fidl_next::Encodable<Encoded = [crate::WireUnion; 5]>,

            T5: ::fidl_next::Encodable<
                Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
            >,

            T6: ::fidl_next::Encodable<Encoded = [crate::WireOptionalUnion; 5]>,
        {
            type Encoded = crate::WireArrayCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for TwoWayArrayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [crate::WireBits; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [crate::WireEnum; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = [crate::WireStruct; 5]>,

            T3: ::fidl_next::Encode<___E, Encoded = [crate::WireTable<'static>; 5]>,

            T4: ::fidl_next::Encode<___E, Encoded = [crate::WireUnion; 5]>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
            >,

            T6: ::fidl_next::Encode<___E, Encoded = [crate::WireOptionalUnion; 5]>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_bits,
                        array_enum,
                        array_struct,
                        array_table,
                        array_union,
                        array_opt_struct,
                        array_opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_bits, encoder, array_bits)?;

                ::fidl_next::Encode::encode(self.array_enum, encoder, array_enum)?;

                ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

                ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

                ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

                ::fidl_next::Encode::encode(self.array_opt_struct, encoder, array_opt_struct)?;

                ::fidl_next::Encode::encode(self.array_opt_union, encoder, array_opt_union)?;

                Ok(())
            }
        }

        pub struct EventArrayCompound<T0, T1, T2, T3, T4, T5, T6> {
            array_bits: T0,

            array_enum: T1,

            array_struct: T2,

            array_table: T3,

            array_union: T4,

            array_opt_struct: T5,

            array_opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for EventArrayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = [crate::WireBits; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [crate::WireEnum; 5]>,

            T2: ::fidl_next::Encodable<Encoded = [crate::WireStruct; 5]>,

            T3: ::fidl_next::Encodable<Encoded = [crate::WireTable<'static>; 5]>,

            T4: ::fidl_next::Encodable<Encoded = [crate::WireUnion; 5]>,

            T5: ::fidl_next::Encodable<
                Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
            >,

            T6: ::fidl_next::Encodable<Encoded = [crate::WireOptionalUnion; 5]>,
        {
            type Encoded = crate::WireArrayCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for EventArrayCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [crate::WireBits; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [crate::WireEnum; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = [crate::WireStruct; 5]>,

            T3: ::fidl_next::Encode<___E, Encoded = [crate::WireTable<'static>; 5]>,

            T4: ::fidl_next::Encode<___E, Encoded = [crate::WireUnion; 5]>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
            >,

            T6: ::fidl_next::Encode<___E, Encoded = [crate::WireOptionalUnion; 5]>,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_bits,
                        array_enum,
                        array_struct,
                        array_table,
                        array_union,
                        array_opt_struct,
                        array_opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_bits, encoder, array_bits)?;

                ::fidl_next::Encode::encode(self.array_enum, encoder, array_enum)?;

                ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

                ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

                ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

                ::fidl_next::Encode::encode(self.array_opt_struct, encoder, array_opt_struct)?;

                ::fidl_next::Encode::encode(self.array_opt_union, encoder, array_opt_union)?;

                Ok(())
            }
        }

        pub struct OneWayVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            vector_uint8: T0,

            vector_uint16: T1,

            vector_uint32: T2,

            vector_uint64: T3,

            vector_int8: T4,

            vector_int16: T5,

            vector_int32: T6,

            vector_int64: T7,

            vector_float32: T8,

            vector_float64: T9,

            vector_string: T10,

            vector_opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for OneWayVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, u8>>,

            T1: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
            >,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
            >,

            T4: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, i8>>,

            T5: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
            >,

            T6: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
            >,

            T7: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
            >,

            T8: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
            >,

            T9: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
            >,

            T10: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >,

            T11: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireOptionalString<'static>,
                >,
            >,
        {
            type Encoded = crate::WireVectorBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for OneWayVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, u8>>,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
            >,

            T4: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, i8>>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
            >,

            T6: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
            >,

            T7: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
            >,

            T8: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
            >,

            T9: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
            >,

            T10: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >,

            T11: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireOptionalString<'static>,
                >,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        vector_uint8,
                        vector_uint16,
                        vector_uint32,
                        vector_uint64,
                        vector_int8,
                        vector_int16,
                        vector_int32,
                        vector_int64,
                        vector_float32,
                        vector_float64,
                        vector_string,
                        vector_opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.vector_uint8, encoder, vector_uint8)?;

                ::fidl_next::Encode::encode(self.vector_uint16, encoder, vector_uint16)?;

                ::fidl_next::Encode::encode(self.vector_uint32, encoder, vector_uint32)?;

                ::fidl_next::Encode::encode(self.vector_uint64, encoder, vector_uint64)?;

                ::fidl_next::Encode::encode(self.vector_int8, encoder, vector_int8)?;

                ::fidl_next::Encode::encode(self.vector_int16, encoder, vector_int16)?;

                ::fidl_next::Encode::encode(self.vector_int32, encoder, vector_int32)?;

                ::fidl_next::Encode::encode(self.vector_int64, encoder, vector_int64)?;

                ::fidl_next::Encode::encode(self.vector_float32, encoder, vector_float32)?;

                ::fidl_next::Encode::encode(self.vector_float64, encoder, vector_float64)?;

                ::fidl_next::Encode::encode(self.vector_string, encoder, vector_string)?;

                ::fidl_next::Encode::encode(self.vector_opt_string, encoder, vector_opt_string)?;

                Ok(())
            }
        }

        pub struct TwoWayVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            vector_uint8: T0,

            vector_uint16: T1,

            vector_uint32: T2,

            vector_uint64: T3,

            vector_int8: T4,

            vector_int16: T5,

            vector_int32: T6,

            vector_int64: T7,

            vector_float32: T8,

            vector_float64: T9,

            vector_string: T10,

            vector_opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for TwoWayVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, u8>>,

            T1: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
            >,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
            >,

            T4: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, i8>>,

            T5: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
            >,

            T6: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
            >,

            T7: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
            >,

            T8: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
            >,

            T9: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
            >,

            T10: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >,

            T11: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireOptionalString<'static>,
                >,
            >,
        {
            type Encoded = crate::WireVectorBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for TwoWayVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, u8>>,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
            >,

            T4: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, i8>>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
            >,

            T6: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
            >,

            T7: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
            >,

            T8: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
            >,

            T9: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
            >,

            T10: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >,

            T11: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireOptionalString<'static>,
                >,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        vector_uint8,
                        vector_uint16,
                        vector_uint32,
                        vector_uint64,
                        vector_int8,
                        vector_int16,
                        vector_int32,
                        vector_int64,
                        vector_float32,
                        vector_float64,
                        vector_string,
                        vector_opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.vector_uint8, encoder, vector_uint8)?;

                ::fidl_next::Encode::encode(self.vector_uint16, encoder, vector_uint16)?;

                ::fidl_next::Encode::encode(self.vector_uint32, encoder, vector_uint32)?;

                ::fidl_next::Encode::encode(self.vector_uint64, encoder, vector_uint64)?;

                ::fidl_next::Encode::encode(self.vector_int8, encoder, vector_int8)?;

                ::fidl_next::Encode::encode(self.vector_int16, encoder, vector_int16)?;

                ::fidl_next::Encode::encode(self.vector_int32, encoder, vector_int32)?;

                ::fidl_next::Encode::encode(self.vector_int64, encoder, vector_int64)?;

                ::fidl_next::Encode::encode(self.vector_float32, encoder, vector_float32)?;

                ::fidl_next::Encode::encode(self.vector_float64, encoder, vector_float64)?;

                ::fidl_next::Encode::encode(self.vector_string, encoder, vector_string)?;

                ::fidl_next::Encode::encode(self.vector_opt_string, encoder, vector_opt_string)?;

                Ok(())
            }
        }

        pub struct EventVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
            vector_uint8: T0,

            vector_uint16: T1,

            vector_uint32: T2,

            vector_uint64: T3,

            vector_int8: T4,

            vector_int16: T5,

            vector_int32: T6,

            vector_int64: T7,

            vector_float32: T8,

            vector_float64: T9,

            vector_string: T10,

            vector_opt_string: T11,
        }

        impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ::fidl_next::Encodable
            for EventVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, u8>>,

            T1: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
            >,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
            >,

            T4: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, i8>>,

            T5: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
            >,

            T6: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
            >,

            T7: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
            >,

            T8: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
            >,

            T9: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
            >,

            T10: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >,

            T11: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireOptionalString<'static>,
                >,
            >,
        {
            type Encoded = crate::WireVectorBasic<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
            ::fidl_next::Encode<___E>
            for EventVectorBasic<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, u8>>,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
            >,

            T4: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, i8>>,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
            >,

            T6: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
            >,

            T7: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
            >,

            T8: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
            >,

            T9: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
            >,

            T10: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >,

            T11: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireOptionalString<'static>,
                >,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        vector_uint8,
                        vector_uint16,
                        vector_uint32,
                        vector_uint64,
                        vector_int8,
                        vector_int16,
                        vector_int32,
                        vector_int64,
                        vector_float32,
                        vector_float64,
                        vector_string,
                        vector_opt_string,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.vector_uint8, encoder, vector_uint8)?;

                ::fidl_next::Encode::encode(self.vector_uint16, encoder, vector_uint16)?;

                ::fidl_next::Encode::encode(self.vector_uint32, encoder, vector_uint32)?;

                ::fidl_next::Encode::encode(self.vector_uint64, encoder, vector_uint64)?;

                ::fidl_next::Encode::encode(self.vector_int8, encoder, vector_int8)?;

                ::fidl_next::Encode::encode(self.vector_int16, encoder, vector_int16)?;

                ::fidl_next::Encode::encode(self.vector_int32, encoder, vector_int32)?;

                ::fidl_next::Encode::encode(self.vector_int64, encoder, vector_int64)?;

                ::fidl_next::Encode::encode(self.vector_float32, encoder, vector_float32)?;

                ::fidl_next::Encode::encode(self.vector_float64, encoder, vector_float64)?;

                ::fidl_next::Encode::encode(self.vector_string, encoder, vector_string)?;

                ::fidl_next::Encode::encode(self.vector_opt_string, encoder, vector_opt_string)?;

                Ok(())
            }
        }

        pub struct OneWayVectorCompound<T0, T1, T2, T3, T4, T5, T6> {
            vector_bits: T0,

            vector_enum: T1,

            vector_struct: T2,

            vector_table: T3,

            vector_union: T4,

            vector_opt_struct: T5,

            vector_opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for OneWayVectorCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, crate::WireBits>>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>>,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
            >,

            T4: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
            >,

            T5: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,

            T6: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
            >,
        {
            type Encoded = crate::WireVectorCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for OneWayVectorCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireBits>,
            >,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
            >,

            T4: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
            >,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,

            T6: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        vector_bits,
                        vector_enum,
                        vector_struct,
                        vector_table,
                        vector_union,
                        vector_opt_struct,
                        vector_opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.vector_bits, encoder, vector_bits)?;

                ::fidl_next::Encode::encode(self.vector_enum, encoder, vector_enum)?;

                ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

                ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

                ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

                ::fidl_next::Encode::encode(self.vector_opt_struct, encoder, vector_opt_struct)?;

                ::fidl_next::Encode::encode(self.vector_opt_union, encoder, vector_opt_union)?;

                Ok(())
            }
        }

        pub struct TwoWayVectorCompound<T0, T1, T2, T3, T4, T5, T6> {
            vector_bits: T0,

            vector_enum: T1,

            vector_struct: T2,

            vector_table: T3,

            vector_union: T4,

            vector_opt_struct: T5,

            vector_opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for TwoWayVectorCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, crate::WireBits>>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>>,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
            >,

            T4: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
            >,

            T5: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,

            T6: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
            >,
        {
            type Encoded = crate::WireVectorCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for TwoWayVectorCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireBits>,
            >,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
            >,

            T4: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
            >,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,

            T6: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        vector_bits,
                        vector_enum,
                        vector_struct,
                        vector_table,
                        vector_union,
                        vector_opt_struct,
                        vector_opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.vector_bits, encoder, vector_bits)?;

                ::fidl_next::Encode::encode(self.vector_enum, encoder, vector_enum)?;

                ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

                ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

                ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

                ::fidl_next::Encode::encode(self.vector_opt_struct, encoder, vector_opt_struct)?;

                ::fidl_next::Encode::encode(self.vector_opt_union, encoder, vector_opt_union)?;

                Ok(())
            }
        }

        pub struct EventVectorCompound<T0, T1, T2, T3, T4, T5, T6> {
            vector_bits: T0,

            vector_enum: T1,

            vector_struct: T2,

            vector_table: T3,

            vector_union: T4,

            vector_opt_struct: T5,

            vector_opt_union: T6,
        }

        impl<T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encodable
            for EventVectorCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, crate::WireBits>>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>>,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
            >,

            T4: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
            >,

            T5: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,

            T6: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
            >,
        {
            type Encoded = crate::WireVectorCompound<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3, T4, T5, T6> ::fidl_next::Encode<___E>
            for EventVectorCompound<T0, T1, T2, T3, T4, T5, T6>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireBits>,
            >,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
            >,

            T4: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
            >,

            T5: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,

            T6: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        vector_bits,
                        vector_enum,
                        vector_struct,
                        vector_table,
                        vector_union,
                        vector_opt_struct,
                        vector_opt_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.vector_bits, encoder, vector_bits)?;

                ::fidl_next::Encode::encode(self.vector_enum, encoder, vector_enum)?;

                ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

                ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

                ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

                ::fidl_next::Encode::encode(self.vector_opt_struct, encoder, vector_opt_struct)?;

                ::fidl_next::Encode::encode(self.vector_opt_union, encoder, vector_opt_union)?;

                Ok(())
            }
        }

        pub struct OneWayVectorOptional<T0, T1, T2, T3> {
            opt_vector_uint8: T0,

            opt_vector_string: T1,

            opt_vector_struct: T2,

            opt_vector_opt_struct: T3,
        }

        impl<T0, T1, T2, T3> ::fidl_next::Encodable for OneWayVectorOptional<T0, T1, T2, T3>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireOptionalVector<'static, u8>>,

            T1: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireString<'static>,
                >,
            >,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,
        {
            type Encoded = crate::WireVectorOptional<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3> ::fidl_next::Encode<___E> for OneWayVectorOptional<T0, T1, T2, T3>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireOptionalVector<'static, u8>>,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireString<'static>,
                >,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        opt_vector_uint8,
                        opt_vector_string,
                        opt_vector_struct,
                        opt_vector_opt_struct,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.opt_vector_uint8, encoder, opt_vector_uint8)?;

                ::fidl_next::Encode::encode(self.opt_vector_string, encoder, opt_vector_string)?;

                ::fidl_next::Encode::encode(self.opt_vector_struct, encoder, opt_vector_struct)?;

                ::fidl_next::Encode::encode(
                    self.opt_vector_opt_struct,
                    encoder,
                    opt_vector_opt_struct,
                )?;

                Ok(())
            }
        }

        pub struct TwoWayVectorOptional<T0, T1, T2, T3> {
            opt_vector_uint8: T0,

            opt_vector_string: T1,

            opt_vector_struct: T2,

            opt_vector_opt_struct: T3,
        }

        impl<T0, T1, T2, T3> ::fidl_next::Encodable for TwoWayVectorOptional<T0, T1, T2, T3>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireOptionalVector<'static, u8>>,

            T1: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireString<'static>,
                >,
            >,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,
        {
            type Encoded = crate::WireVectorOptional<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3> ::fidl_next::Encode<___E> for TwoWayVectorOptional<T0, T1, T2, T3>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireOptionalVector<'static, u8>>,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireString<'static>,
                >,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        opt_vector_uint8,
                        opt_vector_string,
                        opt_vector_struct,
                        opt_vector_opt_struct,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.opt_vector_uint8, encoder, opt_vector_uint8)?;

                ::fidl_next::Encode::encode(self.opt_vector_string, encoder, opt_vector_string)?;

                ::fidl_next::Encode::encode(self.opt_vector_struct, encoder, opt_vector_struct)?;

                ::fidl_next::Encode::encode(
                    self.opt_vector_opt_struct,
                    encoder,
                    opt_vector_opt_struct,
                )?;

                Ok(())
            }
        }

        pub struct EventVectorOptional<T0, T1, T2, T3> {
            opt_vector_uint8: T0,

            opt_vector_string: T1,

            opt_vector_struct: T2,

            opt_vector_opt_struct: T3,
        }

        impl<T0, T1, T2, T3> ::fidl_next::Encodable for EventVectorOptional<T0, T1, T2, T3>
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::WireOptionalVector<'static, u8>>,

            T1: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireString<'static>,
                >,
            >,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,
        {
            type Encoded = crate::WireVectorOptional<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3> ::fidl_next::Encode<___E> for EventVectorOptional<T0, T1, T2, T3>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireOptionalVector<'static, u8>>,

            T1: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireString<'static>,
                >,
            >,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireOptionalVector<
                    'static,
                    ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        opt_vector_uint8,
                        opt_vector_string,
                        opt_vector_struct,
                        opt_vector_opt_struct,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.opt_vector_uint8, encoder, opt_vector_uint8)?;

                ::fidl_next::Encode::encode(self.opt_vector_string, encoder, opt_vector_string)?;

                ::fidl_next::Encode::encode(self.opt_vector_struct, encoder, opt_vector_struct)?;

                ::fidl_next::Encode::encode(
                    self.opt_vector_opt_struct,
                    encoder,
                    opt_vector_opt_struct,
                )?;

                Ok(())
            }
        }

        pub struct OneWayArrayVectorNested<T0, T1, T2, T3> {
            array_array_uint8: T0,

            array_vector_uint8: T1,

            vector_array_uint8: T2,

            vector_vector_uint8: T3,
        }

        impl<T0, T1, T2, T3> ::fidl_next::Encodable for OneWayArrayVectorNested<T0, T1, T2, T3>
        where
            T0: ::fidl_next::Encodable<Encoded = [[u8; 5]; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [::fidl_next::WireVector<'static, u8>; 5]>,

            T2: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, [u8; 5]>>,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireVector<'static, u8>>,
            >,
        {
            type Encoded = crate::WireArrayVectorNested<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3> ::fidl_next::Encode<___E>
            for OneWayArrayVectorNested<T0, T1, T2, T3>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [[u8; 5]; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireVector<'static, u8>; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, [u8; 5]>>,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireVector<'static, u8>>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_array_uint8,
                        array_vector_uint8,
                        vector_array_uint8,
                        vector_vector_uint8,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_array_uint8, encoder, array_array_uint8)?;

                ::fidl_next::Encode::encode(self.array_vector_uint8, encoder, array_vector_uint8)?;

                ::fidl_next::Encode::encode(self.vector_array_uint8, encoder, vector_array_uint8)?;

                ::fidl_next::Encode::encode(
                    self.vector_vector_uint8,
                    encoder,
                    vector_vector_uint8,
                )?;

                Ok(())
            }
        }

        pub struct TwoWayArrayVectorNested<T0, T1, T2, T3> {
            array_array_uint8: T0,

            array_vector_uint8: T1,

            vector_array_uint8: T2,

            vector_vector_uint8: T3,
        }

        impl<T0, T1, T2, T3> ::fidl_next::Encodable for TwoWayArrayVectorNested<T0, T1, T2, T3>
        where
            T0: ::fidl_next::Encodable<Encoded = [[u8; 5]; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [::fidl_next::WireVector<'static, u8>; 5]>,

            T2: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, [u8; 5]>>,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireVector<'static, u8>>,
            >,
        {
            type Encoded = crate::WireArrayVectorNested<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3> ::fidl_next::Encode<___E>
            for TwoWayArrayVectorNested<T0, T1, T2, T3>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [[u8; 5]; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireVector<'static, u8>; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, [u8; 5]>>,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireVector<'static, u8>>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_array_uint8,
                        array_vector_uint8,
                        vector_array_uint8,
                        vector_vector_uint8,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_array_uint8, encoder, array_array_uint8)?;

                ::fidl_next::Encode::encode(self.array_vector_uint8, encoder, array_vector_uint8)?;

                ::fidl_next::Encode::encode(self.vector_array_uint8, encoder, vector_array_uint8)?;

                ::fidl_next::Encode::encode(
                    self.vector_vector_uint8,
                    encoder,
                    vector_vector_uint8,
                )?;

                Ok(())
            }
        }

        pub struct EventArrayVectorNested<T0, T1, T2, T3> {
            array_array_uint8: T0,

            array_vector_uint8: T1,

            vector_array_uint8: T2,

            vector_vector_uint8: T3,
        }

        impl<T0, T1, T2, T3> ::fidl_next::Encodable for EventArrayVectorNested<T0, T1, T2, T3>
        where
            T0: ::fidl_next::Encodable<Encoded = [[u8; 5]; 5]>,

            T1: ::fidl_next::Encodable<Encoded = [::fidl_next::WireVector<'static, u8>; 5]>,

            T2: ::fidl_next::Encodable<Encoded = ::fidl_next::WireVector<'static, [u8; 5]>>,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireVector<'static, u8>>,
            >,
        {
            type Encoded = crate::WireArrayVectorNested<'static>;
        }

        unsafe impl<___E, T0, T1, T2, T3> ::fidl_next::Encode<___E>
            for EventArrayVectorNested<T0, T1, T2, T3>
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            T0: ::fidl_next::Encode<___E, Encoded = [[u8; 5]; 5]>,

            T1: ::fidl_next::Encode<___E, Encoded = [::fidl_next::WireVector<'static, u8>; 5]>,

            T2: ::fidl_next::Encode<___E, Encoded = ::fidl_next::WireVector<'static, [u8; 5]>>,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireVector<'static, u8>>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        array_array_uint8,
                        array_vector_uint8,
                        vector_array_uint8,
                        vector_vector_uint8,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.array_array_uint8, encoder, array_array_uint8)?;

                ::fidl_next::Encode::encode(self.array_vector_uint8, encoder, array_vector_uint8)?;

                ::fidl_next::Encode::encode(self.vector_array_uint8, encoder, vector_array_uint8)?;

                ::fidl_next::Encode::encode(
                    self.vector_vector_uint8,
                    encoder,
                    vector_vector_uint8,
                )?;

                Ok(())
            }
        }

        pub struct OneWayResource<
            T0,
            T1,
            T2,
            T3,
            T4,
            T5,
            T6,
            T7,
            T8,
            T9,
            T10,
            T11,
            T12,
            T13,
            T14,
            T15,
            T16,
            T17,
            T18,
            T19,
            T20,
            T21,
            T22,
            T23,
            T24,
            T25,
            T26,
        > {
            handle: T0,

            vmo: T1,

            client_end: T2,

            server_end: T3,

            struct_: T4,

            table: T5,

            union: T6,

            opt_handle: T7,

            opt_vmo: T8,

            opt_client_end: T9,

            opt_server_end: T10,

            opt_struct: T11,

            opt_union: T12,

            array_handle: T13,

            array_vmo: T14,

            array_client_end: T15,

            array_server_end: T16,

            array_struct: T17,

            array_table: T18,

            array_union: T19,

            vector_handle: T20,

            vector_vmo: T21,

            vector_client_end: T22,

            vector_server_end: T23,

            vector_struct: T24,

            vector_table: T25,

            vector_union: T26,
        }

        impl<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            > ::fidl_next::Encodable
            for OneWayResource<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            >
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireHandle>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireHandle>,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T4: ::fidl_next::Encodable<Encoded = crate::WireResourceStruct>,

            T5: ::fidl_next::Encodable<Encoded = crate::WireResourceTable<'static>>,

            T6: ::fidl_next::Encodable<Encoded = crate::WireResourceUnion>,

            T7: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T8: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T9: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T10: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T11: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
            >,

            T12: ::fidl_next::Encodable<Encoded = crate::WireOptionalResourceUnion>,

            T13: ::fidl_next::Encodable<Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T14: ::fidl_next::Encodable<Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T15: ::fidl_next::Encodable<
                Encoded = [::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T16: ::fidl_next::Encodable<
                Encoded = [::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T17: ::fidl_next::Encodable<Encoded = [crate::WireResourceStruct; 5]>,

            T18: ::fidl_next::Encodable<Encoded = [crate::WireResourceTable<'static>; 5]>,

            T19: ::fidl_next::Encodable<Encoded = [crate::WireResourceUnion; 5]>,

            T20: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T21: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T22: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T23: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T24: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
            >,

            T25: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
            >,

            T26: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
            >,
        {
            type Encoded = crate::WireResource<'static>;
        }

        unsafe impl<
                ___E,
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            > ::fidl_next::Encode<___E>
            for OneWayResource<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            >
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireHandle>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireHandle>,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T4: ::fidl_next::Encode<___E, Encoded = crate::WireResourceStruct>,

            T5: ::fidl_next::Encode<___E, Encoded = crate::WireResourceTable<'static>>,

            T6: ::fidl_next::Encode<___E, Encoded = crate::WireResourceUnion>,

            T7: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T8: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T9: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T10: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T11: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
            >,

            T12: ::fidl_next::Encode<___E, Encoded = crate::WireOptionalResourceUnion>,

            T13: ::fidl_next::Encode<___E, Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T14: ::fidl_next::Encode<___E, Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T15: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T16: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T17: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceStruct; 5]>,

            T18: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceTable<'static>; 5]>,

            T19: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceUnion; 5]>,

            T20: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T21: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T22: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T23: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T24: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
            >,

            T25: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
            >,

            T26: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        handle,
                        vmo,
                        client_end,
                        server_end,
                        struct_,
                        table,
                        union,
                        opt_handle,
                        opt_vmo,
                        opt_client_end,
                        opt_server_end,
                        opt_struct,
                        opt_union,
                        array_handle,
                        array_vmo,
                        array_client_end,
                        array_server_end,
                        array_struct,
                        array_table,
                        array_union,
                        vector_handle,
                        vector_vmo,
                        vector_client_end,
                        vector_server_end,
                        vector_struct,
                        vector_table,
                        vector_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.handle, encoder, handle)?;

                ::fidl_next::Encode::encode(self.vmo, encoder, vmo)?;

                ::fidl_next::Encode::encode(self.client_end, encoder, client_end)?;

                ::fidl_next::Encode::encode(self.server_end, encoder, server_end)?;

                ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

                ::fidl_next::Encode::encode(self.table, encoder, table)?;

                ::fidl_next::Encode::encode(self.union, encoder, union)?;

                ::fidl_next::Encode::encode(self.opt_handle, encoder, opt_handle)?;

                ::fidl_next::Encode::encode(self.opt_vmo, encoder, opt_vmo)?;

                ::fidl_next::Encode::encode(self.opt_client_end, encoder, opt_client_end)?;

                ::fidl_next::Encode::encode(self.opt_server_end, encoder, opt_server_end)?;

                ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

                ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

                ::fidl_next::Encode::encode(self.array_handle, encoder, array_handle)?;

                ::fidl_next::Encode::encode(self.array_vmo, encoder, array_vmo)?;

                ::fidl_next::Encode::encode(self.array_client_end, encoder, array_client_end)?;

                ::fidl_next::Encode::encode(self.array_server_end, encoder, array_server_end)?;

                ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

                ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

                ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

                ::fidl_next::Encode::encode(self.vector_handle, encoder, vector_handle)?;

                ::fidl_next::Encode::encode(self.vector_vmo, encoder, vector_vmo)?;

                ::fidl_next::Encode::encode(self.vector_client_end, encoder, vector_client_end)?;

                ::fidl_next::Encode::encode(self.vector_server_end, encoder, vector_server_end)?;

                ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

                ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

                ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

                Ok(())
            }
        }

        pub struct TwoWayResource<
            T0,
            T1,
            T2,
            T3,
            T4,
            T5,
            T6,
            T7,
            T8,
            T9,
            T10,
            T11,
            T12,
            T13,
            T14,
            T15,
            T16,
            T17,
            T18,
            T19,
            T20,
            T21,
            T22,
            T23,
            T24,
            T25,
            T26,
        > {
            handle: T0,

            vmo: T1,

            client_end: T2,

            server_end: T3,

            struct_: T4,

            table: T5,

            union: T6,

            opt_handle: T7,

            opt_vmo: T8,

            opt_client_end: T9,

            opt_server_end: T10,

            opt_struct: T11,

            opt_union: T12,

            array_handle: T13,

            array_vmo: T14,

            array_client_end: T15,

            array_server_end: T16,

            array_struct: T17,

            array_table: T18,

            array_union: T19,

            vector_handle: T20,

            vector_vmo: T21,

            vector_client_end: T22,

            vector_server_end: T23,

            vector_struct: T24,

            vector_table: T25,

            vector_union: T26,
        }

        impl<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            > ::fidl_next::Encodable
            for TwoWayResource<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            >
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireHandle>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireHandle>,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T4: ::fidl_next::Encodable<Encoded = crate::WireResourceStruct>,

            T5: ::fidl_next::Encodable<Encoded = crate::WireResourceTable<'static>>,

            T6: ::fidl_next::Encodable<Encoded = crate::WireResourceUnion>,

            T7: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T8: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T9: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T10: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T11: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
            >,

            T12: ::fidl_next::Encodable<Encoded = crate::WireOptionalResourceUnion>,

            T13: ::fidl_next::Encodable<Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T14: ::fidl_next::Encodable<Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T15: ::fidl_next::Encodable<
                Encoded = [::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T16: ::fidl_next::Encodable<
                Encoded = [::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T17: ::fidl_next::Encodable<Encoded = [crate::WireResourceStruct; 5]>,

            T18: ::fidl_next::Encodable<Encoded = [crate::WireResourceTable<'static>; 5]>,

            T19: ::fidl_next::Encodable<Encoded = [crate::WireResourceUnion; 5]>,

            T20: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T21: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T22: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T23: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T24: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
            >,

            T25: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
            >,

            T26: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
            >,
        {
            type Encoded = crate::WireResource<'static>;
        }

        unsafe impl<
                ___E,
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            > ::fidl_next::Encode<___E>
            for TwoWayResource<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            >
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireHandle>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireHandle>,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T4: ::fidl_next::Encode<___E, Encoded = crate::WireResourceStruct>,

            T5: ::fidl_next::Encode<___E, Encoded = crate::WireResourceTable<'static>>,

            T6: ::fidl_next::Encode<___E, Encoded = crate::WireResourceUnion>,

            T7: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T8: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T9: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T10: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T11: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
            >,

            T12: ::fidl_next::Encode<___E, Encoded = crate::WireOptionalResourceUnion>,

            T13: ::fidl_next::Encode<___E, Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T14: ::fidl_next::Encode<___E, Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T15: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T16: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T17: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceStruct; 5]>,

            T18: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceTable<'static>; 5]>,

            T19: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceUnion; 5]>,

            T20: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T21: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T22: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T23: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T24: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
            >,

            T25: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
            >,

            T26: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        handle,
                        vmo,
                        client_end,
                        server_end,
                        struct_,
                        table,
                        union,
                        opt_handle,
                        opt_vmo,
                        opt_client_end,
                        opt_server_end,
                        opt_struct,
                        opt_union,
                        array_handle,
                        array_vmo,
                        array_client_end,
                        array_server_end,
                        array_struct,
                        array_table,
                        array_union,
                        vector_handle,
                        vector_vmo,
                        vector_client_end,
                        vector_server_end,
                        vector_struct,
                        vector_table,
                        vector_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.handle, encoder, handle)?;

                ::fidl_next::Encode::encode(self.vmo, encoder, vmo)?;

                ::fidl_next::Encode::encode(self.client_end, encoder, client_end)?;

                ::fidl_next::Encode::encode(self.server_end, encoder, server_end)?;

                ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

                ::fidl_next::Encode::encode(self.table, encoder, table)?;

                ::fidl_next::Encode::encode(self.union, encoder, union)?;

                ::fidl_next::Encode::encode(self.opt_handle, encoder, opt_handle)?;

                ::fidl_next::Encode::encode(self.opt_vmo, encoder, opt_vmo)?;

                ::fidl_next::Encode::encode(self.opt_client_end, encoder, opt_client_end)?;

                ::fidl_next::Encode::encode(self.opt_server_end, encoder, opt_server_end)?;

                ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

                ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

                ::fidl_next::Encode::encode(self.array_handle, encoder, array_handle)?;

                ::fidl_next::Encode::encode(self.array_vmo, encoder, array_vmo)?;

                ::fidl_next::Encode::encode(self.array_client_end, encoder, array_client_end)?;

                ::fidl_next::Encode::encode(self.array_server_end, encoder, array_server_end)?;

                ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

                ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

                ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

                ::fidl_next::Encode::encode(self.vector_handle, encoder, vector_handle)?;

                ::fidl_next::Encode::encode(self.vector_vmo, encoder, vector_vmo)?;

                ::fidl_next::Encode::encode(self.vector_client_end, encoder, vector_client_end)?;

                ::fidl_next::Encode::encode(self.vector_server_end, encoder, vector_server_end)?;

                ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

                ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

                ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

                Ok(())
            }
        }

        pub struct EventResource<
            T0,
            T1,
            T2,
            T3,
            T4,
            T5,
            T6,
            T7,
            T8,
            T9,
            T10,
            T11,
            T12,
            T13,
            T14,
            T15,
            T16,
            T17,
            T18,
            T19,
            T20,
            T21,
            T22,
            T23,
            T24,
            T25,
            T26,
        > {
            handle: T0,

            vmo: T1,

            client_end: T2,

            server_end: T3,

            struct_: T4,

            table: T5,

            union: T6,

            opt_handle: T7,

            opt_vmo: T8,

            opt_client_end: T9,

            opt_server_end: T10,

            opt_struct: T11,

            opt_union: T12,

            array_handle: T13,

            array_vmo: T14,

            array_client_end: T15,

            array_server_end: T16,

            array_struct: T17,

            array_table: T18,

            array_union: T19,

            vector_handle: T20,

            vector_vmo: T21,

            vector_client_end: T22,

            vector_server_end: T23,

            vector_struct: T24,

            vector_table: T25,

            vector_union: T26,
        }

        impl<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            > ::fidl_next::Encodable
            for EventResource<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            >
        where
            T0: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireHandle>,

            T1: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireHandle>,

            T2: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T3: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T4: ::fidl_next::Encodable<Encoded = crate::WireResourceStruct>,

            T5: ::fidl_next::Encodable<Encoded = crate::WireResourceTable<'static>>,

            T6: ::fidl_next::Encodable<Encoded = crate::WireResourceUnion>,

            T7: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T8: ::fidl_next::Encodable<Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T9: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T10: ::fidl_next::Encodable<
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T11: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
            >,

            T12: ::fidl_next::Encodable<Encoded = crate::WireOptionalResourceUnion>,

            T13: ::fidl_next::Encodable<Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T14: ::fidl_next::Encodable<Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T15: ::fidl_next::Encodable<
                Encoded = [::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T16: ::fidl_next::Encodable<
                Encoded = [::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T17: ::fidl_next::Encodable<Encoded = [crate::WireResourceStruct; 5]>,

            T18: ::fidl_next::Encodable<Encoded = [crate::WireResourceTable<'static>; 5]>,

            T19: ::fidl_next::Encodable<Encoded = [crate::WireResourceUnion; 5]>,

            T20: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T21: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T22: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T23: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T24: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
            >,

            T25: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
            >,

            T26: ::fidl_next::Encodable<
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
            >,
        {
            type Encoded = crate::WireResource<'static>;
        }

        unsafe impl<
                ___E,
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            > ::fidl_next::Encode<___E>
            for EventResource<
                T0,
                T1,
                T2,
                T3,
                T4,
                T5,
                T6,
                T7,
                T8,
                T9,
                T10,
                T11,
                T12,
                T13,
                T14,
                T15,
                T16,
                T17,
                T18,
                T19,
                T20,
                T21,
                T22,
                T23,
                T24,
                T25,
                T26,
            >
        where
            ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

            ___E: ::fidl_next::Encoder,

            ___E: ::fidl_next::fuchsia::HandleEncoder,

            T0: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireHandle>,

            T1: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireHandle>,

            T2: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T3: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >,
            >,

            T4: ::fidl_next::Encode<___E, Encoded = crate::WireResourceStruct>,

            T5: ::fidl_next::Encode<___E, Encoded = crate::WireResourceTable<'static>>,

            T6: ::fidl_next::Encode<___E, Encoded = crate::WireResourceUnion>,

            T7: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T8: ::fidl_next::Encode<___E, Encoded = ::fidl_next::fuchsia::WireOptionalHandle>,

            T9: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T10: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireOptionalChannel,
                >,
            >,

            T11: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
            >,

            T12: ::fidl_next::Encode<___E, Encoded = crate::WireOptionalResourceUnion>,

            T13: ::fidl_next::Encode<___E, Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T14: ::fidl_next::Encode<___E, Encoded = [::fidl_next::fuchsia::WireHandle; 5]>,

            T15: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::ClientEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T16: ::fidl_next::Encode<
                ___E,
                Encoded = [::fidl_next::ServerEnd<
                    crate::Protocol,
                    ::fidl_next::fuchsia::WireChannel,
                >; 5],
            >,

            T17: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceStruct; 5]>,

            T18: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceTable<'static>; 5]>,

            T19: ::fidl_next::Encode<___E, Encoded = [crate::WireResourceUnion; 5]>,

            T20: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T21: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
            >,

            T22: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T23: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<
                    'static,
                    ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                >,
            >,

            T24: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
            >,

            T25: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
            >,

            T26: ::fidl_next::Encode<
                ___E,
                Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
            >,
        {
            #[inline]
            fn encode(
                self,
                encoder: &mut ___E,
                out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
            ) -> Result<(), ::fidl_next::EncodeError> {
                ::fidl_next::munge! {
                    let Self::Encoded {
                        handle,
                        vmo,
                        client_end,
                        server_end,
                        struct_,
                        table,
                        union,
                        opt_handle,
                        opt_vmo,
                        opt_client_end,
                        opt_server_end,
                        opt_struct,
                        opt_union,
                        array_handle,
                        array_vmo,
                        array_client_end,
                        array_server_end,
                        array_struct,
                        array_table,
                        array_union,
                        vector_handle,
                        vector_vmo,
                        vector_client_end,
                        vector_server_end,
                        vector_struct,
                        vector_table,
                        vector_union,

                    } = out;
                }

                ::fidl_next::Encode::encode(self.handle, encoder, handle)?;

                ::fidl_next::Encode::encode(self.vmo, encoder, vmo)?;

                ::fidl_next::Encode::encode(self.client_end, encoder, client_end)?;

                ::fidl_next::Encode::encode(self.server_end, encoder, server_end)?;

                ::fidl_next::Encode::encode(self.struct_, encoder, struct_)?;

                ::fidl_next::Encode::encode(self.table, encoder, table)?;

                ::fidl_next::Encode::encode(self.union, encoder, union)?;

                ::fidl_next::Encode::encode(self.opt_handle, encoder, opt_handle)?;

                ::fidl_next::Encode::encode(self.opt_vmo, encoder, opt_vmo)?;

                ::fidl_next::Encode::encode(self.opt_client_end, encoder, opt_client_end)?;

                ::fidl_next::Encode::encode(self.opt_server_end, encoder, opt_server_end)?;

                ::fidl_next::Encode::encode(self.opt_struct, encoder, opt_struct)?;

                ::fidl_next::Encode::encode(self.opt_union, encoder, opt_union)?;

                ::fidl_next::Encode::encode(self.array_handle, encoder, array_handle)?;

                ::fidl_next::Encode::encode(self.array_vmo, encoder, array_vmo)?;

                ::fidl_next::Encode::encode(self.array_client_end, encoder, array_client_end)?;

                ::fidl_next::Encode::encode(self.array_server_end, encoder, array_server_end)?;

                ::fidl_next::Encode::encode(self.array_struct, encoder, array_struct)?;

                ::fidl_next::Encode::encode(self.array_table, encoder, array_table)?;

                ::fidl_next::Encode::encode(self.array_union, encoder, array_union)?;

                ::fidl_next::Encode::encode(self.vector_handle, encoder, vector_handle)?;

                ::fidl_next::Encode::encode(self.vector_vmo, encoder, vector_vmo)?;

                ::fidl_next::Encode::encode(self.vector_client_end, encoder, vector_client_end)?;

                ::fidl_next::Encode::encode(self.vector_server_end, encoder, vector_server_end)?;

                ::fidl_next::Encode::encode(self.vector_struct, encoder, vector_struct)?;

                ::fidl_next::Encode::encode(self.vector_table, encoder, vector_table)?;

                ::fidl_next::Encode::encode(self.vector_union, encoder, vector_union)?;

                Ok(())
            }
        }

        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::Protocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = ProtocolClientSender<___T>;
            type ServerSender = ProtocolServerSender<___T>;
        }

        /// The client sender for the `Protocol` protocol.
        pub struct ProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> ProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn one_way_basic(
                &self,

                uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = u8,
                >,

                uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU16,
                >,

                uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU32,
                >,

                uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU64,
                >,

                int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = i8,
                >,

                int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI16,
                >,

                int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI32,
                >,

                int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,

                float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireF32,
                >,

                float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireF64,
                >,

                string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireString<'static>,
                >,

                opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalString<'static>,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.one_way_basic_with(OneWayBasic {
                    uint8,

                    uint16,

                    uint32,

                    uint64,

                    int8,

                    int16,

                    int32,

                    int64,

                    float32,

                    float64,

                    string,

                    opt_string,
                })
            }

            pub fn one_way_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireBasic<'static>,
                >,
            {
                self.sender.send_one_way(8948968077914418681, request)
            }

            pub fn two_way_basic(
                &self,

                uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = u8,
                >,

                uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU16,
                >,

                uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU32,
                >,

                uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU64,
                >,

                int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = i8,
                >,

                int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI16,
                >,

                int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI32,
                >,

                int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,

                float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireF32,
                >,

                float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireF64,
                >,

                string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireString<'static>,
                >,

                opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalString<'static>,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayBasic, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.two_way_basic_with(TwoWayBasic {
                    uint8,

                    uint16,

                    uint32,

                    uint64,

                    int8,

                    int16,

                    int32,

                    int64,

                    float32,

                    float64,

                    string,

                    opt_string,
                })
            }

            pub fn two_way_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayBasic, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireBasic<'static>,
                >,
            {
                self.sender
                    .send_two_way(2331618702752598159, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_basic(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorBasic, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(5016634351643393939, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn one_way_compound(
                &self,

                bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireBits,
                >,

                enum_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireEnum,
                >,

                struct_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireStruct,
                >,

                table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireTable<'static>,
                >,

                union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireUnion,
                >,

                opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,

                opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireOptionalUnion,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.one_way_compound_with(OneWayCompound {
                    bits,

                    enum_,

                    struct_,

                    table,

                    union,

                    opt_struct,

                    opt_union,
                })
            }

            pub fn one_way_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireCompound<'static>,
                >,
            {
                self.sender.send_one_way(3153289648860022476, request)
            }

            pub fn two_way_compound(
                &self,

                bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireBits,
                >,

                enum_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireEnum,
                >,

                struct_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireStruct,
                >,

                table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireTable<'static>,
                >,

                union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireUnion,
                >,

                opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,

                opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireOptionalUnion,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayCompound, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.two_way_compound_with(TwoWayCompound {
                    bits,

                    enum_,

                    struct_,

                    table,

                    union,

                    opt_struct,

                    opt_union,
                })
            }

            pub fn two_way_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayCompound, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireCompound<'static>,
                >,
            {
                self.sender
                    .send_two_way(8787219719097524529, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_compound(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorCompound, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(2990809657626249085, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn one_way_array_basic(
                &self,

                array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [u8; 5],
                >,

                array_uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU16; 5],
                >,

                array_uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU32; 5],
                >,

                array_uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU64; 5],
                >,

                array_int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [i8; 5],
                >,

                array_int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI16; 5],
                >,

                array_int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI32; 5],
                >,

                array_int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI64; 5],
                >,

                array_float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireF32; 5],
                >,

                array_float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireF64; 5],
                >,

                array_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireString<'static>; 5],
                >,

                array_opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireOptionalString<'static>; 5],
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.one_way_array_basic_with(OneWayArrayBasic {
                    array_uint8,

                    array_uint16,

                    array_uint32,

                    array_uint64,

                    array_int8,

                    array_int16,

                    array_int32,

                    array_int64,

                    array_float32,

                    array_float64,

                    array_string,

                    array_opt_string,
                })
            }

            pub fn one_way_array_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireArrayBasic<'static>,
                >,
            {
                self.sender.send_one_way(7125516817014311449, request)
            }

            pub fn two_way_array_basic(
                &self,

                array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [u8; 5],
                >,

                array_uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU16; 5],
                >,

                array_uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU32; 5],
                >,

                array_uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU64; 5],
                >,

                array_int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [i8; 5],
                >,

                array_int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI16; 5],
                >,

                array_int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI32; 5],
                >,

                array_int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI64; 5],
                >,

                array_float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireF32; 5],
                >,

                array_float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireF64; 5],
                >,

                array_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireString<'static>; 5],
                >,

                array_opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireOptionalString<'static>; 5],
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayArrayBasic, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.two_way_array_basic_with(TwoWayArrayBasic {
                    array_uint8,

                    array_uint16,

                    array_uint32,

                    array_uint64,

                    array_int8,

                    array_int16,

                    array_int32,

                    array_int64,

                    array_float32,

                    array_float64,

                    array_string,

                    array_opt_string,
                })
            }

            pub fn two_way_array_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayArrayBasic, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireArrayBasic<'static>,
                >,
            {
                self.sender
                    .send_two_way(5309034178175279380, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_array_basic(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorArrayBasic, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1084731895342694265, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn one_way_array_compound(
                &self,

                array_bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireBits; 5],
                >,

                array_enum: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireEnum; 5],
                >,

                array_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireStruct; 5],
                >,

                array_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireTable<'static>; 5],
                >,

                array_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireUnion; 5],
                >,

                array_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
                >,

                array_opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireOptionalUnion; 5],
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.one_way_array_compound_with(OneWayArrayCompound {
                    array_bits,

                    array_enum,

                    array_struct,

                    array_table,

                    array_union,

                    array_opt_struct,

                    array_opt_union,
                })
            }

            pub fn one_way_array_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireArrayCompound<'static>,
                >,
            {
                self.sender.send_one_way(5064659223443251357, request)
            }

            pub fn two_way_array_compound(
                &self,

                array_bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireBits; 5],
                >,

                array_enum: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireEnum; 5],
                >,

                array_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireStruct; 5],
                >,

                array_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireTable<'static>; 5],
                >,

                array_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireUnion; 5],
                >,

                array_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
                >,

                array_opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireOptionalUnion; 5],
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayArrayCompound, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.two_way_array_compound_with(TwoWayArrayCompound {
                    array_bits,

                    array_enum,

                    array_struct,

                    array_table,

                    array_union,

                    array_opt_struct,

                    array_opt_union,
                })
            }

            pub fn two_way_array_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayArrayCompound, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireArrayCompound<'static>,
                >,
            {
                self.sender
                    .send_two_way(849744466051983995, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_array_compound(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorArrayCompound, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(5919277476782807556, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn one_way_vector_basic(
                &self,

                vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, u8>,
                >,

                vector_uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
                >,

                vector_uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
                >,

                vector_uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
                >,

                vector_int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, i8>,
                >,

                vector_int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
                >,

                vector_int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
                >,

                vector_int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
                >,

                vector_float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
                >,

                vector_float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
                >,

                vector_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
                >,

                vector_opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireOptionalString<'static>,
                    >,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.one_way_vector_basic_with(OneWayVectorBasic {
                    vector_uint8,

                    vector_uint16,

                    vector_uint32,

                    vector_uint64,

                    vector_int8,

                    vector_int16,

                    vector_int32,

                    vector_int64,

                    vector_float32,

                    vector_float64,

                    vector_string,

                    vector_opt_string,
                })
            }

            pub fn one_way_vector_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireVectorBasic<'static>,
                >,
            {
                self.sender.send_one_way(5733220720079947351, request)
            }

            pub fn two_way_vector_basic(
                &self,

                vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, u8>,
                >,

                vector_uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
                >,

                vector_uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
                >,

                vector_uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
                >,

                vector_int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, i8>,
                >,

                vector_int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
                >,

                vector_int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
                >,

                vector_int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
                >,

                vector_float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
                >,

                vector_float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
                >,

                vector_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
                >,

                vector_opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireOptionalString<'static>,
                    >,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayVectorBasic, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.two_way_vector_basic_with(TwoWayVectorBasic {
                    vector_uint8,

                    vector_uint16,

                    vector_uint32,

                    vector_uint64,

                    vector_int8,

                    vector_int16,

                    vector_int32,

                    vector_int64,

                    vector_float32,

                    vector_float64,

                    vector_string,

                    vector_opt_string,
                })
            }

            pub fn two_way_vector_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayVectorBasic, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireVectorBasic<'static>,
                >,
            {
                self.sender
                    .send_two_way(8674156353091415668, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_vector_basic(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorVectorBasic, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(875941614196965234, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn one_way_vector_compound(
                &self,

                vector_bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireBits>,
                >,

                vector_enum: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>,
                >,

                vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
                >,

                vector_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
                >,

                vector_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
                >,

                vector_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireBox<'static, crate::WireStruct>,
                    >,
                >,

                vector_opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.one_way_vector_compound_with(OneWayVectorCompound {
                    vector_bits,

                    vector_enum,

                    vector_struct,

                    vector_table,

                    vector_union,

                    vector_opt_struct,

                    vector_opt_union,
                })
            }

            pub fn one_way_vector_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireVectorCompound<'static>,
                >,
            {
                self.sender.send_one_way(1853985797298830992, request)
            }

            pub fn two_way_vector_compound(
                &self,

                vector_bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireBits>,
                >,

                vector_enum: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>,
                >,

                vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
                >,

                vector_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
                >,

                vector_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
                >,

                vector_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireBox<'static, crate::WireStruct>,
                    >,
                >,

                vector_opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayVectorCompound, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.two_way_vector_compound_with(TwoWayVectorCompound {
                    vector_bits,

                    vector_enum,

                    vector_struct,

                    vector_table,

                    vector_union,

                    vector_opt_struct,

                    vector_opt_union,
                })
            }

            pub fn two_way_vector_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayVectorCompound, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireVectorCompound<'static>,
                >,
            {
                self.sender
                    .send_two_way(3968024057912959924, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_vector_compound(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorVectorCompound, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(8506780203315865989, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn one_way_vector_optional(
                &self,

                opt_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<'static, u8>,
                >,

                opt_vector_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<
                        'static,
                        ::fidl_next::WireString<'static>,
                    >,
                >,

                opt_vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
                >,

                opt_vector_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<
                        'static,
                        ::fidl_next::WireBox<'static, crate::WireStruct>,
                    >,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.one_way_vector_optional_with(OneWayVectorOptional {
                    opt_vector_uint8,

                    opt_vector_string,

                    opt_vector_struct,

                    opt_vector_opt_struct,
                })
            }

            pub fn one_way_vector_optional_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireVectorOptional<'static>,
                >,
            {
                self.sender.send_one_way(1530215841195476271, request)
            }

            pub fn two_way_vector_optional(
                &self,

                opt_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<'static, u8>,
                >,

                opt_vector_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<
                        'static,
                        ::fidl_next::WireString<'static>,
                    >,
                >,

                opt_vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
                >,

                opt_vector_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<
                        'static,
                        ::fidl_next::WireBox<'static, crate::WireStruct>,
                    >,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayVectorOptional, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.two_way_vector_optional_with(TwoWayVectorOptional {
                    opt_vector_uint8,

                    opt_vector_string,

                    opt_vector_struct,

                    opt_vector_opt_struct,
                })
            }

            pub fn two_way_vector_optional_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayVectorOptional, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireVectorOptional<'static>,
                >,
            {
                self.sender
                    .send_two_way(1030024737742222323, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_vector_optional(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorVectorOptional, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6406191217027936606, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn one_way_array_vector_nested(
                &self,

                array_array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [[u8; 5]; 5],
                >,

                array_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireVector<'static, u8>; 5],
                >,

                vector_array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, [u8; 5]>,
                >,

                vector_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireVector<'static, u8>,
                    >,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.one_way_array_vector_nested_with(OneWayArrayVectorNested {
                    array_array_uint8,

                    array_vector_uint8,

                    vector_array_uint8,

                    vector_vector_uint8,
                })
            }

            pub fn one_way_array_vector_nested_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireArrayVectorNested<'static>,
                >,
            {
                self.sender.send_one_way(5912603762133524183, request)
            }

            pub fn two_way_array_vector_nested(
                &self,

                array_array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [[u8; 5]; 5],
                >,

                array_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireVector<'static, u8>; 5],
                >,

                vector_array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, [u8; 5]>,
                >,

                vector_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireVector<'static, u8>,
                    >,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayArrayVectorNested, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.two_way_array_vector_nested_with(TwoWayArrayVectorNested {
                    array_array_uint8,

                    array_vector_uint8,

                    vector_array_uint8,

                    vector_vector_uint8,
                })
            }

            pub fn two_way_array_vector_nested_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayArrayVectorNested, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireArrayVectorNested<'static>,
                >,
            {
                self.sender
                    .send_two_way(5351275678438791132, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_array_vector_nested(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorArrayVectorNested, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(9085604921605802151, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn one_way_resource(
                &self,

                handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireHandle,
                >,

                vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireHandle,
                >,

                client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >,
                >,

                server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >,
                >,

                struct_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceStruct,
                >,

                table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceTable<'static>,
                >,

                union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceUnion,
                >,

                opt_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireOptionalHandle,
                >,

                opt_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireOptionalHandle,
                >,

                opt_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >,

                opt_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >,

                opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
                >,

                opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireOptionalResourceUnion,
                >,

                array_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::fuchsia::WireHandle; 5],
                >,

                array_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::fuchsia::WireHandle; 5],
                >,

                array_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >; 5],
                >,

                array_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >; 5],
                >,

                array_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceStruct; 5],
                >,

                array_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceTable<'static>; 5],
                >,

                array_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceUnion; 5],
                >,

                vector_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
                >,

                vector_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
                >,

                vector_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                    >,
                >,

                vector_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                    >,
                >,

                vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
                >,

                vector_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
                >,

                vector_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.one_way_resource_with(OneWayResource {
                    handle,

                    vmo,

                    client_end,

                    server_end,

                    struct_,

                    table,

                    union,

                    opt_handle,

                    opt_vmo,

                    opt_client_end,

                    opt_server_end,

                    opt_struct,

                    opt_union,

                    array_handle,

                    array_vmo,

                    array_client_end,

                    array_server_end,

                    array_struct,

                    array_table,

                    array_union,

                    vector_handle,

                    vector_vmo,

                    vector_client_end,

                    vector_server_end,

                    vector_struct,

                    vector_table,

                    vector_union,
                })
            }

            pub fn one_way_resource_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResource<'static>,
                >,
            {
                self.sender.send_one_way(6553996787849601058, request)
            }

            pub fn two_way_resource(
                &self,

                handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireHandle,
                >,

                vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireHandle,
                >,

                client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >,
                >,

                server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >,
                >,

                struct_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceStruct,
                >,

                table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceTable<'static>,
                >,

                union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceUnion,
                >,

                opt_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireOptionalHandle,
                >,

                opt_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireOptionalHandle,
                >,

                opt_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >,

                opt_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >,

                opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
                >,

                opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireOptionalResourceUnion,
                >,

                array_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::fuchsia::WireHandle; 5],
                >,

                array_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::fuchsia::WireHandle; 5],
                >,

                array_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >; 5],
                >,

                array_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >; 5],
                >,

                array_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceStruct; 5],
                >,

                array_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceTable<'static>; 5],
                >,

                array_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceUnion; 5],
                >,

                vector_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
                >,

                vector_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
                >,

                vector_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                    >,
                >,

                vector_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                    >,
                >,

                vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
                >,

                vector_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
                >,

                vector_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
                >,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayResource, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.two_way_resource_with(TwoWayResource {
                    handle,

                    vmo,

                    client_end,

                    server_end,

                    struct_,

                    table,

                    union,

                    opt_handle,

                    opt_vmo,

                    opt_client_end,

                    opt_server_end,

                    opt_struct,

                    opt_union,

                    array_handle,

                    array_vmo,

                    array_client_end,

                    array_server_end,

                    array_struct,

                    array_table,

                    array_union,

                    vector_handle,

                    vector_vmo,

                    vector_client_end,

                    vector_server_end,

                    vector_struct,

                    vector_table,

                    vector_union,
                })
            }

            pub fn two_way_resource_with<___R>(
                &self,
                request: ___R,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::TwoWayResource, ___T>,
                ::fidl_next::EncodeError,
            >
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResource<'static>,
                >,
            {
                self.sender
                    .send_two_way(1802709005492464987, request)
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn error_resource(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::ErrorResource, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6568609240497354166, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `Protocol` protocol.
        #[repr(transparent)]
        pub struct ProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> ProtocolServerSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn event_basic(
                &self,

                uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = u8,
                >,

                uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU16,
                >,

                uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU32,
                >,

                uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireU64,
                >,

                int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = i8,
                >,

                int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI16,
                >,

                int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI32,
                >,

                int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireI64,
                >,

                float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireF32,
                >,

                float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireF64,
                >,

                string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireString<'static>,
                >,

                opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalString<'static>,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.event_basic_with(EventBasic {
                    uint8,

                    uint16,

                    uint32,

                    uint64,

                    int8,

                    int16,

                    int32,

                    int64,

                    float32,

                    float64,

                    string,

                    opt_string,
                })
            }

            pub fn event_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventBasic as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(5892309624949902400, request)
            }

            pub fn event_compound(
                &self,

                bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireBits,
                >,

                enum_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireEnum,
                >,

                struct_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireStruct,
                >,

                table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireTable<'static>,
                >,

                union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireUnion,
                >,

                opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireBox<'static, crate::WireStruct>,
                >,

                opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireOptionalUnion,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.event_compound_with(EventCompound {
                    bits,

                    enum_,

                    struct_,

                    table,

                    union,

                    opt_struct,

                    opt_union,
                })
            }

            pub fn event_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventCompound as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(7024581948727571669, request)
            }

            pub fn event_array_basic(
                &self,

                array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [u8; 5],
                >,

                array_uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU16; 5],
                >,

                array_uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU32; 5],
                >,

                array_uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireU64; 5],
                >,

                array_int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [i8; 5],
                >,

                array_int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI16; 5],
                >,

                array_int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI32; 5],
                >,

                array_int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireI64; 5],
                >,

                array_float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireF32; 5],
                >,

                array_float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireF64; 5],
                >,

                array_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireString<'static>; 5],
                >,

                array_opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireOptionalString<'static>; 5],
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.event_array_basic_with(EventArrayBasic {
                    array_uint8,

                    array_uint16,

                    array_uint32,

                    array_uint64,

                    array_int8,

                    array_int16,

                    array_int32,

                    array_int64,

                    array_float32,

                    array_float64,

                    array_string,

                    array_opt_string,
                })
            }

            pub fn event_array_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventArrayBasic as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(5888282827283820590, request)
            }

            pub fn event_array_compound(
                &self,

                array_bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireBits; 5],
                >,

                array_enum: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireEnum; 5],
                >,

                array_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireStruct; 5],
                >,

                array_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireTable<'static>; 5],
                >,

                array_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireUnion; 5],
                >,

                array_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireBox<'static, crate::WireStruct>; 5],
                >,

                array_opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireOptionalUnion; 5],
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.event_array_compound_with(EventArrayCompound {
                    array_bits,

                    array_enum,

                    array_struct,

                    array_table,

                    array_union,

                    array_opt_struct,

                    array_opt_union,
                })
            }

            pub fn event_array_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventArrayCompound as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(2189769767733851157, request)
            }

            pub fn event_vector_basic(
                &self,

                vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, u8>,
                >,

                vector_uint16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU16>,
                >,

                vector_uint32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU32>,
                >,

                vector_uint64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireU64>,
                >,

                vector_int8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, i8>,
                >,

                vector_int16: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI16>,
                >,

                vector_int32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI32>,
                >,

                vector_int64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireI64>,
                >,

                vector_float32: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF32>,
                >,

                vector_float64: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireF64>,
                >,

                vector_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
                >,

                vector_opt_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireOptionalString<'static>,
                    >,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.event_vector_basic_with(EventVectorBasic {
                    vector_uint8,

                    vector_uint16,

                    vector_uint32,

                    vector_uint64,

                    vector_int8,

                    vector_int16,

                    vector_int32,

                    vector_int64,

                    vector_float32,

                    vector_float64,

                    vector_string,

                    vector_opt_string,
                })
            }

            pub fn event_vector_basic_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventVectorBasic as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(4583890770109526006, request)
            }

            pub fn event_vector_compound(
                &self,

                vector_bits: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireBits>,
                >,

                vector_enum: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireEnum>,
                >,

                vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireStruct>,
                >,

                vector_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireTable<'static>>,
                >,

                vector_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireUnion>,
                >,

                vector_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireBox<'static, crate::WireStruct>,
                    >,
                >,

                vector_opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireOptionalUnion>,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.event_vector_compound_with(EventVectorCompound {
                    vector_bits,

                    vector_enum,

                    vector_struct,

                    vector_table,

                    vector_union,

                    vector_opt_struct,

                    vector_opt_union,
                })
            }

            pub fn event_vector_compound_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventVectorCompound as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(6026375226599919603, request)
            }

            pub fn event_vector_optional(
                &self,

                opt_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<'static, u8>,
                >,

                opt_vector_string: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<
                        'static,
                        ::fidl_next::WireString<'static>,
                    >,
                >,

                opt_vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<'static, crate::WireStruct>,
                >,

                opt_vector_opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireOptionalVector<
                        'static,
                        ::fidl_next::WireBox<'static, crate::WireStruct>,
                    >,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.event_vector_optional_with(EventVectorOptional {
                    opt_vector_uint8,

                    opt_vector_string,

                    opt_vector_struct,

                    opt_vector_opt_struct,
                })
            }

            pub fn event_vector_optional_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventVectorOptional as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(1684763340073130077, request)
            }

            pub fn event_array_vector_nested(
                &self,

                array_array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [[u8; 5]; 5],
                >,

                array_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::WireVector<'static, u8>; 5],
                >,

                vector_array_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, [u8; 5]>,
                >,

                vector_vector_uint8: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::WireVector<'static, u8>,
                    >,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,
            {
                self.event_array_vector_nested_with(EventArrayVectorNested {
                    array_array_uint8,

                    array_vector_uint8,

                    vector_array_uint8,

                    vector_vector_uint8,
                })
            }

            pub fn event_array_vector_nested_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventArrayVectorNested as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(1228201560727880574, request)
            }

            pub fn event_resource(
                &self,

                handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireHandle,
                >,

                vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireHandle,
                >,

                client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >,
                >,

                server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >,
                >,

                struct_: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceStruct,
                >,

                table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceTable<'static>,
                >,

                union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireResourceUnion,
                >,

                opt_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireOptionalHandle,
                >,

                opt_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::fuchsia::WireOptionalHandle,
                >,

                opt_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >,

                opt_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireOptionalChannel,
                    >,
                >,

                opt_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireBox<'static, crate::WireResourceStruct>,
                >,

                opt_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = crate::WireOptionalResourceUnion,
                >,

                array_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::fuchsia::WireHandle; 5],
                >,

                array_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::fuchsia::WireHandle; 5],
                >,

                array_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::ClientEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >; 5],
                >,

                array_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [::fidl_next::ServerEnd<
                        crate::Protocol,
                        ::fidl_next::fuchsia::WireChannel,
                    >; 5],
                >,

                array_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceStruct; 5],
                >,

                array_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceTable<'static>; 5],
                >,

                array_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = [crate::WireResourceUnion; 5],
                >,

                vector_handle: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
                >,

                vector_vmo: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, ::fidl_next::fuchsia::WireHandle>,
                >,

                vector_client_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::ClientEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                    >,
                >,

                vector_server_end: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<
                        'static,
                        ::fidl_next::ServerEnd<crate::Protocol, ::fidl_next::fuchsia::WireChannel>,
                    >,
                >,

                vector_struct: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceStruct>,
                >,

                vector_table: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceTable<'static>>,
                >,

                vector_union: impl ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = ::fidl_next::WireVector<'static, crate::WireResourceUnion>,
                >,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                <___T as ::fidl_next::Transport>::SendBuffer:
                    ::fidl_next::encoder::InternalHandleEncoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::Encoder,

                <___T as ::fidl_next::Transport>::SendBuffer: ::fidl_next::fuchsia::HandleEncoder,
            {
                self.event_resource_with(EventResource {
                    handle,

                    vmo,

                    client_end,

                    server_end,

                    struct_,

                    table,

                    union,

                    opt_handle,

                    opt_vmo,

                    opt_client_end,

                    opt_server_end,

                    opt_struct,

                    opt_union,

                    array_handle,

                    array_vmo,

                    array_client_end,

                    array_server_end,

                    array_struct,

                    array_table,

                    array_union,

                    vector_handle,

                    vector_vmo,

                    vector_client_end,

                    vector_server_end,

                    vector_struct,

                    vector_table,

                    vector_union,
                })
            }

            pub fn event_resource_with<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::EventResource as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(5745997765922613643, request)
            }
        }
    }
}

/// A client handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn event_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventBasic, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn event_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventCompound, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn event_array_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventArrayBasic, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn event_array_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventArrayCompound, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn event_vector_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventVectorBasic, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn event_vector_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventVectorCompound, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn event_vector_optional(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventVectorOptional, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn event_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventArrayVectorNested, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn event_resource(
        &mut self,
        sender: &::fidl_next::ClientSender<Protocol, ___T>,

        event: ::fidl_next::Response<protocol::EventResource, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for Protocol
where
    ___H: ProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <protocol::TwoWayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5892309624949902400 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_basic(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            7024581948727571669 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_compound(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            5888282827283820590 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_array_basic(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            2189769767733851157 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_array_compound(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            4583890770109526006 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_vector_basic(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            6026375226599919603 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_vector_compound(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            1684763340073130077 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_vector_optional(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            1228201560727880574 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_array_vector_nested(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            5745997765922613643 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.event_resource(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn one_way_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayBasic, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayBasic, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayBasic>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorBasic>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn one_way_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayCompound, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayCompound, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayCompound>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorCompound>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn one_way_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayArrayBasic, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayArrayBasic, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayBasic>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayBasic>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn one_way_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayArrayCompound, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayArrayCompound, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayCompound>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayCompound>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn one_way_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayVectorBasic, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayVectorBasic, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorBasic>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorBasic>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn one_way_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayVectorCompound, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayVectorCompound, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorCompound>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorCompound>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn one_way_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayVectorOptional, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayVectorOptional, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorOptional>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorOptional>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn one_way_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayArrayVectorNested, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayArrayVectorNested, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayVectorNested>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayVectorNested>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn one_way_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::OneWayResource, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn two_way_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        request: ::fidl_next::Request<protocol::TwoWayResource, ___T>,

        responder: ::fidl_next::Responder<protocol::TwoWayResource>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn error_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<Protocol, ___T>,

        responder: ::fidl_next::Responder<protocol::ErrorResource>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for Protocol
where
    ___H: ProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <protocol::OneWayBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayArrayBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayArrayCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayVectorBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorBasic as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayVectorCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorCompound as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayVectorOptional as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorOptional as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayArrayVectorNested as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayVectorNested as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::OneWayResource as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayResource as ::fidl_next::Method>::Request:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            8948968077914418681 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_basic(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            3153289648860022476 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_compound(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            7125516817014311449 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_array_basic(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            5064659223443251357 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_array_compound(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            5733220720079947351 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_vector_basic(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            1853985797298830992 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_vector_compound(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            1530215841195476271 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_vector_optional(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            5912603762133524183 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_array_vector_nested(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            6553996787849601058 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.one_way_resource(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2331618702752598159 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_basic(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            5016634351643393939 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_basic(sender, responder).await;
            }

            8787219719097524529 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_compound(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            2990809657626249085 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_compound(sender, responder).await;
            }

            5309034178175279380 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_array_basic(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            1084731895342694265 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_basic(sender, responder).await;
            }

            849744466051983995 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_array_compound(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            5919277476782807556 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_compound(sender, responder).await;
            }

            8674156353091415668 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_vector_basic(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            875941614196965234 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_basic(sender, responder).await;
            }

            3968024057912959924 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => {
                        handler.two_way_vector_compound(sender, decoded, responder).await
                    }
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            8506780203315865989 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_compound(sender, responder).await;
            }

            1030024737742222323 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => {
                        handler.two_way_vector_optional(sender, decoded, responder).await
                    }
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            6406191217027936606 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_optional(sender, responder).await;
            }

            5351275678438791132 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => {
                        handler.two_way_array_vector_nested(sender, decoded, responder).await
                    }
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            9085604921605802151 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_vector_nested(sender, responder).await;
            }

            1802709005492464987 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                match ::fidl_next::DecoderExt::decode(buffer) {
                    Ok(decoded) => handler.two_way_resource(sender, decoded, responder).await,
                    Err(e) => {
                        sender.close();
                    }
                }
            }

            6568609240497354166 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_resource(sender, responder).await;
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::core::convert::From<crate::Bits> for ::fidl_test_typesinprotocols::Bits {
        #[inline]
        fn from(from: crate::Bits) -> Self {
            Self::from_bits_retain(from.bits())
        }
    }

    impl ::core::convert::From<crate::Enum> for ::fidl_test_typesinprotocols::Enum {
        #[inline]
        fn from(from: crate::Enum) -> Self {
            match crate::Enum::from(from) {
                crate::Enum::Val => Self::Val,

                crate::Enum::UnknownOrdinal_(value) => {
                    Self::__SourceBreaking { unknown_ordinal: value }
                }
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Protocol`
    /// protocol.
    pub type ProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Protocol>;

    impl ::core::convert::From<crate::Protocol> for ::fidl_test_typesinprotocols::ProtocolMarker {
        #[inline]
        fn from(_: crate::Protocol) -> Self {
            Self
        }
    }
}
