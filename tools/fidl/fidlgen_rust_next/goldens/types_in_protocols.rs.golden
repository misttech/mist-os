// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],

    pub array_uint16: [u16; 5],

    pub array_uint32: [u32; 5],

    pub array_uint64: [u64; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [i16; 5],

    pub array_int32: [i32; 5],

    pub array_int64: [i64; 5],

    pub array_float32: [f32; 5],

    pub array_float64: [f64; 5],

    pub array_string: [String; 5],

    pub array_opt_string: [Option<String>; 5],
}

impl ::fidl_next::Encodable for ArrayBasic {
    type Encoded = WireArrayBasic;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.array_uint8, encoder, array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.array_uint16, encoder, array_uint16)?;

        ::fidl_next::Encode::encode(&mut self.array_uint32, encoder, array_uint32)?;

        ::fidl_next::Encode::encode(&mut self.array_uint64, encoder, array_uint64)?;

        ::fidl_next::Encode::encode(&mut self.array_int8, encoder, array_int8)?;

        ::fidl_next::Encode::encode(&mut self.array_int16, encoder, array_int16)?;

        ::fidl_next::Encode::encode(&mut self.array_int32, encoder, array_int32)?;

        ::fidl_next::Encode::encode(&mut self.array_int64, encoder, array_int64)?;

        ::fidl_next::Encode::encode(&mut self.array_float32, encoder, array_float32)?;

        ::fidl_next::Encode::encode(&mut self.array_float64, encoder, array_float64)?;

        ::fidl_next::Encode::encode(&mut self.array_string, encoder, array_string)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_string, encoder, array_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayBasic> {
    type EncodedOption = ::fidl_next::WireBox<WireArrayBasic>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayBasic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayBasic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireArrayBasic> for ArrayBasic {
    #[inline]
    fn take_from(from: &WireArrayBasic) -> Self {
        Self {
            array_uint8: ::fidl_next::TakeFrom::take_from(&from.array_uint8),

            array_uint16: ::fidl_next::TakeFrom::take_from(&from.array_uint16),

            array_uint32: ::fidl_next::TakeFrom::take_from(&from.array_uint32),

            array_uint64: ::fidl_next::TakeFrom::take_from(&from.array_uint64),

            array_int8: ::fidl_next::TakeFrom::take_from(&from.array_int8),

            array_int16: ::fidl_next::TakeFrom::take_from(&from.array_int16),

            array_int32: ::fidl_next::TakeFrom::take_from(&from.array_int32),

            array_int64: ::fidl_next::TakeFrom::take_from(&from.array_int64),

            array_float32: ::fidl_next::TakeFrom::take_from(&from.array_float32),

            array_float64: ::fidl_next::TakeFrom::take_from(&from.array_float64),

            array_string: ::fidl_next::TakeFrom::take_from(&from.array_string),

            array_opt_string: ::fidl_next::TakeFrom::take_from(&from.array_opt_string),
        }
    }
}

/// The wire type corresponding to [`ArrayBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayBasic {
    pub array_uint8: [u8; 5],

    pub array_uint16: [::fidl_next::WireU16; 5],

    pub array_uint32: [::fidl_next::WireU32; 5],

    pub array_uint64: [::fidl_next::WireU64; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [::fidl_next::WireI16; 5],

    pub array_int32: [::fidl_next::WireI32; 5],

    pub array_int64: [::fidl_next::WireI64; 5],

    pub array_float32: [::fidl_next::WireF32; 5],

    pub array_float64: [::fidl_next::WireF64; 5],

    pub array_string: [::fidl_next::WireString; 5],

    pub array_opt_string: [::fidl_next::WireOptionalString; 5],
}

unsafe impl ::fidl_next::ZeroPadding for WireArrayBasic {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(180).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(116).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(85).write_bytes(0, 1);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(36).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(5).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayBasic
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_uint8,
                mut array_uint16,
                mut array_uint32,
                mut array_uint64,
                mut array_int8,
                mut array_int16,
                mut array_int32,
                mut array_int64,
                mut array_float32,
                mut array_float64,
                mut array_string,
                mut array_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Bits: u32 {
        const VAL = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Bits {
    type Encoded = WireBits;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Bits
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBits { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireBits> for Bits {
    fn from(wire: WireBits) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBits> for Bits {
    #[inline]
    fn take_from(from: &WireBits) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Bits`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBits {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireBits {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBits
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Bits> for WireBits {
    fn from(natural: Bits) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Enum {
    Val = 1,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for Enum {
    type Encoded = WireEnum;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Enum
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnum { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::Val => 1,

            Self::UnknownOrdinal_(value) => value,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireEnum> for Enum {
    fn from(wire: WireEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::Val,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireEnum> for Enum {
    #[inline]
    fn take_from(from: &WireEnum) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Enum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnum {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireEnum {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireEnum {
    pub const VAL: WireEnum = WireEnum { value: ::fidl_next::WireU32(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Enum> for WireEnum {
    fn from(natural: Enum) -> Self {
        match natural {
            Enum::Val => WireEnum::VAL,

            Enum::UnknownOrdinal_(value) => WireEnum { value: ::fidl_next::WireU32::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct Struct {}

impl ::fidl_next::Encodable for Struct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Struct> {
    type EncodedOption = ::fidl_next::WireBox<WireStruct>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Struct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStruct> for Struct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireStruct) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Struct`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireStruct {}

unsafe impl ::fidl_next::ZeroPadding for WireStruct {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Table {}

impl Table {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for Table {
    type Encoded = WireTable;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Table
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTable> for Table {
    #[inline]
    fn take_from(from: &WireTable) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Table`].
#[repr(C)]
pub struct WireTable {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireTable {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireTable {}

impl ::core::fmt::Debug for WireTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("Table").finish()
    }
}

#[derive(Clone, Debug)]
pub enum Union {
    B(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for Union {
    type Encoded = WireUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw } = out);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Union> {
    type EncodedOption = WireOptionalUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Union>
where
    ___E: ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnion> for Union {
    #[inline]
    fn take_from(from: &WireUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::B(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnion> for Option<Box<Union>> {
    #[inline]
    fn take_from(from: &WireOptionalUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireUnion {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union {
    pub enum Ref<'union> {
        B(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireUnion {
    pub fn as_ref(&self) -> crate::union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union::Ref::B(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalUnion {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnion { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct ArrayCompound {
    pub array_bits: [crate::Bits; 5],

    pub array_enum: [crate::Enum; 5],

    pub array_struct: [crate::Struct; 5],

    pub array_table: [crate::Table; 5],

    pub array_union: [crate::Union; 5],

    pub array_opt_struct: [Option<Box<crate::Struct>>; 5],

    pub array_opt_union: [Option<Box<crate::Union>>; 5],
}

impl ::fidl_next::Encodable for ArrayCompound {
    type Encoded = WireArrayCompound;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.array_bits, encoder, array_bits)?;

        ::fidl_next::Encode::encode(&mut self.array_enum, encoder, array_enum)?;

        ::fidl_next::Encode::encode(&mut self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(&mut self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_struct, encoder, array_opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_union, encoder, array_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayCompound> {
    type EncodedOption = ::fidl_next::WireBox<WireArrayCompound>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayCompound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayCompound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireArrayCompound> for ArrayCompound {
    #[inline]
    fn take_from(from: &WireArrayCompound) -> Self {
        Self {
            array_bits: ::fidl_next::TakeFrom::take_from(&from.array_bits),

            array_enum: ::fidl_next::TakeFrom::take_from(&from.array_enum),

            array_struct: ::fidl_next::TakeFrom::take_from(&from.array_struct),

            array_table: ::fidl_next::TakeFrom::take_from(&from.array_table),

            array_union: ::fidl_next::TakeFrom::take_from(&from.array_union),

            array_opt_struct: ::fidl_next::TakeFrom::take_from(&from.array_opt_struct),

            array_opt_union: ::fidl_next::TakeFrom::take_from(&from.array_opt_union),
        }
    }
}

/// The wire type corresponding to [`ArrayCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayCompound {
    pub array_bits: [crate::WireBits; 5],

    pub array_enum: [crate::WireEnum; 5],

    pub array_struct: [crate::WireStruct; 5],

    pub array_table: [crate::WireTable; 5],

    pub array_union: [crate::WireUnion; 5],

    pub array_opt_struct: [::fidl_next::WireBox<crate::WireStruct>; 5],

    pub array_opt_union: [crate::WireOptionalUnion; 5],
}

unsafe impl ::fidl_next::ZeroPadding for WireArrayCompound {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(45).write_bytes(0, 3);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayCompound
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_bits,
                mut array_enum,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut array_opt_struct,
                mut array_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ArrayVectorNested {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [Vec<u8>; 5],

    pub vector_array_uint8: Vec<[u8; 5]>,

    pub vector_vector_uint8: Vec<Vec<u8>>,
}

impl ::fidl_next::Encodable for ArrayVectorNested {
    type Encoded = WireArrayVectorNested;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.array_array_uint8, encoder, array_array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.array_vector_uint8, encoder, array_vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_array_uint8, encoder, vector_array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_vector_uint8, encoder, vector_vector_uint8)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayVectorNested> {
    type EncodedOption = ::fidl_next::WireBox<WireArrayVectorNested>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayVectorNested>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayVectorNested: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireArrayVectorNested> for ArrayVectorNested {
    #[inline]
    fn take_from(from: &WireArrayVectorNested) -> Self {
        Self {
            array_array_uint8: ::fidl_next::TakeFrom::take_from(&from.array_array_uint8),

            array_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.array_vector_uint8),

            vector_array_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_array_uint8),

            vector_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_vector_uint8),
        }
    }
}

/// The wire type corresponding to [`ArrayVectorNested`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayVectorNested {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [::fidl_next::WireVector<u8>; 5],

    pub vector_array_uint8: ::fidl_next::WireVector<[u8; 5]>,

    pub vector_vector_uint8: ::fidl_next::WireVector<::fidl_next::WireVector<u8>>,
}

unsafe impl ::fidl_next::ZeroPadding for WireArrayVectorNested {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(25).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireArrayVectorNested
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_array_uint8,
                mut array_vector_uint8,
                mut vector_array_uint8,
                mut vector_vector_uint8,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vector_uint8.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Basic {
    pub uint8: u8,

    pub uint16: u16,

    pub uint32: u32,

    pub uint64: u64,

    pub int8: i8,

    pub int16: i16,

    pub int32: i32,

    pub int64: i64,

    pub float32: f32,

    pub float64: f64,

    pub string: String,

    pub opt_string: Option<String>,
}

impl ::fidl_next::Encodable for Basic {
    type Encoded = WireBasic;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Basic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.uint8, encoder, uint8)?;

        ::fidl_next::Encode::encode(&mut self.uint16, encoder, uint16)?;

        ::fidl_next::Encode::encode(&mut self.uint32, encoder, uint32)?;

        ::fidl_next::Encode::encode(&mut self.uint64, encoder, uint64)?;

        ::fidl_next::Encode::encode(&mut self.int8, encoder, int8)?;

        ::fidl_next::Encode::encode(&mut self.int16, encoder, int16)?;

        ::fidl_next::Encode::encode(&mut self.int32, encoder, int32)?;

        ::fidl_next::Encode::encode(&mut self.int64, encoder, int64)?;

        ::fidl_next::Encode::encode(&mut self.float32, encoder, float32)?;

        ::fidl_next::Encode::encode(&mut self.float64, encoder, float64)?;

        ::fidl_next::Encode::encode(&mut self.string, encoder, string)?;

        ::fidl_next::Encode::encode(&mut self.opt_string, encoder, opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Basic> {
    type EncodedOption = ::fidl_next::WireBox<WireBasic>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Basic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Basic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireBasic> for Basic {
    #[inline]
    fn take_from(from: &WireBasic) -> Self {
        Self {
            uint8: ::fidl_next::TakeFrom::take_from(&from.uint8),

            uint16: ::fidl_next::TakeFrom::take_from(&from.uint16),

            uint32: ::fidl_next::TakeFrom::take_from(&from.uint32),

            uint64: ::fidl_next::TakeFrom::take_from(&from.uint64),

            int8: ::fidl_next::TakeFrom::take_from(&from.int8),

            int16: ::fidl_next::TakeFrom::take_from(&from.int16),

            int32: ::fidl_next::TakeFrom::take_from(&from.int32),

            int64: ::fidl_next::TakeFrom::take_from(&from.int64),

            float32: ::fidl_next::TakeFrom::take_from(&from.float32),

            float64: ::fidl_next::TakeFrom::take_from(&from.float64),

            string: ::fidl_next::TakeFrom::take_from(&from.string),

            opt_string: ::fidl_next::TakeFrom::take_from(&from.opt_string),
        }
    }
}

/// The wire type corresponding to [`Basic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireBasic {
    pub uint8: u8,

    pub uint16: ::fidl_next::WireU16,

    pub uint32: ::fidl_next::WireU32,

    pub uint64: ::fidl_next::WireU64,

    pub int8: i8,

    pub int16: ::fidl_next::WireI16,

    pub int32: ::fidl_next::WireI32,

    pub int64: ::fidl_next::WireI64,

    pub float32: ::fidl_next::WireF32,

    pub float64: ::fidl_next::WireF64,

    pub string: ::fidl_next::WireString,

    pub opt_string: ::fidl_next::WireOptionalString,
}

unsafe impl ::fidl_next::ZeroPadding for WireBasic {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(36).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(17).write_bytes(0, 1);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 1);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBasic
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut uint8,
                mut uint16,
                mut uint32,
                mut uint64,
                mut int8,
                mut int16,
                mut int32,
                mut int64,
                mut float32,
                mut float64,
                mut string,
                mut opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Compound {
    pub bits: crate::Bits,

    pub enum_: crate::Enum,

    pub struct_: crate::Struct,

    pub table: crate::Table,

    pub union: crate::Union,

    pub opt_struct: Option<Box<crate::Struct>>,

    pub opt_union: Option<Box<crate::Union>>,
}

impl ::fidl_next::Encodable for Compound {
    type Encoded = WireCompound;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Compound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits,
                enum_,
                struct_,
                table,
                union,
                opt_struct,
                opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.bits, encoder, bits)?;

        ::fidl_next::Encode::encode(&mut self.enum_, encoder, enum_)?;

        ::fidl_next::Encode::encode(&mut self.struct_, encoder, struct_)?;

        ::fidl_next::Encode::encode(&mut self.table, encoder, table)?;

        ::fidl_next::Encode::encode(&mut self.union, encoder, union)?;

        ::fidl_next::Encode::encode(&mut self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.opt_union, encoder, opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Compound> {
    type EncodedOption = ::fidl_next::WireBox<WireCompound>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Compound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Compound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireCompound> for Compound {
    #[inline]
    fn take_from(from: &WireCompound) -> Self {
        Self {
            bits: ::fidl_next::TakeFrom::take_from(&from.bits),

            enum_: ::fidl_next::TakeFrom::take_from(&from.enum_),

            struct_: ::fidl_next::TakeFrom::take_from(&from.struct_),

            table: ::fidl_next::TakeFrom::take_from(&from.table),

            union: ::fidl_next::TakeFrom::take_from(&from.union),

            opt_struct: ::fidl_next::TakeFrom::take_from(&from.opt_struct),

            opt_union: ::fidl_next::TakeFrom::take_from(&from.opt_union),
        }
    }
}

/// The wire type corresponding to [`Compound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireCompound {
    pub bits: crate::WireBits,

    pub enum_: crate::WireEnum,

    pub struct_: crate::WireStruct,

    pub table: crate::WireTable,

    pub union: crate::WireUnion,

    pub opt_struct: ::fidl_next::WireBox<crate::WireStruct>,

    pub opt_union: crate::WireOptionalUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireCompound {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(9).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireCompound
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits,
                mut enum_,
                mut struct_,
                mut table,
                mut union,
                mut opt_struct,
                mut opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(enum_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(struct_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,

    pub vector_uint16: Vec<u16>,

    pub vector_uint32: Vec<u32>,

    pub vector_uint64: Vec<u64>,

    pub vector_int8: Vec<i8>,

    pub vector_int16: Vec<i16>,

    pub vector_int32: Vec<i32>,

    pub vector_int64: Vec<i64>,

    pub vector_float32: Vec<f32>,

    pub vector_float64: Vec<f64>,

    pub vector_string: Vec<String>,

    pub vector_opt_string: Vec<Option<String>>,
}

impl ::fidl_next::Encodable for VectorBasic {
    type Encoded = WireVectorBasic;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.vector_uint8, encoder, vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint16, encoder, vector_uint16)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint32, encoder, vector_uint32)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint64, encoder, vector_uint64)?;

        ::fidl_next::Encode::encode(&mut self.vector_int8, encoder, vector_int8)?;

        ::fidl_next::Encode::encode(&mut self.vector_int16, encoder, vector_int16)?;

        ::fidl_next::Encode::encode(&mut self.vector_int32, encoder, vector_int32)?;

        ::fidl_next::Encode::encode(&mut self.vector_int64, encoder, vector_int64)?;

        ::fidl_next::Encode::encode(&mut self.vector_float32, encoder, vector_float32)?;

        ::fidl_next::Encode::encode(&mut self.vector_float64, encoder, vector_float64)?;

        ::fidl_next::Encode::encode(&mut self.vector_string, encoder, vector_string)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_string, encoder, vector_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorBasic> {
    type EncodedOption = ::fidl_next::WireBox<WireVectorBasic>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorBasic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorBasic: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireVectorBasic> for VectorBasic {
    #[inline]
    fn take_from(from: &WireVectorBasic) -> Self {
        Self {
            vector_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_uint8),

            vector_uint16: ::fidl_next::TakeFrom::take_from(&from.vector_uint16),

            vector_uint32: ::fidl_next::TakeFrom::take_from(&from.vector_uint32),

            vector_uint64: ::fidl_next::TakeFrom::take_from(&from.vector_uint64),

            vector_int8: ::fidl_next::TakeFrom::take_from(&from.vector_int8),

            vector_int16: ::fidl_next::TakeFrom::take_from(&from.vector_int16),

            vector_int32: ::fidl_next::TakeFrom::take_from(&from.vector_int32),

            vector_int64: ::fidl_next::TakeFrom::take_from(&from.vector_int64),

            vector_float32: ::fidl_next::TakeFrom::take_from(&from.vector_float32),

            vector_float64: ::fidl_next::TakeFrom::take_from(&from.vector_float64),

            vector_string: ::fidl_next::TakeFrom::take_from(&from.vector_string),

            vector_opt_string: ::fidl_next::TakeFrom::take_from(&from.vector_opt_string),
        }
    }
}

/// The wire type corresponding to [`VectorBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorBasic {
    pub vector_uint8: ::fidl_next::WireVector<u8>,

    pub vector_uint16: ::fidl_next::WireVector<::fidl_next::WireU16>,

    pub vector_uint32: ::fidl_next::WireVector<::fidl_next::WireU32>,

    pub vector_uint64: ::fidl_next::WireVector<::fidl_next::WireU64>,

    pub vector_int8: ::fidl_next::WireVector<i8>,

    pub vector_int16: ::fidl_next::WireVector<::fidl_next::WireI16>,

    pub vector_int32: ::fidl_next::WireVector<::fidl_next::WireI32>,

    pub vector_int64: ::fidl_next::WireVector<::fidl_next::WireI64>,

    pub vector_float32: ::fidl_next::WireVector<::fidl_next::WireF32>,

    pub vector_float64: ::fidl_next::WireVector<::fidl_next::WireF64>,

    pub vector_string: ::fidl_next::WireVector<::fidl_next::WireString>,

    pub vector_opt_string: ::fidl_next::WireVector<::fidl_next::WireOptionalString>,
}

unsafe impl ::fidl_next::ZeroPadding for WireVectorBasic {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorBasic
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_uint8,
                mut vector_uint16,
                mut vector_uint32,
                mut vector_uint64,
                mut vector_int8,
                mut vector_int16,
                mut vector_int32,
                mut vector_int64,
                mut vector_float32,
                mut vector_float64,
                mut vector_string,
                mut vector_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorCompound {
    pub vector_bits: Vec<crate::Bits>,

    pub vector_enum: Vec<crate::Enum>,

    pub vector_struct: Vec<crate::Struct>,

    pub vector_table: Vec<crate::Table>,

    pub vector_union: Vec<crate::Union>,

    pub vector_opt_struct: Vec<Option<Box<crate::Struct>>>,

    pub vector_opt_union: Vec<Option<Box<crate::Union>>>,
}

impl ::fidl_next::Encodable for VectorCompound {
    type Encoded = WireVectorCompound;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.vector_bits, encoder, vector_bits)?;

        ::fidl_next::Encode::encode(&mut self.vector_enum, encoder, vector_enum)?;

        ::fidl_next::Encode::encode(&mut self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(&mut self.vector_union, encoder, vector_union)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_struct, encoder, vector_opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_union, encoder, vector_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorCompound> {
    type EncodedOption = ::fidl_next::WireBox<WireVectorCompound>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorCompound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorCompound: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireVectorCompound> for VectorCompound {
    #[inline]
    fn take_from(from: &WireVectorCompound) -> Self {
        Self {
            vector_bits: ::fidl_next::TakeFrom::take_from(&from.vector_bits),

            vector_enum: ::fidl_next::TakeFrom::take_from(&from.vector_enum),

            vector_struct: ::fidl_next::TakeFrom::take_from(&from.vector_struct),

            vector_table: ::fidl_next::TakeFrom::take_from(&from.vector_table),

            vector_union: ::fidl_next::TakeFrom::take_from(&from.vector_union),

            vector_opt_struct: ::fidl_next::TakeFrom::take_from(&from.vector_opt_struct),

            vector_opt_union: ::fidl_next::TakeFrom::take_from(&from.vector_opt_union),
        }
    }
}

/// The wire type corresponding to [`VectorCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorCompound {
    pub vector_bits: ::fidl_next::WireVector<crate::WireBits>,

    pub vector_enum: ::fidl_next::WireVector<crate::WireEnum>,

    pub vector_struct: ::fidl_next::WireVector<crate::WireStruct>,

    pub vector_table: ::fidl_next::WireVector<crate::WireTable>,

    pub vector_union: ::fidl_next::WireVector<crate::WireUnion>,

    pub vector_opt_struct: ::fidl_next::WireVector<::fidl_next::WireBox<crate::WireStruct>>,

    pub vector_opt_union: ::fidl_next::WireVector<crate::WireOptionalUnion>,
}

unsafe impl ::fidl_next::ZeroPadding for WireVectorCompound {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorCompound
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_bits,
                mut vector_enum,
                mut vector_struct,
                mut vector_table,
                mut vector_union,
                mut vector_opt_struct,
                mut vector_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,

    pub opt_vector_string: Option<Vec<String>>,

    pub opt_vector_struct: Option<Vec<crate::Struct>>,

    pub opt_vector_opt_struct: Option<Vec<Option<Box<crate::Struct>>>>,
}

impl ::fidl_next::Encodable for VectorOptional {
    type Encoded = WireVectorOptional;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for VectorOptional
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.opt_vector_uint8, encoder, opt_vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.opt_vector_string, encoder, opt_vector_string)?;

        ::fidl_next::Encode::encode(&mut self.opt_vector_struct, encoder, opt_vector_struct)?;

        ::fidl_next::Encode::encode(
            &mut self.opt_vector_opt_struct,
            encoder,
            opt_vector_opt_struct,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorOptional> {
    type EncodedOption = ::fidl_next::WireBox<WireVectorOptional>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorOptional>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorOptional: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireVectorOptional> for VectorOptional {
    #[inline]
    fn take_from(from: &WireVectorOptional) -> Self {
        Self {
            opt_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.opt_vector_uint8),

            opt_vector_string: ::fidl_next::TakeFrom::take_from(&from.opt_vector_string),

            opt_vector_struct: ::fidl_next::TakeFrom::take_from(&from.opt_vector_struct),

            opt_vector_opt_struct: ::fidl_next::TakeFrom::take_from(&from.opt_vector_opt_struct),
        }
    }
}

/// The wire type corresponding to [`VectorOptional`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorOptional {
    pub opt_vector_uint8: ::fidl_next::WireOptionalVector<u8>,

    pub opt_vector_string: ::fidl_next::WireOptionalVector<::fidl_next::WireString>,

    pub opt_vector_struct: ::fidl_next::WireOptionalVector<crate::WireStruct>,

    pub opt_vector_opt_struct:
        ::fidl_next::WireOptionalVector<::fidl_next::WireBox<crate::WireStruct>>,
}

unsafe impl ::fidl_next::ZeroPadding for WireVectorOptional {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireVectorOptional
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut opt_vector_uint8,
                mut opt_vector_string,
                mut opt_vector_struct,
                mut opt_vector_opt_struct,

            } = slot;
        }

        ::fidl_next::Decode::decode(opt_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_opt_struct.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct ResourceStruct {}

impl ::fidl_next::Encodable for ResourceStruct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireResourceStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ResourceStruct> {
    type EncodedOption = ::fidl_next::WireBox<WireResourceStruct>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ResourceStruct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ResourceStruct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResourceStruct> for ResourceStruct {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireResourceStruct) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`ResourceStruct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResourceStruct {}

unsafe impl ::fidl_next::ZeroPadding for WireResourceStruct {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Debug)]
pub struct ResourceTable {}

impl ResourceTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for ResourceTable {
    type Encoded = WireResourceTable;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceTable
where
    ___E: ::fidl_next::Encoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceTable { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResourceTable> for ResourceTable {
    #[inline]
    fn take_from(from: &WireResourceTable) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`ResourceTable`].
#[repr(C)]
pub struct WireResourceTable {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireResourceTable {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceTable
where
    ___D: ::fidl_next::Decoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireResourceTable {}

impl ::core::fmt::Debug for WireResourceTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ResourceTable").finish()
    }
}

#[derive(Debug)]
pub enum ResourceUnion {
    B(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ResourceUnion {
    type Encoded = WireResourceUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ResourceUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceUnion { raw } = out);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ResourceUnion> {
    type EncodedOption = WireOptionalResourceUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ResourceUnion>
where
    ___E: ?Sized,
    ResourceUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalResourceUnion { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResourceUnion> for ResourceUnion {
    #[inline]
    fn take_from(from: &WireResourceUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::B(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalResourceUnion> for Option<Box<ResourceUnion>> {
    #[inline]
    fn take_from(from: &WireOptionalResourceUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ResourceUnion`].
#[repr(transparent)]
pub struct WireResourceUnion {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireResourceUnion {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod resource_union {
    pub enum Ref<'union> {
        B(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireResourceUnion {
    pub fn as_ref(&self) -> crate::resource_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::resource_union::Ref::B(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::resource_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalResourceUnion {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalResourceUnion {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalResourceUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireResourceUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalResourceUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct Resource {
    pub handle: ::fidl_next::fuchsia::zx::Handle,

    pub vmo: ::fidl_next::fuchsia::zx::Handle,

    pub client_end: ::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>,

    pub server_end: ::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>,

    pub struct_: crate::ResourceStruct,

    pub table: crate::ResourceTable,

    pub union: crate::ResourceUnion,

    pub opt_handle: Option<::fidl_next::fuchsia::zx::Handle>,

    pub opt_vmo: Option<::fidl_next::fuchsia::zx::Handle>,

    pub opt_client_end:
        ::fidl_next::ClientEnd<Option<::fidl_next::fuchsia::zx::Channel>, crate::Protocol>,

    pub opt_server_end:
        ::fidl_next::ServerEnd<Option<::fidl_next::fuchsia::zx::Channel>, crate::Protocol>,

    pub opt_struct: Option<Box<crate::ResourceStruct>>,

    pub opt_union: Option<Box<crate::ResourceUnion>>,

    pub array_handle: [::fidl_next::fuchsia::zx::Handle; 5],

    pub array_vmo: [::fidl_next::fuchsia::zx::Handle; 5],

    pub array_client_end:
        [::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>; 5],

    pub array_server_end:
        [::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>; 5],

    pub array_struct: [crate::ResourceStruct; 5],

    pub array_table: [crate::ResourceTable; 5],

    pub array_union: [crate::ResourceUnion; 5],

    pub vector_handle: Vec<::fidl_next::fuchsia::zx::Handle>,

    pub vector_vmo: Vec<::fidl_next::fuchsia::zx::Handle>,

    pub vector_client_end:
        Vec<::fidl_next::ClientEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>>,

    pub vector_server_end:
        Vec<::fidl_next::ServerEnd<::fidl_next::fuchsia::zx::Channel, crate::Protocol>>,

    pub vector_struct: Vec<crate::ResourceStruct>,

    pub vector_table: Vec<crate::ResourceTable>,

    pub vector_union: Vec<crate::ResourceUnion>,
}

impl ::fidl_next::Encodable for Resource {
    type Encoded = WireResource;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Resource
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.handle, encoder, handle)?;

        ::fidl_next::Encode::encode(&mut self.vmo, encoder, vmo)?;

        ::fidl_next::Encode::encode(&mut self.client_end, encoder, client_end)?;

        ::fidl_next::Encode::encode(&mut self.server_end, encoder, server_end)?;

        ::fidl_next::Encode::encode(&mut self.struct_, encoder, struct_)?;

        ::fidl_next::Encode::encode(&mut self.table, encoder, table)?;

        ::fidl_next::Encode::encode(&mut self.union, encoder, union)?;

        ::fidl_next::Encode::encode(&mut self.opt_handle, encoder, opt_handle)?;

        ::fidl_next::Encode::encode(&mut self.opt_vmo, encoder, opt_vmo)?;

        ::fidl_next::Encode::encode(&mut self.opt_client_end, encoder, opt_client_end)?;

        ::fidl_next::Encode::encode(&mut self.opt_server_end, encoder, opt_server_end)?;

        ::fidl_next::Encode::encode(&mut self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.opt_union, encoder, opt_union)?;

        ::fidl_next::Encode::encode(&mut self.array_handle, encoder, array_handle)?;

        ::fidl_next::Encode::encode(&mut self.array_vmo, encoder, array_vmo)?;

        ::fidl_next::Encode::encode(&mut self.array_client_end, encoder, array_client_end)?;

        ::fidl_next::Encode::encode(&mut self.array_server_end, encoder, array_server_end)?;

        ::fidl_next::Encode::encode(&mut self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(&mut self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(&mut self.vector_handle, encoder, vector_handle)?;

        ::fidl_next::Encode::encode(&mut self.vector_vmo, encoder, vector_vmo)?;

        ::fidl_next::Encode::encode(&mut self.vector_client_end, encoder, vector_client_end)?;

        ::fidl_next::Encode::encode(&mut self.vector_server_end, encoder, vector_server_end)?;

        ::fidl_next::Encode::encode(&mut self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(&mut self.vector_union, encoder, vector_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Resource> {
    type EncodedOption = ::fidl_next::WireBox<WireResource>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<Resource>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Resource: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResource> for Resource {
    #[inline]
    fn take_from(from: &WireResource) -> Self {
        Self {
            handle: ::fidl_next::TakeFrom::take_from(&from.handle),

            vmo: ::fidl_next::TakeFrom::take_from(&from.vmo),

            client_end: ::fidl_next::TakeFrom::take_from(&from.client_end),

            server_end: ::fidl_next::TakeFrom::take_from(&from.server_end),

            struct_: ::fidl_next::TakeFrom::take_from(&from.struct_),

            table: ::fidl_next::TakeFrom::take_from(&from.table),

            union: ::fidl_next::TakeFrom::take_from(&from.union),

            opt_handle: ::fidl_next::TakeFrom::take_from(&from.opt_handle),

            opt_vmo: ::fidl_next::TakeFrom::take_from(&from.opt_vmo),

            opt_client_end: ::fidl_next::TakeFrom::take_from(&from.opt_client_end),

            opt_server_end: ::fidl_next::TakeFrom::take_from(&from.opt_server_end),

            opt_struct: ::fidl_next::TakeFrom::take_from(&from.opt_struct),

            opt_union: ::fidl_next::TakeFrom::take_from(&from.opt_union),

            array_handle: ::fidl_next::TakeFrom::take_from(&from.array_handle),

            array_vmo: ::fidl_next::TakeFrom::take_from(&from.array_vmo),

            array_client_end: ::fidl_next::TakeFrom::take_from(&from.array_client_end),

            array_server_end: ::fidl_next::TakeFrom::take_from(&from.array_server_end),

            array_struct: ::fidl_next::TakeFrom::take_from(&from.array_struct),

            array_table: ::fidl_next::TakeFrom::take_from(&from.array_table),

            array_union: ::fidl_next::TakeFrom::take_from(&from.array_union),

            vector_handle: ::fidl_next::TakeFrom::take_from(&from.vector_handle),

            vector_vmo: ::fidl_next::TakeFrom::take_from(&from.vector_vmo),

            vector_client_end: ::fidl_next::TakeFrom::take_from(&from.vector_client_end),

            vector_server_end: ::fidl_next::TakeFrom::take_from(&from.vector_server_end),

            vector_struct: ::fidl_next::TakeFrom::take_from(&from.vector_struct),

            vector_table: ::fidl_next::TakeFrom::take_from(&from.vector_table),

            vector_union: ::fidl_next::TakeFrom::take_from(&from.vector_union),
        }
    }
}

/// The wire type corresponding to [`Resource`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResource {
    pub handle: ::fidl_next::fuchsia::WireHandle,

    pub vmo: ::fidl_next::fuchsia::WireHandle,

    pub client_end: ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>,

    pub server_end: ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>,

    pub struct_: crate::WireResourceStruct,

    pub table: crate::WireResourceTable,

    pub union: crate::WireResourceUnion,

    pub opt_handle: ::fidl_next::fuchsia::WireOptionalHandle,

    pub opt_vmo: ::fidl_next::fuchsia::WireOptionalHandle,

    pub opt_client_end:
        ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireOptionalChannel, crate::Protocol>,

    pub opt_server_end:
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireOptionalChannel, crate::Protocol>,

    pub opt_struct: ::fidl_next::WireBox<crate::WireResourceStruct>,

    pub opt_union: crate::WireOptionalResourceUnion,

    pub array_handle: [::fidl_next::fuchsia::WireHandle; 5],

    pub array_vmo: [::fidl_next::fuchsia::WireHandle; 5],

    pub array_client_end:
        [::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>; 5],

    pub array_server_end:
        [::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>; 5],

    pub array_struct: [crate::WireResourceStruct; 5],

    pub array_table: [crate::WireResourceTable; 5],

    pub array_union: [crate::WireResourceUnion; 5],

    pub vector_handle: ::fidl_next::WireVector<::fidl_next::fuchsia::WireHandle>,

    pub vector_vmo: ::fidl_next::WireVector<::fidl_next::fuchsia::WireHandle>,

    pub vector_client_end: ::fidl_next::WireVector<
        ::fidl_next::ClientEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>,
    >,

    pub vector_server_end: ::fidl_next::WireVector<
        ::fidl_next::ServerEnd<::fidl_next::fuchsia::WireChannel, crate::Protocol>,
    >,

    pub vector_struct: ::fidl_next::WireVector<crate::WireResourceStruct>,

    pub vector_table: ::fidl_next::WireVector<crate::WireResourceTable>,

    pub vector_union: ::fidl_next::WireVector<crate::WireResourceUnion>,
}

unsafe impl ::fidl_next::ZeroPadding for WireResource {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(181).write_bytes(0, 3);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(17).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResource
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut handle,
                mut vmo,
                mut client_end,
                mut server_end,
                mut struct_,
                mut table,
                mut union,
                mut opt_handle,
                mut opt_vmo,
                mut opt_client_end,
                mut opt_server_end,
                mut opt_struct,
                mut opt_union,
                mut array_handle,
                mut array_vmo,
                mut array_client_end,
                mut array_server_end,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut vector_handle,
                mut vector_vmo,
                mut vector_client_end,
                mut vector_server_end,
                mut vector_struct,
                mut vector_table,
                mut vector_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(struct_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the Protocol protocol.
#[derive(Debug)]
pub struct Protocol;

pub mod protocol {
    pub mod prelude {
        pub use crate::{
            protocol, Protocol, ProtocolClientHandler, ProtocolClientSender, ProtocolServerHandler,
            ProtocolServerSender,
        };

        pub use crate::ArrayBasic;

        pub use crate::ArrayCompound;

        pub use crate::ArrayVectorNested;

        pub use crate::Basic;

        pub use crate::Compound;

        pub use crate::Resource;

        pub use crate::VectorBasic;

        pub use crate::VectorCompound;

        pub use crate::VectorOptional;
    }

    pub struct OneWayBasic;

    impl ::fidl_next::Method for OneWayBasic {
        const ORDINAL: u64 = 8948968077914418681;

        type Protocol = crate::Protocol;

        type Request = crate::WireBasic;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayBasic;

    impl ::fidl_next::Method for TwoWayBasic {
        const ORDINAL: u64 = 2331618702752598159;

        type Protocol = crate::Protocol;

        type Request = crate::WireBasic;

        type Response = crate::WireBasic;
    }

    pub struct ErrorBasic;

    impl ::fidl_next::Method for ErrorBasic {
        const ORDINAL: u64 = 5016634351643393939;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireBasic, ::fidl_next::WireU32>;
    }

    pub struct EventBasic;

    impl ::fidl_next::Method for EventBasic {
        const ORDINAL: u64 = 5892309624949902400;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireBasic;
    }

    pub struct OneWayCompound;

    impl ::fidl_next::Method for OneWayCompound {
        const ORDINAL: u64 = 3153289648860022476;

        type Protocol = crate::Protocol;

        type Request = crate::WireCompound;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayCompound;

    impl ::fidl_next::Method for TwoWayCompound {
        const ORDINAL: u64 = 8787219719097524529;

        type Protocol = crate::Protocol;

        type Request = crate::WireCompound;

        type Response = crate::WireCompound;
    }

    pub struct ErrorCompound;

    impl ::fidl_next::Method for ErrorCompound {
        const ORDINAL: u64 = 2990809657626249085;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireCompound, ::fidl_next::WireU32>;
    }

    pub struct EventCompound;

    impl ::fidl_next::Method for EventCompound {
        const ORDINAL: u64 = 7024581948727571669;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireCompound;
    }

    pub struct OneWayArrayBasic;

    impl ::fidl_next::Method for OneWayArrayBasic {
        const ORDINAL: u64 = 7125516817014311449;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayBasic;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayBasic;

    impl ::fidl_next::Method for TwoWayArrayBasic {
        const ORDINAL: u64 = 5309034178175279380;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayBasic;

        type Response = crate::WireArrayBasic;
    }

    pub struct ErrorArrayBasic;

    impl ::fidl_next::Method for ErrorArrayBasic {
        const ORDINAL: u64 = 1084731895342694265;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireArrayBasic, ::fidl_next::WireU32>;
    }

    pub struct EventArrayBasic;

    impl ::fidl_next::Method for EventArrayBasic {
        const ORDINAL: u64 = 5888282827283820590;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayBasic;
    }

    pub struct OneWayArrayCompound;

    impl ::fidl_next::Method for OneWayArrayCompound {
        const ORDINAL: u64 = 5064659223443251357;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayCompound;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayCompound;

    impl ::fidl_next::Method for TwoWayArrayCompound {
        const ORDINAL: u64 = 849744466051983995;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayCompound;

        type Response = crate::WireArrayCompound;
    }

    pub struct ErrorArrayCompound;

    impl ::fidl_next::Method for ErrorArrayCompound {
        const ORDINAL: u64 = 5919277476782807556;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireArrayCompound, ::fidl_next::WireU32>;
    }

    pub struct EventArrayCompound;

    impl ::fidl_next::Method for EventArrayCompound {
        const ORDINAL: u64 = 2189769767733851157;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayCompound;
    }

    pub struct OneWayVectorBasic;

    impl ::fidl_next::Method for OneWayVectorBasic {
        const ORDINAL: u64 = 5733220720079947351;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorBasic;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorBasic;

    impl ::fidl_next::Method for TwoWayVectorBasic {
        const ORDINAL: u64 = 8674156353091415668;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorBasic;

        type Response = crate::WireVectorBasic;
    }

    pub struct ErrorVectorBasic;

    impl ::fidl_next::Method for ErrorVectorBasic {
        const ORDINAL: u64 = 875941614196965234;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireVectorBasic, ::fidl_next::WireU32>;
    }

    pub struct EventVectorBasic;

    impl ::fidl_next::Method for EventVectorBasic {
        const ORDINAL: u64 = 4583890770109526006;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorBasic;
    }

    pub struct OneWayVectorCompound;

    impl ::fidl_next::Method for OneWayVectorCompound {
        const ORDINAL: u64 = 1853985797298830992;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorCompound;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorCompound;

    impl ::fidl_next::Method for TwoWayVectorCompound {
        const ORDINAL: u64 = 3968024057912959924;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorCompound;

        type Response = crate::WireVectorCompound;
    }

    pub struct ErrorVectorCompound;

    impl ::fidl_next::Method for ErrorVectorCompound {
        const ORDINAL: u64 = 8506780203315865989;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireVectorCompound, ::fidl_next::WireU32>;
    }

    pub struct EventVectorCompound;

    impl ::fidl_next::Method for EventVectorCompound {
        const ORDINAL: u64 = 6026375226599919603;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorCompound;
    }

    pub struct OneWayVectorOptional;

    impl ::fidl_next::Method for OneWayVectorOptional {
        const ORDINAL: u64 = 1530215841195476271;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorOptional;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayVectorOptional;

    impl ::fidl_next::Method for TwoWayVectorOptional {
        const ORDINAL: u64 = 1030024737742222323;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorOptional;

        type Response = crate::WireVectorOptional;
    }

    pub struct ErrorVectorOptional;

    impl ::fidl_next::Method for ErrorVectorOptional {
        const ORDINAL: u64 = 6406191217027936606;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireVectorOptional, ::fidl_next::WireU32>;
    }

    pub struct EventVectorOptional;

    impl ::fidl_next::Method for EventVectorOptional {
        const ORDINAL: u64 = 1684763340073130077;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireVectorOptional;
    }

    pub struct OneWayArrayVectorNested;

    impl ::fidl_next::Method for OneWayArrayVectorNested {
        const ORDINAL: u64 = 5912603762133524183;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayVectorNested;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayArrayVectorNested;

    impl ::fidl_next::Method for TwoWayArrayVectorNested {
        const ORDINAL: u64 = 5351275678438791132;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayVectorNested;

        type Response = crate::WireArrayVectorNested;
    }

    pub struct ErrorArrayVectorNested;

    impl ::fidl_next::Method for ErrorArrayVectorNested {
        const ORDINAL: u64 = 9085604921605802151;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireArrayVectorNested, ::fidl_next::WireU32>;
    }

    pub struct EventArrayVectorNested;

    impl ::fidl_next::Method for EventArrayVectorNested {
        const ORDINAL: u64 = 1228201560727880574;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireArrayVectorNested;
    }

    pub struct OneWayResource;

    impl ::fidl_next::Method for OneWayResource {
        const ORDINAL: u64 = 6553996787849601058;

        type Protocol = crate::Protocol;

        type Request = crate::WireResource;

        type Response = ::fidl_next::Never;
    }

    pub struct TwoWayResource;

    impl ::fidl_next::Method for TwoWayResource {
        const ORDINAL: u64 = 1802709005492464987;

        type Protocol = crate::Protocol;

        type Request = crate::WireResource;

        type Response = crate::WireResource;
    }

    pub struct ErrorResource;

    impl ::fidl_next::Method for ErrorResource {
        const ORDINAL: u64 = 6568609240497354166;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<crate::WireResource, ::fidl_next::WireU32>;
    }

    pub struct EventResource;

    impl ::fidl_next::Method for EventResource {
        const ORDINAL: u64 = 5745997765922613643;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireResource;
    }
}

/// A helper trait for the `Protocol` client sender.
pub trait ProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn one_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireBasic,
        >;

    fn two_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireBasic,
        >;

    fn error_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireCompound,
        >;

    fn two_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireCompound,
        >;

    fn error_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayBasic,
        >;

    fn two_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayBasic,
        >;

    fn error_array_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayCompound,
        >;

    fn two_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayCompound,
        >;

    fn error_array_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorBasic,
        >;

    fn two_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorBasic,
        >;

    fn error_vector_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorCompound,
        >;

    fn two_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorCompound,
        >;

    fn error_vector_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorOptional,
        >;

    fn two_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorOptional>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorOptional,
        >;

    fn error_vector_optional(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorOptional>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayVectorNested,
        >;

    fn two_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayVectorNested>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayVectorNested,
        >;

    fn error_array_vector_nested(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayVectorNested>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireResource,
        >;

    fn two_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayResource>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireResource,
        >;

    fn error_resource(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorResource>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> ProtocolClientSender for ::fidl_next::ClientSender<___T, Protocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn one_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireBasic,
        >,
    {
        self.as_untyped().send_one_way(8948968077914418681, request)
    }

    fn two_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireBasic,
        >,
    {
        self.as_untyped()
            .send_two_way(2331618702752598159, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5016634351643393939, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireCompound,
        >,
    {
        self.as_untyped().send_one_way(3153289648860022476, request)
    }

    fn two_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireCompound,
        >,
    {
        self.as_untyped()
            .send_two_way(8787219719097524529, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2990809657626249085, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayBasic,
        >,
    {
        self.as_untyped().send_one_way(7125516817014311449, request)
    }

    fn two_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayBasic,
        >,
    {
        self.as_untyped()
            .send_two_way(5309034178175279380, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_array_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1084731895342694265, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayCompound,
        >,
    {
        self.as_untyped().send_one_way(5064659223443251357, request)
    }

    fn two_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayCompound,
        >,
    {
        self.as_untyped()
            .send_two_way(849744466051983995, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_array_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5919277476782807556, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorBasic,
        >,
    {
        self.as_untyped().send_one_way(5733220720079947351, request)
    }

    fn two_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorBasic>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorBasic,
        >,
    {
        self.as_untyped()
            .send_two_way(8674156353091415668, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_vector_basic(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(875941614196965234, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorCompound,
        >,
    {
        self.as_untyped().send_one_way(1853985797298830992, request)
    }

    fn two_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorCompound>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorCompound,
        >,
    {
        self.as_untyped()
            .send_two_way(3968024057912959924, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_vector_compound(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8506780203315865989, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorOptional,
        >,
    {
        self.as_untyped().send_one_way(1530215841195476271, request)
    }

    fn two_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayVectorOptional>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireVectorOptional,
        >,
    {
        self.as_untyped()
            .send_two_way(1030024737742222323, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_vector_optional(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorVectorOptional>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6406191217027936606, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayVectorNested,
        >,
    {
        self.as_untyped().send_one_way(5912603762133524183, request)
    }

    fn two_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayArrayVectorNested>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireArrayVectorNested,
        >,
    {
        self.as_untyped()
            .send_two_way(5351275678438791132, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_array_vector_nested(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorArrayVectorNested>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9085604921605802151, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn one_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireResource,
        >,
    {
        self.as_untyped().send_one_way(6553996787849601058, request)
    }

    fn two_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::TwoWayResource>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireResource,
        >,
    {
        self.as_untyped()
            .send_two_way(1802709005492464987, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn error_resource(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, protocol::ErrorResource>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6568609240497354166, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn event_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventBasic>,
    );

    fn event_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventCompound>,
    );

    fn event_array_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventArrayBasic>,
    );

    fn event_array_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventArrayCompound>,
    );

    fn event_vector_basic(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventVectorBasic>,
    );

    fn event_vector_compound(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventVectorCompound>,
    );

    fn event_vector_optional(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventVectorOptional>,
    );

    fn event_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventArrayVectorNested>,
    );

    fn event_resource(
        &mut self,
        sender: &::fidl_next::ClientSender<___T, Protocol>,

        message: ::fidl_next::ResponseBuffer<___T, protocol::EventResource>,
    );
}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::Transport,
    ___H: ProtocolClientHandler<___T>,

    <protocol::TwoWayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorBasic as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorCompound as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventVectorOptional as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventArrayVectorNested as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::TwoWayResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::ErrorResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <protocol::EventResource as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5892309624949902400 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_basic(sender, buffer);
            }

            7024581948727571669 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_compound(sender, buffer);
            }

            5888282827283820590 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_array_basic(sender, buffer);
            }

            2189769767733851157 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_array_compound(sender, buffer);
            }

            4583890770109526006 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_basic(sender, buffer);
            }

            6026375226599919603 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_compound(sender, buffer);
            }

            1684763340073130077 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_optional(sender, buffer);
            }

            1228201560727880574 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_array_vector_nested(sender, buffer);
            }

            5745997765922613643 => {
                let buffer = ::fidl_next::ResponseBuffer::from_untyped(buffer);
                handler.event_resource(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Protocol` server sender.
pub trait ProtocolServerSender {
    type Transport: ::fidl_next::Transport;

    fn event_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventBasic as ::fidl_next::Method>::Response,
        >;

    fn event_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventCompound as ::fidl_next::Method>::Response,
        >;

    fn event_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayBasic as ::fidl_next::Method>::Response,
        >;

    fn event_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayCompound as ::fidl_next::Method>::Response,
        >;

    fn event_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorBasic as ::fidl_next::Method>::Response,
        >;

    fn event_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorCompound as ::fidl_next::Method>::Response,
        >;

    fn event_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorOptional as ::fidl_next::Method>::Response,
        >;

    fn event_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayVectorNested as ::fidl_next::Method>::Response,
        >;

    fn event_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventResource as ::fidl_next::Method>::Response,
        >;
}

impl<___T> ProtocolServerSender for ::fidl_next::ServerSender<___T, Protocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn event_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventBasic as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(5892309624949902400, request)
    }

    fn event_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventCompound as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(7024581948727571669, request)
    }

    fn event_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayBasic as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(5888282827283820590, request)
    }

    fn event_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayCompound as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(2189769767733851157, request)
    }

    fn event_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorBasic as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(4583890770109526006, request)
    }

    fn event_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorCompound as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(6026375226599919603, request)
    }

    fn event_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventVectorOptional as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(1684763340073130077, request)
    }

    fn event_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventArrayVectorNested as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(1228201560727880574, request)
    }

    fn event_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = <protocol::EventResource as ::fidl_next::Method>::Response,
        >,
    {
        self.as_untyped().send_event(5745997765922613643, request)
    }
}

/// A server handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn one_way_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayBasic>,
    );

    fn two_way_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayBasic>,

        responder: ::fidl_next::Responder<protocol::TwoWayBasic>,
    );

    fn error_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorBasic>,
    );

    fn one_way_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayCompound>,
    );

    fn two_way_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayCompound>,

        responder: ::fidl_next::Responder<protocol::TwoWayCompound>,
    );

    fn error_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorCompound>,
    );

    fn one_way_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayArrayBasic>,
    );

    fn two_way_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayArrayBasic>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayBasic>,
    );

    fn error_array_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayBasic>,
    );

    fn one_way_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayArrayCompound>,
    );

    fn two_way_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayArrayCompound>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayCompound>,
    );

    fn error_array_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayCompound>,
    );

    fn one_way_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayVectorBasic>,
    );

    fn two_way_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayVectorBasic>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorBasic>,
    );

    fn error_vector_basic(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorBasic>,
    );

    fn one_way_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayVectorCompound>,
    );

    fn two_way_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayVectorCompound>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorCompound>,
    );

    fn error_vector_compound(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorCompound>,
    );

    fn one_way_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayVectorOptional>,
    );

    fn two_way_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayVectorOptional>,

        responder: ::fidl_next::Responder<protocol::TwoWayVectorOptional>,
    );

    fn error_vector_optional(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorVectorOptional>,
    );

    fn one_way_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayArrayVectorNested>,
    );

    fn two_way_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayArrayVectorNested>,

        responder: ::fidl_next::Responder<protocol::TwoWayArrayVectorNested>,
    );

    fn error_array_vector_nested(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorArrayVectorNested>,
    );

    fn one_way_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::OneWayResource>,
    );

    fn two_way_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        request: ::fidl_next::RequestBuffer<___T, protocol::TwoWayResource>,

        responder: ::fidl_next::Responder<protocol::TwoWayResource>,
    );

    fn error_resource(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Protocol>,

        responder: ::fidl_next::Responder<protocol::ErrorResource>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::Transport,
    ___H: ProtocolServerHandler<___T>,

    crate::WireBasic: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireBasic: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireCompound: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireCompound: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireArrayBasic: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireArrayBasic: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireArrayCompound: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireArrayCompound: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireVectorBasic: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireVectorBasic: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireVectorCompound: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireVectorCompound: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireVectorOptional: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireVectorOptional: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireArrayVectorNested: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireArrayVectorNested: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireResource: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireResource: ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            8948968077914418681 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_basic(sender, buffer);
            }

            3153289648860022476 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_compound(sender, buffer);
            }

            7125516817014311449 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_basic(sender, buffer);
            }

            5064659223443251357 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_compound(sender, buffer);
            }

            5733220720079947351 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_basic(sender, buffer);
            }

            1853985797298830992 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_compound(sender, buffer);
            }

            1530215841195476271 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_optional(sender, buffer);
            }

            5912603762133524183 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_vector_nested(sender, buffer);
            }

            6553996787849601058 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.one_way_resource(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2331618702752598159 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_basic(sender, buffer, responder);
            }

            5016634351643393939 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_basic(sender, responder);
            }

            8787219719097524529 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_compound(sender, buffer, responder);
            }

            2990809657626249085 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_compound(sender, responder);
            }

            5309034178175279380 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_basic(sender, buffer, responder);
            }

            1084731895342694265 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_basic(sender, responder);
            }

            849744466051983995 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_compound(sender, buffer, responder);
            }

            5919277476782807556 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_compound(sender, responder);
            }

            8674156353091415668 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_basic(sender, buffer, responder);
            }

            875941614196965234 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_basic(sender, responder);
            }

            3968024057912959924 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_compound(sender, buffer, responder);
            }

            8506780203315865989 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_compound(sender, responder);
            }

            1030024737742222323 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_optional(sender, buffer, responder);
            }

            6406191217027936606 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_vector_optional(sender, responder);
            }

            5351275678438791132 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_vector_nested(sender, buffer, responder);
            }

            9085604921605802151 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_array_vector_nested(sender, responder);
            }

            1802709005492464987 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.two_way_resource(sender, buffer, responder);
            }

            6568609240497354166 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.error_resource(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::fidl_next::TakeFrom<crate::WireArrayBasic> for ::fidl_test_typesinprotocols::ArrayBasic {
        #[inline]
        fn take_from(from: &crate::WireArrayBasic) -> Self {
            Self {
                array_uint8: ::fidl_next::TakeFrom::take_from(&from.array_uint8),

                array_uint16: ::fidl_next::TakeFrom::take_from(&from.array_uint16),

                array_uint32: ::fidl_next::TakeFrom::take_from(&from.array_uint32),

                array_uint64: ::fidl_next::TakeFrom::take_from(&from.array_uint64),

                array_int8: ::fidl_next::TakeFrom::take_from(&from.array_int8),

                array_int16: ::fidl_next::TakeFrom::take_from(&from.array_int16),

                array_int32: ::fidl_next::TakeFrom::take_from(&from.array_int32),

                array_int64: ::fidl_next::TakeFrom::take_from(&from.array_int64),

                array_float32: ::fidl_next::TakeFrom::take_from(&from.array_float32),

                array_float64: ::fidl_next::TakeFrom::take_from(&from.array_float64),

                array_string: ::fidl_next::TakeFrom::take_from(&from.array_string),

                array_opt_string: ::fidl_next::TakeFrom::take_from(&from.array_opt_string),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireBits> for ::fidl_test_typesinprotocols::Bits {
        #[inline]
        fn take_from(from: &crate::WireBits) -> Self {
            Self::from_bits_retain(from.value.into())
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireEnum> for ::fidl_test_typesinprotocols::Enum {
        #[inline]
        fn take_from(from: &crate::WireEnum) -> Self {
            match crate::Enum::from(*from) {
                crate::Enum::Val => Self::Val,

                crate::Enum::UnknownOrdinal_(value) => {
                    Self::__SourceBreaking { unknown_ordinal: value }
                }
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireStruct> for ::fidl_test_typesinprotocols::Struct {
        #[inline]
        fn take_from(from: &crate::WireStruct) -> Self {
            Self {}
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireTable> for ::fidl_test_typesinprotocols::Table {
        #[inline]
        fn take_from(from: &crate::WireTable) -> Self {
            Self { __source_breaking: ::fidl::marker::SourceBreaking }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireUnion> for ::fidl_test_typesinprotocols::Union {
        #[inline]
        fn take_from(from: &crate::WireUnion) -> Self {
            match from.as_ref() {
                crate::union::Ref::B(value) => Self::B(::fidl_next::TakeFrom::take_from(value)),

                crate::union::Ref::UnknownOrdinal_(unknown_ordinal) => {
                    Self::__SourceBreaking { unknown_ordinal }
                }
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalUnion>
        for Option<Box<::fidl_test_typesinprotocols::Union>>
    {
        #[inline]
        fn take_from(from: &crate::WireOptionalUnion) -> Self {
            if let Some(inner) = from.as_ref() {
                Some(::fidl_next::TakeFrom::take_from(inner))
            } else {
                None
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireArrayCompound>
        for ::fidl_test_typesinprotocols::ArrayCompound
    {
        #[inline]
        fn take_from(from: &crate::WireArrayCompound) -> Self {
            Self {
                array_bits: ::fidl_next::TakeFrom::take_from(&from.array_bits),

                array_enum: ::fidl_next::TakeFrom::take_from(&from.array_enum),

                array_struct: ::fidl_next::TakeFrom::take_from(&from.array_struct),

                array_table: ::fidl_next::TakeFrom::take_from(&from.array_table),

                array_union: ::fidl_next::TakeFrom::take_from(&from.array_union),

                array_opt_struct: ::fidl_next::TakeFrom::take_from(&from.array_opt_struct),

                array_opt_union: ::fidl_next::TakeFrom::take_from(&from.array_opt_union),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireArrayVectorNested>
        for ::fidl_test_typesinprotocols::ArrayVectorNested
    {
        #[inline]
        fn take_from(from: &crate::WireArrayVectorNested) -> Self {
            Self {
                array_array_uint8: ::fidl_next::TakeFrom::take_from(&from.array_array_uint8),

                array_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.array_vector_uint8),

                vector_array_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_array_uint8),

                vector_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_vector_uint8),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireBasic> for ::fidl_test_typesinprotocols::Basic {
        #[inline]
        fn take_from(from: &crate::WireBasic) -> Self {
            Self {
                uint8: ::fidl_next::TakeFrom::take_from(&from.uint8),

                uint16: ::fidl_next::TakeFrom::take_from(&from.uint16),

                uint32: ::fidl_next::TakeFrom::take_from(&from.uint32),

                uint64: ::fidl_next::TakeFrom::take_from(&from.uint64),

                int8: ::fidl_next::TakeFrom::take_from(&from.int8),

                int16: ::fidl_next::TakeFrom::take_from(&from.int16),

                int32: ::fidl_next::TakeFrom::take_from(&from.int32),

                int64: ::fidl_next::TakeFrom::take_from(&from.int64),

                float32: ::fidl_next::TakeFrom::take_from(&from.float32),

                float64: ::fidl_next::TakeFrom::take_from(&from.float64),

                string: ::fidl_next::TakeFrom::take_from(&from.string),

                opt_string: ::fidl_next::TakeFrom::take_from(&from.opt_string),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireCompound> for ::fidl_test_typesinprotocols::Compound {
        #[inline]
        fn take_from(from: &crate::WireCompound) -> Self {
            Self {
                bits: ::fidl_next::TakeFrom::take_from(&from.bits),

                enum_: ::fidl_next::TakeFrom::take_from(&from.enum_),

                struct_: ::fidl_next::TakeFrom::take_from(&from.struct_),

                table: ::fidl_next::TakeFrom::take_from(&from.table),

                union: ::fidl_next::TakeFrom::take_from(&from.union),

                opt_struct: ::fidl_next::TakeFrom::take_from(&from.opt_struct),

                opt_union: ::fidl_next::TakeFrom::take_from(&from.opt_union),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireVectorBasic> for ::fidl_test_typesinprotocols::VectorBasic {
        #[inline]
        fn take_from(from: &crate::WireVectorBasic) -> Self {
            Self {
                vector_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_uint8),

                vector_uint16: ::fidl_next::TakeFrom::take_from(&from.vector_uint16),

                vector_uint32: ::fidl_next::TakeFrom::take_from(&from.vector_uint32),

                vector_uint64: ::fidl_next::TakeFrom::take_from(&from.vector_uint64),

                vector_int8: ::fidl_next::TakeFrom::take_from(&from.vector_int8),

                vector_int16: ::fidl_next::TakeFrom::take_from(&from.vector_int16),

                vector_int32: ::fidl_next::TakeFrom::take_from(&from.vector_int32),

                vector_int64: ::fidl_next::TakeFrom::take_from(&from.vector_int64),

                vector_float32: ::fidl_next::TakeFrom::take_from(&from.vector_float32),

                vector_float64: ::fidl_next::TakeFrom::take_from(&from.vector_float64),

                vector_string: ::fidl_next::TakeFrom::take_from(&from.vector_string),

                vector_opt_string: ::fidl_next::TakeFrom::take_from(&from.vector_opt_string),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireVectorCompound>
        for ::fidl_test_typesinprotocols::VectorCompound
    {
        #[inline]
        fn take_from(from: &crate::WireVectorCompound) -> Self {
            Self {
                vector_bits: ::fidl_next::TakeFrom::take_from(&from.vector_bits),

                vector_enum: ::fidl_next::TakeFrom::take_from(&from.vector_enum),

                vector_struct: ::fidl_next::TakeFrom::take_from(&from.vector_struct),

                vector_table: ::fidl_next::TakeFrom::take_from(&from.vector_table),

                vector_union: ::fidl_next::TakeFrom::take_from(&from.vector_union),

                vector_opt_struct: ::fidl_next::TakeFrom::take_from(&from.vector_opt_struct),

                vector_opt_union: ::fidl_next::TakeFrom::take_from(&from.vector_opt_union),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireVectorOptional>
        for ::fidl_test_typesinprotocols::VectorOptional
    {
        #[inline]
        fn take_from(from: &crate::WireVectorOptional) -> Self {
            Self {
                opt_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.opt_vector_uint8),

                opt_vector_string: ::fidl_next::TakeFrom::take_from(&from.opt_vector_string),

                opt_vector_struct: ::fidl_next::TakeFrom::take_from(&from.opt_vector_struct),

                opt_vector_opt_struct: ::fidl_next::TakeFrom::take_from(
                    &from.opt_vector_opt_struct,
                ),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireResourceStruct>
        for ::fidl_test_typesinprotocols::ResourceStruct
    {
        #[inline]
        fn take_from(from: &crate::WireResourceStruct) -> Self {
            Self {}
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireResourceTable>
        for ::fidl_test_typesinprotocols::ResourceTable
    {
        #[inline]
        fn take_from(from: &crate::WireResourceTable) -> Self {
            Self { __source_breaking: ::fidl::marker::SourceBreaking }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireResourceUnion>
        for ::fidl_test_typesinprotocols::ResourceUnion
    {
        #[inline]
        fn take_from(from: &crate::WireResourceUnion) -> Self {
            match from.as_ref() {
                crate::resource_union::Ref::B(value) => {
                    Self::B(::fidl_next::TakeFrom::take_from(value))
                }

                crate::resource_union::Ref::UnknownOrdinal_(unknown_ordinal) => {
                    Self::__SourceBreaking { unknown_ordinal }
                }
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOptionalResourceUnion>
        for Option<Box<::fidl_test_typesinprotocols::ResourceUnion>>
    {
        #[inline]
        fn take_from(from: &crate::WireOptionalResourceUnion) -> Self {
            if let Some(inner) = from.as_ref() {
                Some(::fidl_next::TakeFrom::take_from(inner))
            } else {
                None
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireResource> for ::fidl_test_typesinprotocols::Resource {
        #[inline]
        fn take_from(from: &crate::WireResource) -> Self {
            Self {
                handle: ::fidl_next::TakeFrom::take_from(&from.handle),

                vmo: ::fidl_next::TakeFrom::take_from(&from.vmo),

                client_end: ::fidl_next::TakeFrom::take_from(&from.client_end),

                server_end: ::fidl_next::TakeFrom::take_from(&from.server_end),

                struct_: ::fidl_next::TakeFrom::take_from(&from.struct_),

                table: ::fidl_next::TakeFrom::take_from(&from.table),

                union: ::fidl_next::TakeFrom::take_from(&from.union),

                opt_handle: ::fidl_next::TakeFrom::take_from(&from.opt_handle),

                opt_vmo: ::fidl_next::TakeFrom::take_from(&from.opt_vmo),

                opt_client_end: ::fidl_next::TakeFrom::take_from(&from.opt_client_end),

                opt_server_end: ::fidl_next::TakeFrom::take_from(&from.opt_server_end),

                opt_struct: ::fidl_next::TakeFrom::take_from(&from.opt_struct),

                opt_union: ::fidl_next::TakeFrom::take_from(&from.opt_union),

                array_handle: ::fidl_next::TakeFrom::take_from(&from.array_handle),

                array_vmo: ::fidl_next::TakeFrom::take_from(&from.array_vmo),

                array_client_end: ::fidl_next::TakeFrom::take_from(&from.array_client_end),

                array_server_end: ::fidl_next::TakeFrom::take_from(&from.array_server_end),

                array_struct: ::fidl_next::TakeFrom::take_from(&from.array_struct),

                array_table: ::fidl_next::TakeFrom::take_from(&from.array_table),

                array_union: ::fidl_next::TakeFrom::take_from(&from.array_union),

                vector_handle: ::fidl_next::TakeFrom::take_from(&from.vector_handle),

                vector_vmo: ::fidl_next::TakeFrom::take_from(&from.vector_vmo),

                vector_client_end: ::fidl_next::TakeFrom::take_from(&from.vector_client_end),

                vector_server_end: ::fidl_next::TakeFrom::take_from(&from.vector_server_end),

                vector_struct: ::fidl_next::TakeFrom::take_from(&from.vector_struct),

                vector_table: ::fidl_next::TakeFrom::take_from(&from.vector_table),

                vector_union: ::fidl_next::TakeFrom::take_from(&from.vector_union),
            }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Protocol`
    /// protocol.
    pub type ProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Protocol>;

    impl ::fidl_next::TakeFrom<crate::Protocol> for ::fidl_test_typesinprotocols::ProtocolMarker {
        #[inline]
        fn take_from(from: &crate::Protocol) -> Self {
            Self
        }
    }
}
