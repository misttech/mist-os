// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
pub struct ArrayBasic {
    pub array_uint8: [u8; 5],

    pub array_uint16: [u16; 5],

    pub array_uint32: [u32; 5],

    pub array_uint64: [u64; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [i16; 5],

    pub array_int32: [i32; 5],

    pub array_int64: [i64; 5],

    pub array_float32: [f32; 5],

    pub array_float64: [f64; 5],

    pub array_string: [String; 5],

    pub array_opt_string: [Option<String>; 5],
}

impl ::fidl_next::Encodable for ArrayBasic {
    type Encoded = WireArrayBasic;
}

impl<___E> ::fidl_next::Encode<___E> for ArrayBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_uint8,
                array_uint16,
                array_uint32,
                array_uint64,
                array_int8,
                array_int16,
                array_int32,
                array_int64,
                array_float32,
                array_float64,
                array_string,
                array_opt_string,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.array_uint8, encoder, array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.array_uint16, encoder, array_uint16)?;

        ::fidl_next::Encode::encode(&mut self.array_uint32, encoder, array_uint32)?;

        ::fidl_next::Encode::encode(&mut self.array_uint64, encoder, array_uint64)?;

        ::fidl_next::Encode::encode(&mut self.array_int8, encoder, array_int8)?;

        ::fidl_next::Encode::encode(&mut self.array_int16, encoder, array_int16)?;

        ::fidl_next::Encode::encode(&mut self.array_int32, encoder, array_int32)?;

        ::fidl_next::Encode::encode(&mut self.array_int64, encoder, array_int64)?;

        ::fidl_next::Encode::encode(&mut self.array_float32, encoder, array_float32)?;

        ::fidl_next::Encode::encode(&mut self.array_float64, encoder, array_float64)?;

        ::fidl_next::Encode::encode(&mut self.array_string, encoder, array_string)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_string, encoder, array_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayBasic> {
    type EncodedOption = ::fidl_next::WireBox<WireArrayBasic>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayBasic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayBasic: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireArrayBasic> for ArrayBasic {
    fn take_from(from: &WireArrayBasic) -> Self {
        Self {
            array_uint8: ::fidl_next::TakeFrom::take_from(&from.array_uint8),

            array_uint16: ::fidl_next::TakeFrom::take_from(&from.array_uint16),

            array_uint32: ::fidl_next::TakeFrom::take_from(&from.array_uint32),

            array_uint64: ::fidl_next::TakeFrom::take_from(&from.array_uint64),

            array_int8: ::fidl_next::TakeFrom::take_from(&from.array_int8),

            array_int16: ::fidl_next::TakeFrom::take_from(&from.array_int16),

            array_int32: ::fidl_next::TakeFrom::take_from(&from.array_int32),

            array_int64: ::fidl_next::TakeFrom::take_from(&from.array_int64),

            array_float32: ::fidl_next::TakeFrom::take_from(&from.array_float32),

            array_float64: ::fidl_next::TakeFrom::take_from(&from.array_float64),

            array_string: ::fidl_next::TakeFrom::take_from(&from.array_string),

            array_opt_string: ::fidl_next::TakeFrom::take_from(&from.array_opt_string),
        }
    }
}

/// The wire type corersponding to [`ArrayBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayBasic {
    pub array_uint8: [u8; 5],

    pub array_uint16: [::fidl_next::u16_le; 5],

    pub array_uint32: [::fidl_next::u32_le; 5],

    pub array_uint64: [::fidl_next::u64_le; 5],

    pub array_int8: [i8; 5],

    pub array_int16: [::fidl_next::i16_le; 5],

    pub array_int32: [::fidl_next::i32_le; 5],

    pub array_int64: [::fidl_next::i64_le; 5],

    pub array_float32: [::fidl_next::f32_le; 5],

    pub array_float64: [::fidl_next::f64_le; 5],

    pub array_string: [::fidl_next::WireString; 5],

    pub array_opt_string: [::fidl_next::WireOptionalString; 5],
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireArrayBasic
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_uint8,
                mut array_uint16,
                mut array_uint32,
                mut array_uint64,
                mut array_int8,
                mut array_int16,
                mut array_int32,
                mut array_int64,
                mut array_float32,
                mut array_float64,
                mut array_string,
                mut array_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct Bits: u32 {
        const VAL = 1;
        const _ = !0;
    }
}

impl ::fidl_next::Encodable for Bits {
    type Encoded = WireBits;
}

impl<___E> ::fidl_next::Encode<___E> for Bits
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireBits { mut value } = slot);
        *value = ::fidl_next::u32_le::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<WireBits> for Bits {
    fn from(wire: WireBits) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireBits> for Bits {
    fn take_from(from: &WireBits) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Bits`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireBits {
    value: ::fidl_next::u32_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireBits
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Bits> for WireBits {
    fn from(natural: Bits) -> Self {
        Self { value: ::fidl_next::u32_le::from(natural.bits()) }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Enum {
    Val = 1,
    UnknownOrdinal_(u32),
}

impl ::fidl_next::Encodable for Enum {
    type Encoded = WireEnum;
}

impl<___E> ::fidl_next::Encode<___E> for Enum
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEnum { mut value } = slot);
        *value = ::fidl_next::u32_le::from(match *self {
            Self::Val => 1,

            Self::UnknownOrdinal_(value) => value,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireEnum> for Enum {
    fn from(wire: WireEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::Val,

            value => Self::UnknownOrdinal_(value),
        }
    }
}

impl ::fidl_next::TakeFrom<WireEnum> for Enum {
    fn take_from(from: &WireEnum) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`Enum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireEnum {
    value: ::fidl_next::u32_le,
}

impl WireEnum {
    pub const VAL: WireEnum = WireEnum { value: ::fidl_next::u32_le::from_native(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        Ok(())
    }
}

impl ::core::convert::From<Enum> for WireEnum {
    fn from(natural: Enum) -> Self {
        match natural {
            Enum::Val => WireEnum::VAL,

            Enum::UnknownOrdinal_(value) => WireEnum { value: ::fidl_next::u32_le::from(value) },
        }
    }
}

#[derive(Clone, Debug)]
pub struct Struct {}

impl ::fidl_next::Encodable for Struct {
    type Encoded = WireStruct;
}

impl<___E> ::fidl_next::Encode<___E> for Struct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Struct> {
    type EncodedOption = ::fidl_next::WireBox<WireStruct>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Struct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Struct: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireStruct> for Struct {
    fn take_from(from: &WireStruct) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`Struct`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireStruct {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Table {}

impl Table {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for Table {
    type Encoded = WireTable;
}

impl<___E> ::fidl_next::Encode<___E> for Table
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTable> for Table {
    fn take_from(from: &WireTable) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Table`].
#[repr(C)]
pub struct WireTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireTable
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireTable {}

impl ::core::fmt::Debug for WireTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("Table").finish()
    }
}

#[derive(Clone, Debug)]
pub enum Union {
    B(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for Union {
    type Encoded = WireUnion;
}

impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw } = slot);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Union> {
    type EncodedOption = WireOptionalUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Union>
where
    ___E: ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireUnion> for Union {
    fn take_from(from: &WireUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::B(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalUnion> for Option<Box<Union>> {
    fn take_from(from: &WireOptionalUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod union_ {
    pub enum Ref<'union> {
        B(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireUnion {
    pub fn as_ref(&self) -> crate::union_::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union_::Ref::B(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::union_::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnion { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct ArrayCompound {
    pub array_bits: [crate::Bits; 5],

    pub array_enum: [crate::Enum; 5],

    pub array_struct: [crate::Struct; 5],

    pub array_table: [crate::Table; 5],

    pub array_union: [crate::Union; 5],

    pub array_opt_struct: [Option<Box<crate::Struct>>; 5],

    pub array_opt_union: [Option<Box<crate::Union>>; 5],
}

impl ::fidl_next::Encodable for ArrayCompound {
    type Encoded = WireArrayCompound;
}

impl<___E> ::fidl_next::Encode<___E> for ArrayCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_bits,
                array_enum,
                array_struct,
                array_table,
                array_union,
                array_opt_struct,
                array_opt_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.array_bits, encoder, array_bits)?;

        ::fidl_next::Encode::encode(&mut self.array_enum, encoder, array_enum)?;

        ::fidl_next::Encode::encode(&mut self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(&mut self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_struct, encoder, array_opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_opt_union, encoder, array_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayCompound> {
    type EncodedOption = ::fidl_next::WireBox<WireArrayCompound>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayCompound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayCompound: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireArrayCompound> for ArrayCompound {
    fn take_from(from: &WireArrayCompound) -> Self {
        Self {
            array_bits: ::fidl_next::TakeFrom::take_from(&from.array_bits),

            array_enum: ::fidl_next::TakeFrom::take_from(&from.array_enum),

            array_struct: ::fidl_next::TakeFrom::take_from(&from.array_struct),

            array_table: ::fidl_next::TakeFrom::take_from(&from.array_table),

            array_union: ::fidl_next::TakeFrom::take_from(&from.array_union),

            array_opt_struct: ::fidl_next::TakeFrom::take_from(&from.array_opt_struct),

            array_opt_union: ::fidl_next::TakeFrom::take_from(&from.array_opt_union),
        }
    }
}

/// The wire type corersponding to [`ArrayCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayCompound {
    pub array_bits: [crate::WireBits; 5],

    pub array_enum: [crate::WireEnum; 5],

    pub array_struct: [crate::WireStruct; 5],

    pub array_table: [crate::WireTable; 5],

    pub array_union: [crate::WireUnion; 5],

    pub array_opt_struct: [::fidl_next::WireBox<crate::WireStruct>; 5],

    pub array_opt_union: [crate::WireOptionalUnion; 5],
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireArrayCompound
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_bits,
                mut array_enum,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut array_opt_struct,
                mut array_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ArrayVectorNested {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [Vec<u8>; 5],

    pub vector_array_uint8: Vec<[u8; 5]>,

    pub vector_vector_uint8: Vec<Vec<u8>>,
}

impl ::fidl_next::Encodable for ArrayVectorNested {
    type Encoded = WireArrayVectorNested;
}

impl<___E> ::fidl_next::Encode<___E> for ArrayVectorNested
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                array_array_uint8,
                array_vector_uint8,
                vector_array_uint8,
                vector_vector_uint8,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.array_array_uint8, encoder, array_array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.array_vector_uint8, encoder, array_vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_array_uint8, encoder, vector_array_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_vector_uint8, encoder, vector_vector_uint8)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ArrayVectorNested> {
    type EncodedOption = ::fidl_next::WireBox<WireArrayVectorNested>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ArrayVectorNested>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ArrayVectorNested: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireArrayVectorNested> for ArrayVectorNested {
    fn take_from(from: &WireArrayVectorNested) -> Self {
        Self {
            array_array_uint8: ::fidl_next::TakeFrom::take_from(&from.array_array_uint8),

            array_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.array_vector_uint8),

            vector_array_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_array_uint8),

            vector_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_vector_uint8),
        }
    }
}

/// The wire type corersponding to [`ArrayVectorNested`].
#[derive(Debug)]
#[repr(C)]
pub struct WireArrayVectorNested {
    pub array_array_uint8: [[u8; 5]; 5],

    pub array_vector_uint8: [::fidl_next::WireVector<u8>; 5],

    pub vector_array_uint8: ::fidl_next::WireVector<[u8; 5]>,

    pub vector_vector_uint8: ::fidl_next::WireVector<::fidl_next::WireVector<u8>>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireArrayVectorNested
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut array_array_uint8,
                mut array_vector_uint8,
                mut vector_array_uint8,
                mut vector_vector_uint8,

            } = slot;
        }

        ::fidl_next::Decode::decode(array_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_array_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vector_uint8.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Basic {
    pub uint8: u8,

    pub uint16: u16,

    pub uint32: u32,

    pub uint64: u64,

    pub int8: i8,

    pub int16: i16,

    pub int32: i32,

    pub int64: i64,

    pub float32: f32,

    pub float64: f64,

    pub string: String,

    pub opt_string: Option<String>,
}

impl ::fidl_next::Encodable for Basic {
    type Encoded = WireBasic;
}

impl<___E> ::fidl_next::Encode<___E> for Basic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                uint8,
                uint16,
                uint32,
                uint64,
                int8,
                int16,
                int32,
                int64,
                float32,
                float64,
                string,
                opt_string,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.uint8, encoder, uint8)?;

        ::fidl_next::Encode::encode(&mut self.uint16, encoder, uint16)?;

        ::fidl_next::Encode::encode(&mut self.uint32, encoder, uint32)?;

        ::fidl_next::Encode::encode(&mut self.uint64, encoder, uint64)?;

        ::fidl_next::Encode::encode(&mut self.int8, encoder, int8)?;

        ::fidl_next::Encode::encode(&mut self.int16, encoder, int16)?;

        ::fidl_next::Encode::encode(&mut self.int32, encoder, int32)?;

        ::fidl_next::Encode::encode(&mut self.int64, encoder, int64)?;

        ::fidl_next::Encode::encode(&mut self.float32, encoder, float32)?;

        ::fidl_next::Encode::encode(&mut self.float64, encoder, float64)?;

        ::fidl_next::Encode::encode(&mut self.string, encoder, string)?;

        ::fidl_next::Encode::encode(&mut self.opt_string, encoder, opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Basic> {
    type EncodedOption = ::fidl_next::WireBox<WireBasic>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Basic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Basic: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireBasic> for Basic {
    fn take_from(from: &WireBasic) -> Self {
        Self {
            uint8: ::fidl_next::TakeFrom::take_from(&from.uint8),

            uint16: ::fidl_next::TakeFrom::take_from(&from.uint16),

            uint32: ::fidl_next::TakeFrom::take_from(&from.uint32),

            uint64: ::fidl_next::TakeFrom::take_from(&from.uint64),

            int8: ::fidl_next::TakeFrom::take_from(&from.int8),

            int16: ::fidl_next::TakeFrom::take_from(&from.int16),

            int32: ::fidl_next::TakeFrom::take_from(&from.int32),

            int64: ::fidl_next::TakeFrom::take_from(&from.int64),

            float32: ::fidl_next::TakeFrom::take_from(&from.float32),

            float64: ::fidl_next::TakeFrom::take_from(&from.float64),

            string: ::fidl_next::TakeFrom::take_from(&from.string),

            opt_string: ::fidl_next::TakeFrom::take_from(&from.opt_string),
        }
    }
}

/// The wire type corersponding to [`Basic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireBasic {
    pub uint8: u8,

    pub uint16: ::fidl_next::u16_le,

    pub uint32: ::fidl_next::u32_le,

    pub uint64: ::fidl_next::u64_le,

    pub int8: i8,

    pub int16: ::fidl_next::i16_le,

    pub int32: ::fidl_next::i32_le,

    pub int64: ::fidl_next::i64_le,

    pub float32: ::fidl_next::f32_le,

    pub float64: ::fidl_next::f64_le,

    pub string: ::fidl_next::WireString,

    pub opt_string: ::fidl_next::WireOptionalString,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireBasic
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut uint8,
                mut uint16,
                mut uint32,
                mut uint64,
                mut int8,
                mut int16,
                mut int32,
                mut int64,
                mut float32,
                mut float64,
                mut string,
                mut opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Compound {
    pub bits: crate::Bits,

    pub enum_: crate::Enum,

    pub struct_: crate::Struct,

    pub table: crate::Table,

    pub union_: crate::Union,

    pub opt_struct: Option<Box<crate::Struct>>,

    pub opt_union: Option<Box<crate::Union>>,
}

impl ::fidl_next::Encodable for Compound {
    type Encoded = WireCompound;
}

impl<___E> ::fidl_next::Encode<___E> for Compound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                bits,
                enum_,
                struct_,
                table,
                union_,
                opt_struct,
                opt_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.bits, encoder, bits)?;

        ::fidl_next::Encode::encode(&mut self.enum_, encoder, enum_)?;

        ::fidl_next::Encode::encode(&mut self.struct_, encoder, struct_)?;

        ::fidl_next::Encode::encode(&mut self.table, encoder, table)?;

        ::fidl_next::Encode::encode(&mut self.union_, encoder, union_)?;

        ::fidl_next::Encode::encode(&mut self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.opt_union, encoder, opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Compound> {
    type EncodedOption = ::fidl_next::WireBox<WireCompound>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Compound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Compound: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireCompound> for Compound {
    fn take_from(from: &WireCompound) -> Self {
        Self {
            bits: ::fidl_next::TakeFrom::take_from(&from.bits),

            enum_: ::fidl_next::TakeFrom::take_from(&from.enum_),

            struct_: ::fidl_next::TakeFrom::take_from(&from.struct_),

            table: ::fidl_next::TakeFrom::take_from(&from.table),

            union_: ::fidl_next::TakeFrom::take_from(&from.union_),

            opt_struct: ::fidl_next::TakeFrom::take_from(&from.opt_struct),

            opt_union: ::fidl_next::TakeFrom::take_from(&from.opt_union),
        }
    }
}

/// The wire type corersponding to [`Compound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireCompound {
    pub bits: crate::WireBits,

    pub enum_: crate::WireEnum,

    pub struct_: crate::WireStruct,

    pub table: crate::WireTable,

    pub union_: crate::WireUnion,

    pub opt_struct: ::fidl_next::WireBox<crate::WireStruct>,

    pub opt_union: crate::WireOptionalUnion,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireCompound
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut bits,
                mut enum_,
                mut struct_,
                mut table,
                mut union_,
                mut opt_struct,
                mut opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(enum_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(struct_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(union_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorBasicResult {
    Response(crate::Basic),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorBasicResult {
    type Encoded = WireProtocolErrorBasicResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorBasicResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorBasicResult { raw } = slot);

        match self {
            Self::Response(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Basic>(value, 1, encoder, raw)?
            }

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorBasicResult> {
    type EncodedOption = WireOptionalProtocolErrorBasicResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorBasicResult>
where
    ___E: ?Sized,
    ProtocolErrorBasicResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorBasicResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorBasicResult> for ProtocolErrorBasicResult {
    fn take_from(from: &WireProtocolErrorBasicResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorBasicResult>
    for Option<Box<ProtocolErrorBasicResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorBasicResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorBasicResult`].
#[repr(transparent)]
pub struct WireProtocolErrorBasicResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_basic_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireBasic),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorBasicResult {
    pub fn as_ref(&self) -> crate::protocol_error_basic_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_basic_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_basic_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorBasicResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireBasic>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorBasicResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireBasic>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorBasicResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorBasicResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorBasicResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalProtocolErrorBasicResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireBasic>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorBasicResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorCompoundResult {
    Response(crate::Compound),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorCompoundResult {
    type Encoded = WireProtocolErrorCompoundResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorCompoundResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorCompoundResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<___E, crate::Compound>(
                value, 1, encoder, raw,
            )?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorCompoundResult> {
    type EncodedOption = WireOptionalProtocolErrorCompoundResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorCompoundResult>
where
    ___E: ?Sized,
    ProtocolErrorCompoundResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorCompoundResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorCompoundResult> for ProtocolErrorCompoundResult {
    fn take_from(from: &WireProtocolErrorCompoundResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorCompoundResult>
    for Option<Box<ProtocolErrorCompoundResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorCompoundResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorCompoundResult`].
#[repr(transparent)]
pub struct WireProtocolErrorCompoundResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_compound_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireCompound),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorCompoundResult {
    pub fn as_ref(&self) -> crate::protocol_error_compound_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_compound_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_compound_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorCompoundResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireCompound>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorCompoundResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireCompound>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorCompoundResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorCompoundResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorCompoundResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalProtocolErrorCompoundResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireCompound>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorCompoundResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorArrayBasicResult {
    Response(crate::ArrayBasic),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorArrayBasicResult {
    type Encoded = WireProtocolErrorArrayBasicResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorArrayBasicResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorArrayBasicResult { raw } = slot);

        match self {
            Self::Response(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::ArrayBasic>(
                    value, 1, encoder, raw,
                )?
            }

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorArrayBasicResult> {
    type EncodedOption = WireOptionalProtocolErrorArrayBasicResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorArrayBasicResult>
where
    ___E: ?Sized,
    ProtocolErrorArrayBasicResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorArrayBasicResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorArrayBasicResult> for ProtocolErrorArrayBasicResult {
    fn take_from(from: &WireProtocolErrorArrayBasicResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorArrayBasicResult>
    for Option<Box<ProtocolErrorArrayBasicResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorArrayBasicResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorArrayBasicResult`].
#[repr(transparent)]
pub struct WireProtocolErrorArrayBasicResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_array_basic_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireArrayBasic),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorArrayBasicResult {
    pub fn as_ref(&self) -> crate::protocol_error_array_basic_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_basic_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_array_basic_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorArrayBasicResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayBasic>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorArrayBasicResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireArrayBasic>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorArrayBasicResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorArrayBasicResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorArrayBasicResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalProtocolErrorArrayBasicResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayBasic>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorArrayBasicResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorArrayCompoundResult {
    Response(crate::ArrayCompound),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorArrayCompoundResult {
    type Encoded = WireProtocolErrorArrayCompoundResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorArrayCompoundResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorArrayCompoundResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::ArrayCompound,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorArrayCompoundResult> {
    type EncodedOption = WireOptionalProtocolErrorArrayCompoundResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorArrayCompoundResult>
where
    ___E: ?Sized,
    ProtocolErrorArrayCompoundResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorArrayCompoundResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorArrayCompoundResult>
    for ProtocolErrorArrayCompoundResult
{
    fn take_from(from: &WireProtocolErrorArrayCompoundResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorArrayCompoundResult>
    for Option<Box<ProtocolErrorArrayCompoundResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorArrayCompoundResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorArrayCompoundResult`].
#[repr(transparent)]
pub struct WireProtocolErrorArrayCompoundResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_array_compound_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireArrayCompound),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorArrayCompoundResult {
    pub fn as_ref(&self) -> crate::protocol_error_array_compound_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_compound_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_array_compound_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorArrayCompoundResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayCompound>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorArrayCompoundResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireArrayCompound>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorArrayCompoundResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorArrayCompoundResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorArrayCompoundResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalProtocolErrorArrayCompoundResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayCompound>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorArrayCompoundResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct VectorBasic {
    pub vector_uint8: Vec<u8>,

    pub vector_uint16: Vec<u16>,

    pub vector_uint32: Vec<u32>,

    pub vector_uint64: Vec<u64>,

    pub vector_int8: Vec<i8>,

    pub vector_int16: Vec<i16>,

    pub vector_int32: Vec<i32>,

    pub vector_int64: Vec<i64>,

    pub vector_float32: Vec<f32>,

    pub vector_float64: Vec<f64>,

    pub vector_string: Vec<String>,

    pub vector_opt_string: Vec<Option<String>>,
}

impl ::fidl_next::Encodable for VectorBasic {
    type Encoded = WireVectorBasic;
}

impl<___E> ::fidl_next::Encode<___E> for VectorBasic
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_uint8,
                vector_uint16,
                vector_uint32,
                vector_uint64,
                vector_int8,
                vector_int16,
                vector_int32,
                vector_int64,
                vector_float32,
                vector_float64,
                vector_string,
                vector_opt_string,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.vector_uint8, encoder, vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint16, encoder, vector_uint16)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint32, encoder, vector_uint32)?;

        ::fidl_next::Encode::encode(&mut self.vector_uint64, encoder, vector_uint64)?;

        ::fidl_next::Encode::encode(&mut self.vector_int8, encoder, vector_int8)?;

        ::fidl_next::Encode::encode(&mut self.vector_int16, encoder, vector_int16)?;

        ::fidl_next::Encode::encode(&mut self.vector_int32, encoder, vector_int32)?;

        ::fidl_next::Encode::encode(&mut self.vector_int64, encoder, vector_int64)?;

        ::fidl_next::Encode::encode(&mut self.vector_float32, encoder, vector_float32)?;

        ::fidl_next::Encode::encode(&mut self.vector_float64, encoder, vector_float64)?;

        ::fidl_next::Encode::encode(&mut self.vector_string, encoder, vector_string)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_string, encoder, vector_opt_string)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorBasic> {
    type EncodedOption = ::fidl_next::WireBox<WireVectorBasic>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorBasic>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorBasic: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireVectorBasic> for VectorBasic {
    fn take_from(from: &WireVectorBasic) -> Self {
        Self {
            vector_uint8: ::fidl_next::TakeFrom::take_from(&from.vector_uint8),

            vector_uint16: ::fidl_next::TakeFrom::take_from(&from.vector_uint16),

            vector_uint32: ::fidl_next::TakeFrom::take_from(&from.vector_uint32),

            vector_uint64: ::fidl_next::TakeFrom::take_from(&from.vector_uint64),

            vector_int8: ::fidl_next::TakeFrom::take_from(&from.vector_int8),

            vector_int16: ::fidl_next::TakeFrom::take_from(&from.vector_int16),

            vector_int32: ::fidl_next::TakeFrom::take_from(&from.vector_int32),

            vector_int64: ::fidl_next::TakeFrom::take_from(&from.vector_int64),

            vector_float32: ::fidl_next::TakeFrom::take_from(&from.vector_float32),

            vector_float64: ::fidl_next::TakeFrom::take_from(&from.vector_float64),

            vector_string: ::fidl_next::TakeFrom::take_from(&from.vector_string),

            vector_opt_string: ::fidl_next::TakeFrom::take_from(&from.vector_opt_string),
        }
    }
}

/// The wire type corersponding to [`VectorBasic`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorBasic {
    pub vector_uint8: ::fidl_next::WireVector<u8>,

    pub vector_uint16: ::fidl_next::WireVector<::fidl_next::u16_le>,

    pub vector_uint32: ::fidl_next::WireVector<::fidl_next::u32_le>,

    pub vector_uint64: ::fidl_next::WireVector<::fidl_next::u64_le>,

    pub vector_int8: ::fidl_next::WireVector<i8>,

    pub vector_int16: ::fidl_next::WireVector<::fidl_next::i16_le>,

    pub vector_int32: ::fidl_next::WireVector<::fidl_next::i32_le>,

    pub vector_int64: ::fidl_next::WireVector<::fidl_next::i64_le>,

    pub vector_float32: ::fidl_next::WireVector<::fidl_next::f32_le>,

    pub vector_float64: ::fidl_next::WireVector<::fidl_next::f64_le>,

    pub vector_string: ::fidl_next::WireVector<::fidl_next::WireString>,

    pub vector_opt_string: ::fidl_next::WireVector<::fidl_next::WireOptionalString>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireVectorBasic
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_uint8,
                mut vector_uint16,
                mut vector_uint32,
                mut vector_uint64,
                mut vector_int8,
                mut vector_int16,
                mut vector_int32,
                mut vector_int64,
                mut vector_float32,
                mut vector_float64,
                mut vector_string,
                mut vector_opt_string,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_uint64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int16.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_int64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_float64.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_string.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorVectorBasicResult {
    Response(crate::VectorBasic),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorVectorBasicResult {
    type Encoded = WireProtocolErrorVectorBasicResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorVectorBasicResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorVectorBasicResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::VectorBasic,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorVectorBasicResult> {
    type EncodedOption = WireOptionalProtocolErrorVectorBasicResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorVectorBasicResult>
where
    ___E: ?Sized,
    ProtocolErrorVectorBasicResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorVectorBasicResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorVectorBasicResult> for ProtocolErrorVectorBasicResult {
    fn take_from(from: &WireProtocolErrorVectorBasicResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorVectorBasicResult>
    for Option<Box<ProtocolErrorVectorBasicResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorVectorBasicResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorVectorBasicResult`].
#[repr(transparent)]
pub struct WireProtocolErrorVectorBasicResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_vector_basic_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireVectorBasic),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorVectorBasicResult {
    pub fn as_ref(&self) -> crate::protocol_error_vector_basic_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_basic_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_vector_basic_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorVectorBasicResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorBasic>(raw, decoder)?
            }

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorVectorBasicResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireVectorBasic>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorVectorBasicResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorVectorBasicResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorVectorBasicResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalProtocolErrorVectorBasicResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorBasic>(raw, decoder)?
            }

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorVectorBasicResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct VectorCompound {
    pub vector_bits: Vec<crate::Bits>,

    pub vector_enum: Vec<crate::Enum>,

    pub vector_struct: Vec<crate::Struct>,

    pub vector_table: Vec<crate::Table>,

    pub vector_union: Vec<crate::Union>,

    pub vector_opt_struct: Vec<Option<Box<crate::Struct>>>,

    pub vector_opt_union: Vec<Option<Box<crate::Union>>>,
}

impl ::fidl_next::Encodable for VectorCompound {
    type Encoded = WireVectorCompound;
}

impl<___E> ::fidl_next::Encode<___E> for VectorCompound
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                vector_bits,
                vector_enum,
                vector_struct,
                vector_table,
                vector_union,
                vector_opt_struct,
                vector_opt_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.vector_bits, encoder, vector_bits)?;

        ::fidl_next::Encode::encode(&mut self.vector_enum, encoder, vector_enum)?;

        ::fidl_next::Encode::encode(&mut self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(&mut self.vector_union, encoder, vector_union)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_struct, encoder, vector_opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_opt_union, encoder, vector_opt_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorCompound> {
    type EncodedOption = ::fidl_next::WireBox<WireVectorCompound>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorCompound>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorCompound: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireVectorCompound> for VectorCompound {
    fn take_from(from: &WireVectorCompound) -> Self {
        Self {
            vector_bits: ::fidl_next::TakeFrom::take_from(&from.vector_bits),

            vector_enum: ::fidl_next::TakeFrom::take_from(&from.vector_enum),

            vector_struct: ::fidl_next::TakeFrom::take_from(&from.vector_struct),

            vector_table: ::fidl_next::TakeFrom::take_from(&from.vector_table),

            vector_union: ::fidl_next::TakeFrom::take_from(&from.vector_union),

            vector_opt_struct: ::fidl_next::TakeFrom::take_from(&from.vector_opt_struct),

            vector_opt_union: ::fidl_next::TakeFrom::take_from(&from.vector_opt_union),
        }
    }
}

/// The wire type corersponding to [`VectorCompound`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorCompound {
    pub vector_bits: ::fidl_next::WireVector<crate::WireBits>,

    pub vector_enum: ::fidl_next::WireVector<crate::WireEnum>,

    pub vector_struct: ::fidl_next::WireVector<crate::WireStruct>,

    pub vector_table: ::fidl_next::WireVector<crate::WireTable>,

    pub vector_union: ::fidl_next::WireVector<crate::WireUnion>,

    pub vector_opt_struct: ::fidl_next::WireVector<::fidl_next::WireBox<crate::WireStruct>>,

    pub vector_opt_union: ::fidl_next::WireVector<crate::WireOptionalUnion>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireVectorCompound
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut vector_bits,
                mut vector_enum,
                mut vector_struct,
                mut vector_table,
                mut vector_union,
                mut vector_opt_struct,
                mut vector_opt_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(vector_bits.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_enum.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_opt_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorVectorCompoundResult {
    Response(crate::VectorCompound),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorVectorCompoundResult {
    type Encoded = WireProtocolErrorVectorCompoundResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorVectorCompoundResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorVectorCompoundResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::VectorCompound,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorVectorCompoundResult> {
    type EncodedOption = WireOptionalProtocolErrorVectorCompoundResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorVectorCompoundResult>
where
    ___E: ?Sized,
    ProtocolErrorVectorCompoundResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorVectorCompoundResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorVectorCompoundResult>
    for ProtocolErrorVectorCompoundResult
{
    fn take_from(from: &WireProtocolErrorVectorCompoundResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorVectorCompoundResult>
    for Option<Box<ProtocolErrorVectorCompoundResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorVectorCompoundResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorVectorCompoundResult`].
#[repr(transparent)]
pub struct WireProtocolErrorVectorCompoundResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_vector_compound_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireVectorCompound),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorVectorCompoundResult {
    pub fn as_ref(&self) -> crate::protocol_error_vector_compound_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_compound_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_vector_compound_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorVectorCompoundResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorCompound>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorVectorCompoundResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireVectorCompound>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorVectorCompoundResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorVectorCompoundResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorVectorCompoundResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalProtocolErrorVectorCompoundResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorCompound>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorVectorCompoundResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct VectorOptional {
    pub opt_vector_uint8: Option<Vec<u8>>,

    pub opt_vector_string: Option<Vec<String>>,

    pub opt_vector_struct: Option<Vec<crate::Struct>>,

    pub opt_vector_opt_struct: Option<Vec<Option<Box<crate::Struct>>>>,
}

impl ::fidl_next::Encodable for VectorOptional {
    type Encoded = WireVectorOptional;
}

impl<___E> ::fidl_next::Encode<___E> for VectorOptional
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                opt_vector_uint8,
                opt_vector_string,
                opt_vector_struct,
                opt_vector_opt_struct,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.opt_vector_uint8, encoder, opt_vector_uint8)?;

        ::fidl_next::Encode::encode(&mut self.opt_vector_string, encoder, opt_vector_string)?;

        ::fidl_next::Encode::encode(&mut self.opt_vector_struct, encoder, opt_vector_struct)?;

        ::fidl_next::Encode::encode(
            &mut self.opt_vector_opt_struct,
            encoder,
            opt_vector_opt_struct,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<VectorOptional> {
    type EncodedOption = ::fidl_next::WireBox<WireVectorOptional>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<VectorOptional>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    VectorOptional: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireVectorOptional> for VectorOptional {
    fn take_from(from: &WireVectorOptional) -> Self {
        Self {
            opt_vector_uint8: ::fidl_next::TakeFrom::take_from(&from.opt_vector_uint8),

            opt_vector_string: ::fidl_next::TakeFrom::take_from(&from.opt_vector_string),

            opt_vector_struct: ::fidl_next::TakeFrom::take_from(&from.opt_vector_struct),

            opt_vector_opt_struct: ::fidl_next::TakeFrom::take_from(&from.opt_vector_opt_struct),
        }
    }
}

/// The wire type corersponding to [`VectorOptional`].
#[derive(Debug)]
#[repr(C)]
pub struct WireVectorOptional {
    pub opt_vector_uint8: ::fidl_next::WireOptionalVector<u8>,

    pub opt_vector_string: ::fidl_next::WireOptionalVector<::fidl_next::WireString>,

    pub opt_vector_struct: ::fidl_next::WireOptionalVector<crate::WireStruct>,

    pub opt_vector_opt_struct:
        ::fidl_next::WireOptionalVector<::fidl_next::WireBox<crate::WireStruct>>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireVectorOptional
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut opt_vector_uint8,
                mut opt_vector_string,
                mut opt_vector_struct,
                mut opt_vector_opt_struct,

            } = slot;
        }

        ::fidl_next::Decode::decode(opt_vector_uint8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_string.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vector_opt_struct.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorVectorOptionalResult {
    Response(crate::VectorOptional),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorVectorOptionalResult {
    type Encoded = WireProtocolErrorVectorOptionalResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorVectorOptionalResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorVectorOptionalResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::VectorOptional,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorVectorOptionalResult> {
    type EncodedOption = WireOptionalProtocolErrorVectorOptionalResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorVectorOptionalResult>
where
    ___E: ?Sized,
    ProtocolErrorVectorOptionalResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorVectorOptionalResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorVectorOptionalResult>
    for ProtocolErrorVectorOptionalResult
{
    fn take_from(from: &WireProtocolErrorVectorOptionalResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorVectorOptionalResult>
    for Option<Box<ProtocolErrorVectorOptionalResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorVectorOptionalResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorVectorOptionalResult`].
#[repr(transparent)]
pub struct WireProtocolErrorVectorOptionalResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_vector_optional_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireVectorOptional),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorVectorOptionalResult {
    pub fn as_ref(&self) -> crate::protocol_error_vector_optional_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_vector_optional_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_vector_optional_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorVectorOptionalResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorOptional>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorVectorOptionalResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireVectorOptional>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorVectorOptionalResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorVectorOptionalResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorVectorOptionalResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalProtocolErrorVectorOptionalResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireVectorOptional>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorVectorOptionalResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ProtocolErrorArrayVectorNestedResult {
    Response(crate::ArrayVectorNested),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorArrayVectorNestedResult {
    type Encoded = WireProtocolErrorArrayVectorNestedResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorArrayVectorNestedResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorArrayVectorNestedResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::ArrayVectorNested,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorArrayVectorNestedResult> {
    type EncodedOption = WireOptionalProtocolErrorArrayVectorNestedResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorArrayVectorNestedResult>
where
    ___E: ?Sized,
    ProtocolErrorArrayVectorNestedResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorArrayVectorNestedResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorArrayVectorNestedResult>
    for ProtocolErrorArrayVectorNestedResult
{
    fn take_from(from: &WireProtocolErrorArrayVectorNestedResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorArrayVectorNestedResult>
    for Option<Box<ProtocolErrorArrayVectorNestedResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorArrayVectorNestedResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorArrayVectorNestedResult`].
#[repr(transparent)]
pub struct WireProtocolErrorArrayVectorNestedResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_array_vector_nested_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireArrayVectorNested),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorArrayVectorNestedResult {
    pub fn as_ref(&self) -> crate::protocol_error_array_vector_nested_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_array_vector_nested_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_array_vector_nested_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorArrayVectorNestedResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayVectorNested>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorArrayVectorNestedResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireArrayVectorNested>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorArrayVectorNestedResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorArrayVectorNestedResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorArrayVectorNestedResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalProtocolErrorArrayVectorNestedResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireArrayVectorNested>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorArrayVectorNestedResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct ResourceStruct {}

impl ::fidl_next::Encodable for ResourceStruct {
    type Encoded = WireResourceStruct;
}

impl<___E> ::fidl_next::Encode<___E> for ResourceStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ResourceStruct> {
    type EncodedOption = ::fidl_next::WireBox<WireResourceStruct>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ResourceStruct>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ResourceStruct: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResourceStruct> for ResourceStruct {
    fn take_from(from: &WireResourceStruct) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`ResourceStruct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResourceStruct {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Debug)]
pub struct ResourceTable {}

impl ResourceTable {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for ResourceTable {
    type Encoded = WireResourceTable;
}

impl<___E> ::fidl_next::Encode<___E> for ResourceTable
where
    ___E: ::fidl_next::Encoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceTable { table } = slot);

        let max_ord = self.__max_ordinal();

        let mut backing = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            let mut slot = ::fidl_next::Slot::new(&mut backing);
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(slot.as_mut()),
            }
            preallocated.write_next(slot);
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResourceTable> for ResourceTable {
    fn take_from(from: &WireResourceTable) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`ResourceTable`].
#[repr(C)]
pub struct WireResourceTable {
    table: ::fidl_next::WireTable,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireResourceTable
where
    ___D: ::fidl_next::Decoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireResourceTable {}

impl ::core::fmt::Debug for WireResourceTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ResourceTable").finish()
    }
}

#[derive(Debug)]
pub enum ResourceUnion {
    B(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ResourceUnion {
    type Encoded = WireResourceUnion;
}

impl<___E> ::fidl_next::Encode<___E> for ResourceUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireResourceUnion { raw } = slot);

        match self {
            Self::B(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ResourceUnion> {
    type EncodedOption = WireOptionalResourceUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ResourceUnion>
where
    ___E: ?Sized,
    ResourceUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalResourceUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResourceUnion> for ResourceUnion {
    fn take_from(from: &WireResourceUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::B(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalResourceUnion> for Option<Box<ResourceUnion>> {
    fn take_from(from: &WireOptionalResourceUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ResourceUnion`].
#[repr(transparent)]
pub struct WireResourceUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod resource_union {
    pub enum Ref<'union> {
        B(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireResourceUnion {
    pub fn as_ref(&self) -> crate::resource_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::resource_union::Ref::B(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::resource_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireResourceUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalResourceUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalResourceUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireResourceUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalResourceUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalResourceUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct Resource {
    pub handle: ::fidl_next::fuchsia::zx::Handle,

    pub vmo: ::fidl_next::fuchsia::zx::Handle,

    pub client_end: ::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::zx::Handle, crate::Protocol>,

    pub server_end: ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::zx::Handle, crate::Protocol>,

    pub struct_: crate::ResourceStruct,

    pub table: crate::ResourceTable,

    pub union_: crate::ResourceUnion,

    pub opt_handle: Option<::fidl_next::fuchsia::zx::Handle>,

    pub opt_vmo: Option<::fidl_next::fuchsia::zx::Handle>,

    pub opt_client_end:
        ::fidl_next::bind::ClientEnd<Option<::fidl_next::fuchsia::zx::Handle>, crate::Protocol>,

    pub opt_server_end:
        ::fidl_next::bind::ServerEnd<Option<::fidl_next::fuchsia::zx::Handle>, crate::Protocol>,

    pub opt_struct: Option<Box<crate::ResourceStruct>>,

    pub opt_union: Option<Box<crate::ResourceUnion>>,

    pub array_handle: [::fidl_next::fuchsia::zx::Handle; 5],

    pub array_vmo: [::fidl_next::fuchsia::zx::Handle; 5],

    pub array_client_end:
        [::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::zx::Handle, crate::Protocol>; 5],

    pub array_server_end:
        [::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::zx::Handle, crate::Protocol>; 5],

    pub array_struct: [crate::ResourceStruct; 5],

    pub array_table: [crate::ResourceTable; 5],

    pub array_union: [crate::ResourceUnion; 5],

    pub vector_handle: Vec<::fidl_next::fuchsia::zx::Handle>,

    pub vector_vmo: Vec<::fidl_next::fuchsia::zx::Handle>,

    pub vector_client_end:
        Vec<::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::zx::Handle, crate::Protocol>>,

    pub vector_server_end:
        Vec<::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::zx::Handle, crate::Protocol>>,

    pub vector_struct: Vec<crate::ResourceStruct>,

    pub vector_table: Vec<crate::ResourceTable>,

    pub vector_union: Vec<crate::ResourceUnion>,
}

impl ::fidl_next::Encodable for Resource {
    type Encoded = WireResource;
}

impl<___E> ::fidl_next::Encode<___E> for Resource
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                handle,
                vmo,
                client_end,
                server_end,
                struct_,
                table,
                union_,
                opt_handle,
                opt_vmo,
                opt_client_end,
                opt_server_end,
                opt_struct,
                opt_union,
                array_handle,
                array_vmo,
                array_client_end,
                array_server_end,
                array_struct,
                array_table,
                array_union,
                vector_handle,
                vector_vmo,
                vector_client_end,
                vector_server_end,
                vector_struct,
                vector_table,
                vector_union,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.handle, encoder, handle)?;

        ::fidl_next::Encode::encode(&mut self.vmo, encoder, vmo)?;

        ::fidl_next::Encode::encode(&mut self.client_end, encoder, client_end)?;

        ::fidl_next::Encode::encode(&mut self.server_end, encoder, server_end)?;

        ::fidl_next::Encode::encode(&mut self.struct_, encoder, struct_)?;

        ::fidl_next::Encode::encode(&mut self.table, encoder, table)?;

        ::fidl_next::Encode::encode(&mut self.union_, encoder, union_)?;

        ::fidl_next::Encode::encode(&mut self.opt_handle, encoder, opt_handle)?;

        ::fidl_next::Encode::encode(&mut self.opt_vmo, encoder, opt_vmo)?;

        ::fidl_next::Encode::encode(&mut self.opt_client_end, encoder, opt_client_end)?;

        ::fidl_next::Encode::encode(&mut self.opt_server_end, encoder, opt_server_end)?;

        ::fidl_next::Encode::encode(&mut self.opt_struct, encoder, opt_struct)?;

        ::fidl_next::Encode::encode(&mut self.opt_union, encoder, opt_union)?;

        ::fidl_next::Encode::encode(&mut self.array_handle, encoder, array_handle)?;

        ::fidl_next::Encode::encode(&mut self.array_vmo, encoder, array_vmo)?;

        ::fidl_next::Encode::encode(&mut self.array_client_end, encoder, array_client_end)?;

        ::fidl_next::Encode::encode(&mut self.array_server_end, encoder, array_server_end)?;

        ::fidl_next::Encode::encode(&mut self.array_struct, encoder, array_struct)?;

        ::fidl_next::Encode::encode(&mut self.array_table, encoder, array_table)?;

        ::fidl_next::Encode::encode(&mut self.array_union, encoder, array_union)?;

        ::fidl_next::Encode::encode(&mut self.vector_handle, encoder, vector_handle)?;

        ::fidl_next::Encode::encode(&mut self.vector_vmo, encoder, vector_vmo)?;

        ::fidl_next::Encode::encode(&mut self.vector_client_end, encoder, vector_client_end)?;

        ::fidl_next::Encode::encode(&mut self.vector_server_end, encoder, vector_server_end)?;

        ::fidl_next::Encode::encode(&mut self.vector_struct, encoder, vector_struct)?;

        ::fidl_next::Encode::encode(&mut self.vector_table, encoder, vector_table)?;

        ::fidl_next::Encode::encode(&mut self.vector_union, encoder, vector_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Resource> {
    type EncodedOption = ::fidl_next::WireBox<WireResource>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Resource>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Resource: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireResource> for Resource {
    fn take_from(from: &WireResource) -> Self {
        Self {
            handle: ::fidl_next::TakeFrom::take_from(&from.handle),

            vmo: ::fidl_next::TakeFrom::take_from(&from.vmo),

            client_end: ::fidl_next::TakeFrom::take_from(&from.client_end),

            server_end: ::fidl_next::TakeFrom::take_from(&from.server_end),

            struct_: ::fidl_next::TakeFrom::take_from(&from.struct_),

            table: ::fidl_next::TakeFrom::take_from(&from.table),

            union_: ::fidl_next::TakeFrom::take_from(&from.union_),

            opt_handle: ::fidl_next::TakeFrom::take_from(&from.opt_handle),

            opt_vmo: ::fidl_next::TakeFrom::take_from(&from.opt_vmo),

            opt_client_end: ::fidl_next::TakeFrom::take_from(&from.opt_client_end),

            opt_server_end: ::fidl_next::TakeFrom::take_from(&from.opt_server_end),

            opt_struct: ::fidl_next::TakeFrom::take_from(&from.opt_struct),

            opt_union: ::fidl_next::TakeFrom::take_from(&from.opt_union),

            array_handle: ::fidl_next::TakeFrom::take_from(&from.array_handle),

            array_vmo: ::fidl_next::TakeFrom::take_from(&from.array_vmo),

            array_client_end: ::fidl_next::TakeFrom::take_from(&from.array_client_end),

            array_server_end: ::fidl_next::TakeFrom::take_from(&from.array_server_end),

            array_struct: ::fidl_next::TakeFrom::take_from(&from.array_struct),

            array_table: ::fidl_next::TakeFrom::take_from(&from.array_table),

            array_union: ::fidl_next::TakeFrom::take_from(&from.array_union),

            vector_handle: ::fidl_next::TakeFrom::take_from(&from.vector_handle),

            vector_vmo: ::fidl_next::TakeFrom::take_from(&from.vector_vmo),

            vector_client_end: ::fidl_next::TakeFrom::take_from(&from.vector_client_end),

            vector_server_end: ::fidl_next::TakeFrom::take_from(&from.vector_server_end),

            vector_struct: ::fidl_next::TakeFrom::take_from(&from.vector_struct),

            vector_table: ::fidl_next::TakeFrom::take_from(&from.vector_table),

            vector_union: ::fidl_next::TakeFrom::take_from(&from.vector_union),
        }
    }
}

/// The wire type corersponding to [`Resource`].
#[derive(Debug)]
#[repr(C)]
pub struct WireResource {
    pub handle: ::fidl_next::fuchsia::WireHandle,

    pub vmo: ::fidl_next::fuchsia::WireHandle,

    pub client_end: ::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::WireHandle, crate::Protocol>,

    pub server_end: ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireHandle, crate::Protocol>,

    pub struct_: crate::WireResourceStruct,

    pub table: crate::WireResourceTable,

    pub union_: crate::WireResourceUnion,

    pub opt_handle: ::fidl_next::fuchsia::WireOptionalHandle,

    pub opt_vmo: ::fidl_next::fuchsia::WireOptionalHandle,

    pub opt_client_end:
        ::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::WireOptionalHandle, crate::Protocol>,

    pub opt_server_end:
        ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireOptionalHandle, crate::Protocol>,

    pub opt_struct: ::fidl_next::WireBox<crate::WireResourceStruct>,

    pub opt_union: crate::WireOptionalResourceUnion,

    pub array_handle: [::fidl_next::fuchsia::WireHandle; 5],

    pub array_vmo: [::fidl_next::fuchsia::WireHandle; 5],

    pub array_client_end:
        [::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::WireHandle, crate::Protocol>; 5],

    pub array_server_end:
        [::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireHandle, crate::Protocol>; 5],

    pub array_struct: [crate::WireResourceStruct; 5],

    pub array_table: [crate::WireResourceTable; 5],

    pub array_union: [crate::WireResourceUnion; 5],

    pub vector_handle: ::fidl_next::WireVector<::fidl_next::fuchsia::WireHandle>,

    pub vector_vmo: ::fidl_next::WireVector<::fidl_next::fuchsia::WireHandle>,

    pub vector_client_end: ::fidl_next::WireVector<
        ::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::WireHandle, crate::Protocol>,
    >,

    pub vector_server_end: ::fidl_next::WireVector<
        ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireHandle, crate::Protocol>,
    >,

    pub vector_struct: ::fidl_next::WireVector<crate::WireResourceStruct>,

    pub vector_table: ::fidl_next::WireVector<crate::WireResourceTable>,

    pub vector_union: ::fidl_next::WireVector<crate::WireResourceUnion>,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireResource
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut handle,
                mut vmo,
                mut client_end,
                mut server_end,
                mut struct_,
                mut table,
                mut union_,
                mut opt_handle,
                mut opt_vmo,
                mut opt_client_end,
                mut opt_server_end,
                mut opt_struct,
                mut opt_union,
                mut array_handle,
                mut array_vmo,
                mut array_client_end,
                mut array_server_end,
                mut array_struct,
                mut array_table,
                mut array_union,
                mut vector_handle,
                mut vector_vmo,
                mut vector_client_end,
                mut vector_server_end,
                mut vector_struct,
                mut vector_table,
                mut vector_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(struct_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(union_.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(opt_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(array_union.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_handle.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_vmo.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_server_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_struct.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_table.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vector_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub enum ProtocolErrorResourceResult {
    Response(crate::Resource),

    Err(u32),
}

impl ::fidl_next::Encodable for ProtocolErrorResourceResult {
    type Encoded = WireProtocolErrorResourceResult;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolErrorResourceResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireProtocolErrorResourceResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<___E, crate::Resource>(
                value, 1, encoder, raw,
            )?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolErrorResourceResult> {
    type EncodedOption = WireOptionalProtocolErrorResourceResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolErrorResourceResult>
where
    ___E: ?Sized,
    ProtocolErrorResourceResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalProtocolErrorResourceResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolErrorResourceResult> for ProtocolErrorResourceResult {
    fn take_from(from: &WireProtocolErrorResourceResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalProtocolErrorResourceResult>
    for Option<Box<ProtocolErrorResourceResult>>
{
    fn take_from(from: &WireOptionalProtocolErrorResourceResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ProtocolErrorResourceResult`].
#[repr(transparent)]
pub struct WireProtocolErrorResourceResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod protocol_error_resource_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireResource),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireProtocolErrorResourceResult {
    pub fn as_ref(&self) -> crate::protocol_error_resource_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::protocol_error_resource_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::protocol_error_resource_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireProtocolErrorResourceResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireResource>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireProtocolErrorResourceResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireResource>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalProtocolErrorResourceResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalProtocolErrorResourceResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireProtocolErrorResourceResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireOptionalProtocolErrorResourceResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WireResource>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalProtocolErrorResourceResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the Protocol protocol.
#[derive(Debug)]
pub struct Protocol;

pub mod protocol {

    pub struct OneWayBasic;

    impl ::fidl_next::bind::Method for OneWayBasic {
        const ORDINAL: u64 = 8948968077914418681;

        type Protocol = crate::Protocol;

        type Request = crate::WireBasic;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayBasic;

    impl ::fidl_next::bind::Method for TwoWayBasic {
        const ORDINAL: u64 = 2331618702752598159;

        type Protocol = crate::Protocol;

        type Request = crate::WireBasic;

        type Response = crate::WireBasic;
    }

    pub struct ErrorBasic;

    impl ::fidl_next::bind::Method for ErrorBasic {
        const ORDINAL: u64 = 5016634351643393939;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorBasicResult;
    }

    pub struct EventBasic;

    impl ::fidl_next::bind::Method for EventBasic {
        const ORDINAL: u64 = 5892309624949902400;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireBasic;
    }

    pub struct OneWayCompound;

    impl ::fidl_next::bind::Method for OneWayCompound {
        const ORDINAL: u64 = 3153289648860022476;

        type Protocol = crate::Protocol;

        type Request = crate::WireCompound;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayCompound;

    impl ::fidl_next::bind::Method for TwoWayCompound {
        const ORDINAL: u64 = 8787219719097524529;

        type Protocol = crate::Protocol;

        type Request = crate::WireCompound;

        type Response = crate::WireCompound;
    }

    pub struct ErrorCompound;

    impl ::fidl_next::bind::Method for ErrorCompound {
        const ORDINAL: u64 = 2990809657626249085;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorCompoundResult;
    }

    pub struct EventCompound;

    impl ::fidl_next::bind::Method for EventCompound {
        const ORDINAL: u64 = 7024581948727571669;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireCompound;
    }

    pub struct OneWayArrayBasic;

    impl ::fidl_next::bind::Method for OneWayArrayBasic {
        const ORDINAL: u64 = 7125516817014311449;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayBasic;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayArrayBasic;

    impl ::fidl_next::bind::Method for TwoWayArrayBasic {
        const ORDINAL: u64 = 5309034178175279380;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayBasic;

        type Response = crate::WireArrayBasic;
    }

    pub struct ErrorArrayBasic;

    impl ::fidl_next::bind::Method for ErrorArrayBasic {
        const ORDINAL: u64 = 1084731895342694265;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorArrayBasicResult;
    }

    pub struct EventArrayBasic;

    impl ::fidl_next::bind::Method for EventArrayBasic {
        const ORDINAL: u64 = 5888282827283820590;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireArrayBasic;
    }

    pub struct OneWayArrayCompound;

    impl ::fidl_next::bind::Method for OneWayArrayCompound {
        const ORDINAL: u64 = 5064659223443251357;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayCompound;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayArrayCompound;

    impl ::fidl_next::bind::Method for TwoWayArrayCompound {
        const ORDINAL: u64 = 849744466051983995;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayCompound;

        type Response = crate::WireArrayCompound;
    }

    pub struct ErrorArrayCompound;

    impl ::fidl_next::bind::Method for ErrorArrayCompound {
        const ORDINAL: u64 = 5919277476782807556;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorArrayCompoundResult;
    }

    pub struct EventArrayCompound;

    impl ::fidl_next::bind::Method for EventArrayCompound {
        const ORDINAL: u64 = 2189769767733851157;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireArrayCompound;
    }

    pub struct OneWayVectorBasic;

    impl ::fidl_next::bind::Method for OneWayVectorBasic {
        const ORDINAL: u64 = 5733220720079947351;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorBasic;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayVectorBasic;

    impl ::fidl_next::bind::Method for TwoWayVectorBasic {
        const ORDINAL: u64 = 8674156353091415668;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorBasic;

        type Response = crate::WireVectorBasic;
    }

    pub struct ErrorVectorBasic;

    impl ::fidl_next::bind::Method for ErrorVectorBasic {
        const ORDINAL: u64 = 875941614196965234;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorVectorBasicResult;
    }

    pub struct EventVectorBasic;

    impl ::fidl_next::bind::Method for EventVectorBasic {
        const ORDINAL: u64 = 4583890770109526006;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireVectorBasic;
    }

    pub struct OneWayVectorCompound;

    impl ::fidl_next::bind::Method for OneWayVectorCompound {
        const ORDINAL: u64 = 1853985797298830992;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorCompound;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayVectorCompound;

    impl ::fidl_next::bind::Method for TwoWayVectorCompound {
        const ORDINAL: u64 = 3968024057912959924;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorCompound;

        type Response = crate::WireVectorCompound;
    }

    pub struct ErrorVectorCompound;

    impl ::fidl_next::bind::Method for ErrorVectorCompound {
        const ORDINAL: u64 = 8506780203315865989;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorVectorCompoundResult;
    }

    pub struct EventVectorCompound;

    impl ::fidl_next::bind::Method for EventVectorCompound {
        const ORDINAL: u64 = 6026375226599919603;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireVectorCompound;
    }

    pub struct OneWayVectorOptional;

    impl ::fidl_next::bind::Method for OneWayVectorOptional {
        const ORDINAL: u64 = 1530215841195476271;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorOptional;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayVectorOptional;

    impl ::fidl_next::bind::Method for TwoWayVectorOptional {
        const ORDINAL: u64 = 1030024737742222323;

        type Protocol = crate::Protocol;

        type Request = crate::WireVectorOptional;

        type Response = crate::WireVectorOptional;
    }

    pub struct ErrorVectorOptional;

    impl ::fidl_next::bind::Method for ErrorVectorOptional {
        const ORDINAL: u64 = 6406191217027936606;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorVectorOptionalResult;
    }

    pub struct EventVectorOptional;

    impl ::fidl_next::bind::Method for EventVectorOptional {
        const ORDINAL: u64 = 1684763340073130077;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireVectorOptional;
    }

    pub struct OneWayArrayVectorNested;

    impl ::fidl_next::bind::Method for OneWayArrayVectorNested {
        const ORDINAL: u64 = 5912603762133524183;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayVectorNested;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayArrayVectorNested;

    impl ::fidl_next::bind::Method for TwoWayArrayVectorNested {
        const ORDINAL: u64 = 5351275678438791132;

        type Protocol = crate::Protocol;

        type Request = crate::WireArrayVectorNested;

        type Response = crate::WireArrayVectorNested;
    }

    pub struct ErrorArrayVectorNested;

    impl ::fidl_next::bind::Method for ErrorArrayVectorNested {
        const ORDINAL: u64 = 9085604921605802151;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorArrayVectorNestedResult;
    }

    pub struct EventArrayVectorNested;

    impl ::fidl_next::bind::Method for EventArrayVectorNested {
        const ORDINAL: u64 = 1228201560727880574;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireArrayVectorNested;
    }

    pub struct OneWayResource;

    impl ::fidl_next::bind::Method for OneWayResource {
        const ORDINAL: u64 = 6553996787849601058;

        type Protocol = crate::Protocol;

        type Request = crate::WireResource;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct TwoWayResource;

    impl ::fidl_next::bind::Method for TwoWayResource {
        const ORDINAL: u64 = 1802709005492464987;

        type Protocol = crate::Protocol;

        type Request = crate::WireResource;

        type Response = crate::WireResource;
    }

    pub struct ErrorResource;

    impl ::fidl_next::bind::Method for ErrorResource {
        const ORDINAL: u64 = 6568609240497354166;

        type Protocol = crate::Protocol;

        type Request = ();

        type Response = crate::WireProtocolErrorResourceResult;
    }

    pub struct EventResource;

    impl ::fidl_next::bind::Method for EventResource {
        const ORDINAL: u64 = 5745997765922613643;

        type Protocol = crate::Protocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireResource;
    }
}

/// A helper trait for the `Protocol` client sender.
pub trait ProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn one_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireBasic>;

    fn two_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireBasic>;

    fn error_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireCompound>;

    fn two_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireCompound>;

    fn error_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayBasic>;

    fn two_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayArrayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayBasic>;

    fn error_array_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorArrayBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayCompound>;

    fn two_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayArrayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayCompound>;

    fn error_array_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorArrayCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorBasic>;

    fn two_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayVectorBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorBasic>;

    fn error_vector_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorVectorBasic>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorCompound>;

    fn two_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayVectorCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorCompound>;

    fn error_vector_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorVectorCompound>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorOptional>;

    fn two_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayVectorOptional>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorOptional>;

    fn error_vector_optional(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorVectorOptional>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayVectorNested>;

    fn two_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayArrayVectorNested>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayVectorNested>;

    fn error_array_vector_nested(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorArrayVectorNested>,
        ::fidl_next::EncodeError,
    >;

    fn one_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireResource>;

    fn two_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayResource>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireResource>;

    fn error_resource(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorResource>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> ProtocolClientSender<___T> for ::fidl_next::bind::ClientSender<___T, Protocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn one_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireBasic>,
    {
        self.as_untyped().send_one_way(8948968077914418681, request)
    }

    fn two_way_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireBasic>,
    {
        self.as_untyped()
            .send_two_way(2331618702752598159, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5016634351643393939, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn one_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireCompound>,
    {
        self.as_untyped().send_one_way(3153289648860022476, request)
    }

    fn two_way_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireCompound>,
    {
        self.as_untyped()
            .send_two_way(8787219719097524529, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(2990809657626249085, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn one_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayBasic>,
    {
        self.as_untyped().send_one_way(7125516817014311449, request)
    }

    fn two_way_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayArrayBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayBasic>,
    {
        self.as_untyped()
            .send_two_way(5309034178175279380, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_array_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorArrayBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1084731895342694265, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn one_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayCompound>,
    {
        self.as_untyped().send_one_way(5064659223443251357, request)
    }

    fn two_way_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayArrayCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayCompound>,
    {
        self.as_untyped()
            .send_two_way(849744466051983995, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_array_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorArrayCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5919277476782807556, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn one_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorBasic>,
    {
        self.as_untyped().send_one_way(5733220720079947351, request)
    }

    fn two_way_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayVectorBasic>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorBasic>,
    {
        self.as_untyped()
            .send_two_way(8674156353091415668, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_vector_basic(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorVectorBasic>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(875941614196965234, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn one_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorCompound>,
    {
        self.as_untyped().send_one_way(1853985797298830992, request)
    }

    fn two_way_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayVectorCompound>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorCompound>,
    {
        self.as_untyped()
            .send_two_way(3968024057912959924, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_vector_compound(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorVectorCompound>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(8506780203315865989, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn one_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorOptional>,
    {
        self.as_untyped().send_one_way(1530215841195476271, request)
    }

    fn two_way_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayVectorOptional>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorOptional>,
    {
        self.as_untyped()
            .send_two_way(1030024737742222323, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_vector_optional(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorVectorOptional>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6406191217027936606, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn one_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayVectorNested>,
    {
        self.as_untyped().send_one_way(5912603762133524183, request)
    }

    fn two_way_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayArrayVectorNested>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayVectorNested>,
    {
        self.as_untyped()
            .send_two_way(5351275678438791132, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_array_vector_nested(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorArrayVectorNested>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9085604921605802151, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn one_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireResource>,
    {
        self.as_untyped().send_one_way(6553996787849601058, request)
    }

    fn two_way_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::TwoWayResource>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireResource>,
    {
        self.as_untyped()
            .send_two_way(1802709005492464987, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_resource(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, protocol::ErrorResource>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6568609240497354166, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn event_basic(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventBasic>,
    );

    fn event_compound(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventCompound>,
    );

    fn event_array_basic(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventArrayBasic>,
    );

    fn event_array_compound(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventArrayCompound>,
    );

    fn event_vector_basic(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventVectorBasic>,
    );

    fn event_vector_compound(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventVectorCompound>,
    );

    fn event_vector_optional(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventVectorOptional>,
    );

    fn event_array_vector_nested(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventArrayVectorNested>,
    );

    fn event_resource(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, Protocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, protocol::EventResource>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ProtocolClientHandler<___T>,

    for<'buf> crate::WireBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorBasicResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorCompoundResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorArrayBasicResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorArrayCompoundResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorVectorBasicResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorVectorCompoundResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorOptional:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorVectorOptionalResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorOptional:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayVectorNested:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorArrayVectorNestedResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayVectorNested:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireResource:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireProtocolErrorResourceResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireResource:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5892309624949902400 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_basic(sender, buffer);
            }

            7024581948727571669 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_compound(sender, buffer);
            }

            5888282827283820590 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_array_basic(sender, buffer);
            }

            2189769767733851157 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_array_compound(sender, buffer);
            }

            4583890770109526006 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_basic(sender, buffer);
            }

            6026375226599919603 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_compound(sender, buffer);
            }

            1684763340073130077 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_vector_optional(sender, buffer);
            }

            1228201560727880574 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_array_vector_nested(sender, buffer);
            }

            5745997765922613643 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_resource(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Protocol` server sender.
pub trait ProtocolServerSender<___T: ::fidl_next::protocol::Transport> {
    fn event_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireBasic>;

    fn event_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireCompound>;

    fn event_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayBasic>;

    fn event_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayCompound>;

    fn event_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorBasic>;

    fn event_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorCompound>;

    fn event_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorOptional>;

    fn event_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayVectorNested>;

    fn event_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireResource>;
}

impl<___T> ProtocolServerSender<___T> for ::fidl_next::bind::ServerSender<___T, Protocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn event_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireBasic>,
    {
        self.as_untyped().send_event(5892309624949902400, request)
    }

    fn event_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireCompound>,
    {
        self.as_untyped().send_event(7024581948727571669, request)
    }

    fn event_array_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayBasic>,
    {
        self.as_untyped().send_event(5888282827283820590, request)
    }

    fn event_array_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayCompound>,
    {
        self.as_untyped().send_event(2189769767733851157, request)
    }

    fn event_vector_basic<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorBasic>,
    {
        self.as_untyped().send_event(4583890770109526006, request)
    }

    fn event_vector_compound<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorCompound>,
    {
        self.as_untyped().send_event(6026375226599919603, request)
    }

    fn event_vector_optional<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireVectorOptional>,
    {
        self.as_untyped().send_event(1684763340073130077, request)
    }

    fn event_array_vector_nested<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R:
            ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireArrayVectorNested>,
    {
        self.as_untyped().send_event(1228201560727880574, request)
    }

    fn event_resource<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<___T::SendBuffer, Encoded = crate::WireResource>,
    {
        self.as_untyped().send_event(5745997765922613643, request)
    }
}

/// A server handler for the Protocol protocol.
///
/// See [`Protocol`] for more details.
pub trait ProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn one_way_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayBasic>,
    );

    fn two_way_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayBasic>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayBasic>,
    );

    fn error_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorBasic>,
    );

    fn one_way_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayCompound>,
    );

    fn two_way_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayCompound>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayCompound>,
    );

    fn error_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorCompound>,
    );

    fn one_way_array_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayArrayBasic>,
    );

    fn two_way_array_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayArrayBasic>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayArrayBasic>,
    );

    fn error_array_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorArrayBasic>,
    );

    fn one_way_array_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayArrayCompound>,
    );

    fn two_way_array_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayArrayCompound>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayArrayCompound>,
    );

    fn error_array_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorArrayCompound>,
    );

    fn one_way_vector_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayVectorBasic>,
    );

    fn two_way_vector_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayVectorBasic>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayVectorBasic>,
    );

    fn error_vector_basic(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorVectorBasic>,
    );

    fn one_way_vector_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayVectorCompound>,
    );

    fn two_way_vector_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayVectorCompound>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayVectorCompound>,
    );

    fn error_vector_compound(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorVectorCompound>,
    );

    fn one_way_vector_optional(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayVectorOptional>,
    );

    fn two_way_vector_optional(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayVectorOptional>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayVectorOptional>,
    );

    fn error_vector_optional(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorVectorOptional>,
    );

    fn one_way_array_vector_nested(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayArrayVectorNested>,
    );

    fn two_way_array_vector_nested(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayArrayVectorNested>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayArrayVectorNested>,
    );

    fn error_array_vector_nested(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorArrayVectorNested>,
    );

    fn one_way_resource(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::OneWayResource>,
    );

    fn two_way_resource(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, protocol::TwoWayResource>,

        responder: ::fidl_next::bind::Responder<protocol::TwoWayResource>,
    );

    fn error_resource(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, Protocol>,

        responder: ::fidl_next::bind::Responder<protocol::ErrorResource>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for Protocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ProtocolServerHandler<___T>,

    for<'buf> crate::WireBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorBasic:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorCompound:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorOptional:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireVectorOptional:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayVectorNested:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireArrayVectorNested:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireResource:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireResource:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            8948968077914418681 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_basic(sender, buffer);
            }

            3153289648860022476 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_compound(sender, buffer);
            }

            7125516817014311449 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_basic(sender, buffer);
            }

            5064659223443251357 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_compound(sender, buffer);
            }

            5733220720079947351 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_basic(sender, buffer);
            }

            1853985797298830992 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_compound(sender, buffer);
            }

            1530215841195476271 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_vector_optional(sender, buffer);
            }

            5912603762133524183 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_array_vector_nested(sender, buffer);
            }

            6553996787849601058 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.one_way_resource(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2331618702752598159 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_basic(sender, buffer, responder);
            }

            5016634351643393939 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_basic(sender, responder);
            }

            8787219719097524529 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_compound(sender, buffer, responder);
            }

            2990809657626249085 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_compound(sender, responder);
            }

            5309034178175279380 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_basic(sender, buffer, responder);
            }

            1084731895342694265 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_array_basic(sender, responder);
            }

            849744466051983995 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_compound(sender, buffer, responder);
            }

            5919277476782807556 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_array_compound(sender, responder);
            }

            8674156353091415668 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_basic(sender, buffer, responder);
            }

            875941614196965234 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_vector_basic(sender, responder);
            }

            3968024057912959924 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_compound(sender, buffer, responder);
            }

            8506780203315865989 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_vector_compound(sender, responder);
            }

            1030024737742222323 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_vector_optional(sender, buffer, responder);
            }

            6406191217027936606 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_vector_optional(sender, responder);
            }

            5351275678438791132 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_array_vector_nested(sender, buffer, responder);
            }

            9085604921605802151 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_array_vector_nested(sender, responder);
            }

            1802709005492464987 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.two_way_resource(sender, buffer, responder);
            }

            6568609240497354166 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_resource(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}
