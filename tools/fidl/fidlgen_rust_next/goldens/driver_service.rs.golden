// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the DriverOnlyService service.
#[derive(Debug)]
pub struct DriverOnlyService;

impl ::fidl_next::Service for DriverOnlyService {
    const SERVICE_NAME: &'static str = "test.driverservice.DriverOnlyService";
    const MEMBER_NAMES: &'static [&'static str] = &["member"];
}

/// A helper trait for instances of the `DriverOnlyService` service.
pub trait DriverOnlyServiceInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;

    /// Attempts to connect the given server end to the `member` member.
    fn connect_to_member(
        &self,
        server_end: ::fidl_next::ServerEnd<
            ::fidl_next::ClientEnd<crate::SomeDriverProtocol, ::fidl_next::fuchsia::zx::Channel>,
            Self::Transport,
        >,
    ) -> Result<(), Self::Error>;
}

impl<___I> DriverOnlyServiceInstance for ::fidl_next::ServiceInstance<___I, DriverOnlyService>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;

    fn connect_to_member(
        &self,
        server_end: ::fidl_next::ServerEnd<
            ::fidl_next::ClientEnd<crate::SomeDriverProtocol, ::fidl_next::fuchsia::zx::Channel>,
            Self::Transport,
        >,
    ) -> Result<(), Self::Error> {
        self.as_untyped().connect_to("member", server_end.into_untyped())
    }
}

/// The type corresponding to the SomeDriverProtocol protocol.
#[derive(Debug)]
pub struct SomeDriverProtocol;

pub mod some_driver_protocol {
    pub mod prelude {
        pub use crate::{
            some_driver_protocol, SomeDriverProtocol, SomeDriverProtocolClientHandler,
            SomeDriverProtocolServerHandler,
        };
    }

    mod ___detail {
        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::SomeDriverProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = SomeDriverProtocolClientSender<___T>;
            type ServerSender = SomeDriverProtocolServerSender<___T>;
        }

        /// The client sender for the `SomeDriverProtocol` protocol.
        pub struct SomeDriverProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> SomeDriverProtocolClientSender<___T> where ___T: ::fidl_next::Transport {}

        /// The server sender for the `SomeDriverProtocol` protocol.
        #[repr(transparent)]
        pub struct SomeDriverProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> SomeDriverProtocolServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the SomeDriverProtocol protocol.
///
/// See [`SomeDriverProtocol`] for more details.
pub trait SomeDriverProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for SomeDriverProtocol
where
    ___H: SomeDriverProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the SomeDriverProtocol protocol.
///
/// See [`SomeDriverProtocol`] for more details.
pub trait SomeDriverProtocolServerHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for SomeDriverProtocol
where
    ___H: SomeDriverProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `SomeDriverProtocol`
    /// protocol.
    pub type SomeDriverProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::SomeDriverProtocol>;

    #[cfg(feature = "driver")]
    impl ::core::convert::From<crate::SomeDriverProtocol>
        for ::fidl_test_driverservice::SomeDriverProtocolMarker
    {
        #[inline]
        fn from(_: crate::SomeDriverProtocol) -> Self {
            Self
        }
    }
}
