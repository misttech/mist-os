// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub const ALL_BINDINGS: u32 = 0;

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding4 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding4;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding4
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding4> {
    type EncodedOption = ::fidl_next::WireBox<WireShouldNeverAppearInAnyBinding4>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding4>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding4: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding4> for ShouldNeverAppearInAnyBinding4 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding4) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding4`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding4 {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding4 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding4
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct ShouldNeverAppearInAnyBinding5 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding5 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding5 {
    type Encoded = WireShouldNeverAppearInAnyBinding5;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding5
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding5 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding5> for ShouldNeverAppearInAnyBinding5 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding5) -> Self {
        Self { a: from.a().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding5`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding5 {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding5 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding5
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireShouldNeverAppearInAnyBinding5 {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding5").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding6 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding6 {
    type Encoded = WireShouldNeverAppearInAnyBinding6;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding6
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding6 { raw } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding6> {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding6;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding6>
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding6: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding6 { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding6> for ShouldNeverAppearInAnyBinding6 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding6) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding6>
    for Option<Box<ShouldNeverAppearInAnyBinding6>>
{
    #[inline]
    fn take_from(from: &WireOptionalShouldNeverAppearInAnyBinding6) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding6`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding6 {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding6 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod should_never_appear_in_any_binding6 {
    pub enum Ref<'union> {
        A(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding6 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding6::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding6::Ref::A(unsafe {
                self.raw.get().deref_unchecked::<bool>()
            }),

            unknown => crate::should_never_appear_in_any_binding6::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding6 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding6
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding6 {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalShouldNeverAppearInAnyBinding6 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalShouldNeverAppearInAnyBinding6 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding6> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding6 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding6 {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding6
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct AllowedDeniedResponse {
    pub should_never_appear_in_any_binding_4: crate::ShouldNeverAppearInAnyBinding4,

    pub should_never_appear_in_any_binding_5: crate::ShouldNeverAppearInAnyBinding5,

    pub should_never_appear_in_any_binding_6: crate::ShouldNeverAppearInAnyBinding6,
}

impl ::fidl_next::Encodable for AllowedDeniedResponse {
    type Encoded = WireAllowedDeniedResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for AllowedDeniedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_4,
                should_never_appear_in_any_binding_5,
                should_never_appear_in_any_binding_6,

            } = out;
        }

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_4,
            encoder,
            should_never_appear_in_any_binding_4,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_5,
            encoder,
            should_never_appear_in_any_binding_5,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_6,
            encoder,
            should_never_appear_in_any_binding_6,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<AllowedDeniedResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireAllowedDeniedResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<AllowedDeniedResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    AllowedDeniedResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireAllowedDeniedResponse> for AllowedDeniedResponse {
    #[inline]
    fn take_from(from: &WireAllowedDeniedResponse) -> Self {
        Self {
            should_never_appear_in_any_binding_4: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_4,
            ),

            should_never_appear_in_any_binding_5: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_5,
            ),

            should_never_appear_in_any_binding_6: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_6,
            ),
        }
    }
}

/// The wire type corresponding to [`AllowedDeniedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireAllowedDeniedResponse {
    pub should_never_appear_in_any_binding_4: crate::WireShouldNeverAppearInAnyBinding4,

    pub should_never_appear_in_any_binding_5: crate::WireShouldNeverAppearInAnyBinding5,

    pub should_never_appear_in_any_binding_6: crate::WireShouldNeverAppearInAnyBinding6,
}

unsafe impl ::fidl_next::ZeroPadding for WireAllowedDeniedResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireAllowedDeniedResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_4,
                mut should_never_appear_in_any_binding_5,
                mut should_never_appear_in_any_binding_6,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_6.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the Allowed protocol.
#[derive(Debug)]
pub struct Allowed;

pub mod allowed {
    pub mod prelude {
        pub use crate::{
            allowed, Allowed, AllowedClientHandler, AllowedClientSender, AllowedServerHandler,
            AllowedServerSender,
        };

        pub use crate::AllowedDeniedResponse;
    }

    pub struct Denied;

    impl ::fidl_next::Method for Denied {
        const ORDINAL: u64 = 3826178105137551123;

        type Protocol = crate::Allowed;

        type Request = ();

        type Response =
            ::fidl_next::WireResult<crate::WireAllowedDeniedResponse, ::fidl_next::WireU32>;
    }
}

/// A helper trait for the `Allowed` client sender.
pub trait AllowedClientSender {
    type Transport: ::fidl_next::Transport;

    fn denied(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, allowed::Denied>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> AllowedClientSender for ::fidl_next::ClientSender<___T, Allowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn denied(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, allowed::Denied>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(3826178105137551123, &mut ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the Allowed protocol.
///
/// See [`Allowed`] for more details.
pub trait AllowedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Allowed
where
    ___T: ::fidl_next::Transport,
    ___H: AllowedClientHandler<___T>,

    <allowed::Denied as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Allowed` server sender.
pub trait AllowedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> AllowedServerSender for ::fidl_next::ServerSender<___T, Allowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the Allowed protocol.
///
/// See [`Allowed`] for more details.
pub trait AllowedServerHandler<___T: ::fidl_next::Transport> {
    fn denied(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Allowed>,

        responder: ::fidl_next::Responder<allowed::Denied>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Allowed
where
    ___T: ::fidl_next::Transport,
    ___H: AllowedServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            3826178105137551123 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.denied(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the ContainsAllowed protocol.
#[derive(Debug)]
pub struct ContainsAllowed;

pub mod contains_allowed {
    pub mod prelude {
        pub use crate::{
            contains_allowed, ContainsAllowed, ContainsAllowedClientHandler,
            ContainsAllowedClientSender, ContainsAllowedServerHandler, ContainsAllowedServerSender,
        };
    }
}

/// A helper trait for the `ContainsAllowed` client sender.
pub trait ContainsAllowedClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ContainsAllowedClientSender for ::fidl_next::ClientSender<___T, ContainsAllowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the ContainsAllowed protocol.
///
/// See [`ContainsAllowed`] for more details.
pub trait ContainsAllowedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ContainsAllowed
where
    ___T: ::fidl_next::Transport,
    ___H: ContainsAllowedClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ContainsAllowed` server sender.
pub trait ContainsAllowedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ContainsAllowedServerSender for ::fidl_next::ServerSender<___T, ContainsAllowed>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the ContainsAllowed protocol.
///
/// See [`ContainsAllowed`] for more details.
pub trait ContainsAllowedServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ContainsAllowed
where
    ___T: ::fidl_next::Transport,
    ___H: ContainsAllowedServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding1 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding1;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding1
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding1> {
    type EncodedOption = ::fidl_next::WireBox<WireShouldNeverAppearInAnyBinding1>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding1>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding1: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding1> for ShouldNeverAppearInAnyBinding1 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding1) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding1`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding1 {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding1 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding1
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct ShouldNeverAppearInAnyBinding2 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding2 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding2 {
    type Encoded = WireShouldNeverAppearInAnyBinding2;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding2
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding2 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding2> for ShouldNeverAppearInAnyBinding2 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding2) -> Self {
        Self { a: from.a().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding2`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding2 {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding2 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding2
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireShouldNeverAppearInAnyBinding2 {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding2").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding3 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding3 {
    type Encoded = WireShouldNeverAppearInAnyBinding3;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding3
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding3 { raw } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding3> {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding3;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding3>
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding3: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding3 { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding3> for ShouldNeverAppearInAnyBinding3 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding3) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding3>
    for Option<Box<ShouldNeverAppearInAnyBinding3>>
{
    #[inline]
    fn take_from(from: &WireOptionalShouldNeverAppearInAnyBinding3) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding3`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding3 {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding3 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod should_never_appear_in_any_binding3 {
    pub enum Ref<'union> {
        A(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding3 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding3::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding3::Ref::A(unsafe {
                self.raw.get().deref_unchecked::<bool>()
            }),

            unknown => crate::should_never_appear_in_any_binding3::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding3 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding3
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding3 {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalShouldNeverAppearInAnyBinding3 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalShouldNeverAppearInAnyBinding3 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding3> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding3 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding3 {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding3
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedShouldNeverAppearInAnyBindingRequest {
    pub should_never_appear_in_any_binding_1: crate::ShouldNeverAppearInAnyBinding1,

    pub should_never_appear_in_any_binding_2: crate::ShouldNeverAppearInAnyBinding2,

    pub should_never_appear_in_any_binding_3: crate::ShouldNeverAppearInAnyBinding3,
}

impl ::fidl_next::Encodable for DeniedShouldNeverAppearInAnyBindingRequest {
    type Encoded = WireDeniedShouldNeverAppearInAnyBindingRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DeniedShouldNeverAppearInAnyBindingRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_1,
                should_never_appear_in_any_binding_2,
                should_never_appear_in_any_binding_3,

            } = out;
        }

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_1,
            encoder,
            should_never_appear_in_any_binding_1,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_2,
            encoder,
            should_never_appear_in_any_binding_2,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_3,
            encoder,
            should_never_appear_in_any_binding_3,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DeniedShouldNeverAppearInAnyBindingRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDeniedShouldNeverAppearInAnyBindingRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<DeniedShouldNeverAppearInAnyBindingRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedShouldNeverAppearInAnyBindingRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDeniedShouldNeverAppearInAnyBindingRequest>
    for DeniedShouldNeverAppearInAnyBindingRequest
{
    #[inline]
    fn take_from(from: &WireDeniedShouldNeverAppearInAnyBindingRequest) -> Self {
        Self {
            should_never_appear_in_any_binding_1: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_1,
            ),

            should_never_appear_in_any_binding_2: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_2,
            ),

            should_never_appear_in_any_binding_3: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_3,
            ),
        }
    }
}

/// The wire type corresponding to [`DeniedShouldNeverAppearInAnyBindingRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedShouldNeverAppearInAnyBindingRequest {
    pub should_never_appear_in_any_binding_1: crate::WireShouldNeverAppearInAnyBinding1,

    pub should_never_appear_in_any_binding_2: crate::WireShouldNeverAppearInAnyBinding2,

    pub should_never_appear_in_any_binding_3: crate::WireShouldNeverAppearInAnyBinding3,
}

unsafe impl ::fidl_next::ZeroPadding for WireDeniedShouldNeverAppearInAnyBindingRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDeniedShouldNeverAppearInAnyBindingRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_1,
                mut should_never_appear_in_any_binding_2,
                mut should_never_appear_in_any_binding_3,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_3.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the Denied protocol.
#[derive(Debug)]
pub struct Denied;

pub mod denied {
    pub mod prelude {
        pub use crate::{
            denied, Denied, DeniedClientHandler, DeniedClientSender, DeniedServerHandler,
            DeniedServerSender,
        };

        pub use crate::DeniedShouldNeverAppearInAnyBindingRequest;
    }

    pub struct ShouldNeverAppearInAnyBinding;

    impl ::fidl_next::Method for ShouldNeverAppearInAnyBinding {
        const ORDINAL: u64 = 5338181991150205725;

        type Protocol = crate::Denied;

        type Request = crate::WireDeniedShouldNeverAppearInAnyBindingRequest;

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `Denied` client sender.
pub trait DeniedClientSender {
    type Transport: ::fidl_next::Transport;

    fn should_never_appear_in_any_binding<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDeniedShouldNeverAppearInAnyBindingRequest,
        >;
}

impl<___T> DeniedClientSender for ::fidl_next::ClientSender<___T, Denied>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn should_never_appear_in_any_binding<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDeniedShouldNeverAppearInAnyBindingRequest,
        >,
    {
        self.as_untyped().send_one_way(5338181991150205725, request)
    }
}

/// A client handler for the Denied protocol.
///
/// See [`Denied`] for more details.
pub trait DeniedClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for Denied
where
    ___T: ::fidl_next::Transport,
    ___H: DeniedClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `Denied` server sender.
pub trait DeniedServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> DeniedServerSender for ::fidl_next::ServerSender<___T, Denied>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the Denied protocol.
///
/// See [`Denied`] for more details.
pub trait DeniedServerHandler<___T: ::fidl_next::Transport> {
    fn should_never_appear_in_any_binding(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, Denied>,

        request: ::fidl_next::RequestBuffer<___T, denied::ShouldNeverAppearInAnyBinding>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for Denied
where
    ___T: ::fidl_next::Transport,
    ___H: DeniedServerHandler<___T>,

    crate::WireDeniedShouldNeverAppearInAnyBindingRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5338181991150205725 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.should_never_appear_in_any_binding(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct ShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding7 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireShouldNeverAppearInAnyBinding7;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding7
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding7> {
    type EncodedOption = ::fidl_next::WireBox<WireShouldNeverAppearInAnyBinding7>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding7>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ShouldNeverAppearInAnyBinding7: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding7> for ShouldNeverAppearInAnyBinding7 {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding7) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding7`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding7 {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding7 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding7
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug, Default)]
pub struct ShouldNeverAppearInAnyBinding8 {
    pub a: Option<bool>,
}

impl ShouldNeverAppearInAnyBinding8 {
    fn __max_ordinal(&self) -> usize {
        if self.a.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding8 {
    type Encoded = WireShouldNeverAppearInAnyBinding8;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding8
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding8 { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(a) = &mut self.a {
                        ::fidl_next::WireEnvelope::encode_value(a, preallocated.encoder, &mut out)?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding8> for ShouldNeverAppearInAnyBinding8 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding8) -> Self {
        Self { a: from.a().map(::fidl_next::TakeFrom::take_from) }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding8`].
#[repr(C)]
pub struct WireShouldNeverAppearInAnyBinding8 {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding8 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding8
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, bool>(slot.as_mut(), decoder)?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireShouldNeverAppearInAnyBinding8 {
    pub fn a(&self) -> Option<&bool> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("ShouldNeverAppearInAnyBinding8").field("a", &self.a()).finish()
    }
}

#[derive(Clone, Debug)]
pub enum ShouldNeverAppearInAnyBinding9 {
    A(bool),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ShouldNeverAppearInAnyBinding9 {
    type Encoded = WireShouldNeverAppearInAnyBinding9;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ShouldNeverAppearInAnyBinding9
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireShouldNeverAppearInAnyBinding9 { raw } = out);

        match self {
            Self::A(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, bool>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ShouldNeverAppearInAnyBinding9> {
    type EncodedOption = WireOptionalShouldNeverAppearInAnyBinding9;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ShouldNeverAppearInAnyBinding9>
where
    ___E: ?Sized,
    ShouldNeverAppearInAnyBinding9: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalShouldNeverAppearInAnyBinding9 { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireShouldNeverAppearInAnyBinding9> for ShouldNeverAppearInAnyBinding9 {
    #[inline]
    fn take_from(from: &WireShouldNeverAppearInAnyBinding9) -> Self {
        match from.raw.ordinal() {
            1 => Self::A(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<bool>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalShouldNeverAppearInAnyBinding9>
    for Option<Box<ShouldNeverAppearInAnyBinding9>>
{
    #[inline]
    fn take_from(from: &WireOptionalShouldNeverAppearInAnyBinding9) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ShouldNeverAppearInAnyBinding9`].
#[repr(transparent)]
pub struct WireShouldNeverAppearInAnyBinding9 {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireShouldNeverAppearInAnyBinding9 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod should_never_appear_in_any_binding9 {
    pub enum Ref<'union> {
        A(&'union bool),

        UnknownOrdinal_(u64),
    }
}

impl WireShouldNeverAppearInAnyBinding9 {
    pub fn as_ref(&self) -> crate::should_never_appear_in_any_binding9::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::should_never_appear_in_any_binding9::Ref::A(unsafe {
                self.raw.get().deref_unchecked::<bool>()
            }),

            unknown => crate::should_never_appear_in_any_binding9::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireShouldNeverAppearInAnyBinding9 {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireShouldNeverAppearInAnyBinding9
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireShouldNeverAppearInAnyBinding9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<bool>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalShouldNeverAppearInAnyBinding9 {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalShouldNeverAppearInAnyBinding9 {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalShouldNeverAppearInAnyBinding9 {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireShouldNeverAppearInAnyBinding9> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalShouldNeverAppearInAnyBinding9 {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalShouldNeverAppearInAnyBinding9 {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<bool>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalShouldNeverAppearInAnyBinding9
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, bool>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalShouldNeverAppearInAnyBinding9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct DeniedAnonymous {
    pub should_never_appear_in_any_binding_7: crate::ShouldNeverAppearInAnyBinding7,

    pub should_never_appear_in_any_binding_8: crate::ShouldNeverAppearInAnyBinding8,

    pub should_never_appear_in_any_binding_9: crate::ShouldNeverAppearInAnyBinding9,
}

impl ::fidl_next::Encodable for DeniedAnonymous {
    type Encoded = WireDeniedAnonymous;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DeniedAnonymous
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                should_never_appear_in_any_binding_7,
                should_never_appear_in_any_binding_8,
                should_never_appear_in_any_binding_9,

            } = out;
        }

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_7,
            encoder,
            should_never_appear_in_any_binding_7,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_8,
            encoder,
            should_never_appear_in_any_binding_8,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.should_never_appear_in_any_binding_9,
            encoder,
            should_never_appear_in_any_binding_9,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DeniedAnonymous> {
    type EncodedOption = ::fidl_next::WireBox<WireDeniedAnonymous>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DeniedAnonymous>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DeniedAnonymous: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDeniedAnonymous> for DeniedAnonymous {
    #[inline]
    fn take_from(from: &WireDeniedAnonymous) -> Self {
        Self {
            should_never_appear_in_any_binding_7: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_7,
            ),

            should_never_appear_in_any_binding_8: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_8,
            ),

            should_never_appear_in_any_binding_9: ::fidl_next::TakeFrom::take_from(
                &from.should_never_appear_in_any_binding_9,
            ),
        }
    }
}

/// The wire type corresponding to [`DeniedAnonymous`].
#[derive(Debug)]
#[repr(C)]
pub struct WireDeniedAnonymous {
    pub should_never_appear_in_any_binding_7: crate::WireShouldNeverAppearInAnyBinding7,

    pub should_never_appear_in_any_binding_8: crate::WireShouldNeverAppearInAnyBinding8,

    pub should_never_appear_in_any_binding_9: crate::WireShouldNeverAppearInAnyBinding9,
}

unsafe impl ::fidl_next::ZeroPadding for WireDeniedAnonymous {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(1).write_bytes(0, 7);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDeniedAnonymous
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut should_never_appear_in_any_binding_7,
                mut should_never_appear_in_any_binding_8,
                mut should_never_appear_in_any_binding_9,

            } = slot;
        }

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(should_never_appear_in_any_binding_9.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyCppRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyCppRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyCppRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyCppRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyCppRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyCppRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyCppRequest>
    for DenyEachBindingOnlyDenyCppRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyCppRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyCppRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyCppRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyCppRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyCppRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyCppResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyCppResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyCppResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyCppResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyCppResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyCppResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyCppResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyCppResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyCppResponse>
    for DenyEachBindingOnlyDenyCppResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyCppResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyCppResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyCppResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyCppResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyCppResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyDartRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyDartRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyDartRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyDartRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyDartRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyDartRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyDartRequest>
    for DenyEachBindingOnlyDenyDartRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyDartRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyDartRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyDartRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyDartRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyDartRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyDartResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyDartResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyDartResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyDartResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyDartResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyDartResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyDartResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyDartResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyDartResponse>
    for DenyEachBindingOnlyDenyDartResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyDartResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyDartResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyDartResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyDartResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyDartResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyGoRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyGoRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyGoRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyGoRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyGoRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyGoRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyGoRequest>
    for DenyEachBindingOnlyDenyGoRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyGoRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyGoRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyGoRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyGoRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyGoRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyGoResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyGoResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyGoResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyGoResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyGoResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyGoResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyGoResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyGoResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyGoResponse>
    for DenyEachBindingOnlyDenyGoResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyGoResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyGoResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyGoResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyGoResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyGoResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyPythonRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyPythonRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyPythonRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyPythonRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyPythonRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyPythonRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyPythonRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyPythonRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyPythonRequest>
    for DenyEachBindingOnlyDenyPythonRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyPythonRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyPythonRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyPythonRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyPythonRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyPythonRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyPythonResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyPythonResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyPythonResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyPythonResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyPythonResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyPythonResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyPythonResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyPythonResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyPythonResponse>
    for DenyEachBindingOnlyDenyPythonResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyPythonResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyPythonResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyPythonResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyPythonResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyPythonResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyRustRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyRustRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyRustRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyRustRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyRustRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyRustRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyRustRequest>
    for DenyEachBindingOnlyDenyRustRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyRustRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyRustRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyRustRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyRustRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyRustRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenyRustResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenyRustResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenyRustResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenyRustResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenyRustResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenyRustResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenyRustResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenyRustResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenyRustResponse>
    for DenyEachBindingOnlyDenyRustResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenyRustResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenyRustResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenyRustResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenyRustResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenyRustResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenySyzkallerRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenySyzkallerRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenySyzkallerRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenySyzkallerRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenySyzkallerRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenySyzkallerRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenySyzkallerRequest>
    for DenyEachBindingOnlyDenySyzkallerRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenySyzkallerRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenySyzkallerRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenySyzkallerRequest {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenySyzkallerRequest {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenySyzkallerRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct DenyEachBindingOnlyDenySyzkallerResponse {
    pub b: i32,
}

impl ::fidl_next::Encodable for DenyEachBindingOnlyDenySyzkallerResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireDenyEachBindingOnlyDenySyzkallerResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for DenyEachBindingOnlyDenySyzkallerResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<DenyEachBindingOnlyDenySyzkallerResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireDenyEachBindingOnlyDenySyzkallerResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<DenyEachBindingOnlyDenySyzkallerResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    DenyEachBindingOnlyDenySyzkallerResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireDenyEachBindingOnlyDenySyzkallerResponse>
    for DenyEachBindingOnlyDenySyzkallerResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireDenyEachBindingOnlyDenySyzkallerResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corresponding to [`DenyEachBindingOnlyDenySyzkallerResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireDenyEachBindingOnlyDenySyzkallerResponse {
    pub b: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::ZeroPadding for WireDenyEachBindingOnlyDenySyzkallerResponse {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireDenyEachBindingOnlyDenySyzkallerResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the DenyEachBinding protocol.
#[derive(Debug)]
pub struct DenyEachBinding;

pub mod deny_each_binding {
    pub mod prelude {
        pub use crate::{
            deny_each_binding, DenyEachBinding, DenyEachBindingClientHandler,
            DenyEachBindingClientSender, DenyEachBindingServerHandler, DenyEachBindingServerSender,
        };

        pub use crate::DenyEachBindingOnlyDenyCppRequest;

        pub use crate::DenyEachBindingOnlyDenyDartRequest;

        pub use crate::DenyEachBindingOnlyDenyGoRequest;

        pub use crate::DenyEachBindingOnlyDenyPythonRequest;

        pub use crate::DenyEachBindingOnlyDenyRustRequest;

        pub use crate::DenyEachBindingOnlyDenySyzkallerRequest;

        pub use crate::DenyEachBindingOnlyDenyCppResponse;

        pub use crate::DenyEachBindingOnlyDenyDartResponse;

        pub use crate::DenyEachBindingOnlyDenyGoResponse;

        pub use crate::DenyEachBindingOnlyDenyPythonResponse;

        pub use crate::DenyEachBindingOnlyDenyRustResponse;

        pub use crate::DenyEachBindingOnlyDenySyzkallerResponse;
    }

    pub struct OnlyDenyCpp;

    impl ::fidl_next::Method for OnlyDenyCpp {
        const ORDINAL: u64 = 2957648440141224850;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyCppRequest;

        type Response = ::fidl_next::WireResult<
            crate::WireDenyEachBindingOnlyDenyCppResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenyDart;

    impl ::fidl_next::Method for OnlyDenyDart {
        const ORDINAL: u64 = 8446571910689294295;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyDartRequest;

        type Response = ::fidl_next::WireResult<
            crate::WireDenyEachBindingOnlyDenyDartResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenyGo;

    impl ::fidl_next::Method for OnlyDenyGo {
        const ORDINAL: u64 = 7311125300308839833;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyGoRequest;

        type Response = ::fidl_next::WireResult<
            crate::WireDenyEachBindingOnlyDenyGoResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenyPython;

    impl ::fidl_next::Method for OnlyDenyPython {
        const ORDINAL: u64 = 3010747198252652930;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyPythonRequest;

        type Response = ::fidl_next::WireResult<
            crate::WireDenyEachBindingOnlyDenyPythonResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenyRust;

    impl ::fidl_next::Method for OnlyDenyRust {
        const ORDINAL: u64 = 3719805222870932662;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenyRustRequest;

        type Response = ::fidl_next::WireResult<
            crate::WireDenyEachBindingOnlyDenyRustResponse,
            ::fidl_next::WireU32,
        >;
    }

    pub struct OnlyDenySyzkaller;

    impl ::fidl_next::Method for OnlyDenySyzkaller {
        const ORDINAL: u64 = 2319043834522757514;

        type Protocol = crate::DenyEachBinding;

        type Request = crate::WireDenyEachBindingOnlyDenySyzkallerRequest;

        type Response = ::fidl_next::WireResult<
            crate::WireDenyEachBindingOnlyDenySyzkallerResponse,
            ::fidl_next::WireU32,
        >;
    }
}

/// A helper trait for the `DenyEachBinding` client sender.
pub trait DenyEachBindingClientSender {
    type Transport: ::fidl_next::Transport;

    fn only_deny_cpp<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyCpp>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyCppRequest,
        >;

    fn only_deny_dart<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyDart>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyDartRequest,
        >;

    fn only_deny_go<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyGo>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyGoRequest,
        >;

    fn only_deny_python<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyPython>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyPythonRequest,
        >;

    fn only_deny_rust<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyRust>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyRustRequest,
        >;

    fn only_deny_syzkaller<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenySyzkaller>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenySyzkallerRequest,
        >;
}

impl<___T> DenyEachBindingClientSender for ::fidl_next::ClientSender<___T, DenyEachBinding>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn only_deny_cpp<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyCpp>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyCppRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2957648440141224850, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_dart<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyDart>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyDartRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8446571910689294295, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_go<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyGo>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyGoRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(7311125300308839833, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_python<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyPython>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyPythonRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(3010747198252652930, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_rust<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenyRust>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenyRustRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(3719805222870932662, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn only_deny_syzkaller<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::ResponseFuture<'_, Self::Transport, deny_each_binding::OnlyDenySyzkaller>,
        ::fidl_next::EncodeError,
    >
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = crate::WireDenyEachBindingOnlyDenySyzkallerRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2319043834522757514, request)
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the DenyEachBinding protocol.
///
/// See [`DenyEachBinding`] for more details.
pub trait DenyEachBindingClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for DenyEachBinding
where
    ___T: ::fidl_next::Transport,
    ___H: DenyEachBindingClientHandler<___T>,

    <deny_each_binding::OnlyDenyCpp as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyDart as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyGo as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyPython as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenyRust as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <deny_each_binding::OnlyDenySyzkaller as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `DenyEachBinding` server sender.
pub trait DenyEachBindingServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> DenyEachBindingServerSender for ::fidl_next::ServerSender<___T, DenyEachBinding>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the DenyEachBinding protocol.
///
/// See [`DenyEachBinding`] for more details.
pub trait DenyEachBindingServerHandler<___T: ::fidl_next::Transport> {
    fn only_deny_cpp(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyCpp>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyCpp>,
    );

    fn only_deny_dart(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyDart>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyDart>,
    );

    fn only_deny_go(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyGo>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyGo>,
    );

    fn only_deny_python(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyPython>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyPython>,
    );

    fn only_deny_rust(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenyRust>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenyRust>,
    );

    fn only_deny_syzkaller(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, DenyEachBinding>,

        request: ::fidl_next::RequestBuffer<___T, deny_each_binding::OnlyDenySyzkaller>,

        responder: ::fidl_next::Responder<deny_each_binding::OnlyDenySyzkaller>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for DenyEachBinding
where
    ___T: ::fidl_next::Transport,
    ___H: DenyEachBindingServerHandler<___T>,

    crate::WireDenyEachBindingOnlyDenyCppRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyDartRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyGoRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyPythonRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenyRustRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    crate::WireDenyEachBindingOnlyDenySyzkallerRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2957648440141224850 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_cpp(sender, buffer, responder);
            }

            8446571910689294295 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_dart(sender, buffer, responder);
            }

            7311125300308839833 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_go(sender, buffer, responder);
            }

            3010747198252652930 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_python(sender, buffer, responder);
            }

            3719805222870932662 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_rust(sender, buffer, responder);
            }

            2319043834522757514 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.only_deny_syzkaller(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the ImportsSameNameContext protocol.
#[derive(Debug)]
pub struct ImportsSameNameContext;

pub mod imports_same_name_context {
    pub mod prelude {
        pub use crate::{
            imports_same_name_context, ImportsSameNameContext, ImportsSameNameContextClientHandler,
            ImportsSameNameContextClientSender, ImportsSameNameContextServerHandler,
            ImportsSameNameContextServerSender,
        };

        pub use ::fidl_next_test_dependent::ContainsDeniedAlwaysDeniedRequest;
    }

    pub struct AlwaysDenied;

    impl ::fidl_next::Method for AlwaysDenied {
        const ORDINAL: u64 = 6808317417318106526;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest;

        type Response = ::fidl_next::Never;
    }

    pub struct Unattributed;

    impl ::fidl_next::Method for Unattributed {
        const ORDINAL: u64 = 475191379775102607;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct AlwaysAppearsInImportingLibrary;

    impl ::fidl_next::Method for AlwaysAppearsInImportingLibrary {
        const ORDINAL: u64 = 2914965219653596920;

        type Protocol = crate::ImportsSameNameContext;

        type Request = ();

        type Response = ::fidl_next::Never;
    }
}

/// A helper trait for the `ImportsSameNameContext` client sender.
pub trait ImportsSameNameContextClientSender {
    type Transport: ::fidl_next::Transport;

    fn always_denied<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest,
        >;

    fn unattributed(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;

    fn always_appears_in_importing_library(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>;
}

impl<___T> ImportsSameNameContextClientSender
    for ::fidl_next::ClientSender<___T, ImportsSameNameContext>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn always_denied<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError>
    where
        ___R: ::fidl_next::Encode<
            <Self::Transport as ::fidl_next::Transport>::SendBuffer,
            Encoded = ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest,
        >,
    {
        self.as_untyped().send_one_way(6808317417318106526, request)
    }

    fn unattributed(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(475191379775102607, &mut ())
    }

    fn always_appears_in_importing_library(
        &self,
    ) -> Result<::fidl_next::SendFuture<'_, Self::Transport>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(2914965219653596920, &mut ())
    }
}

/// A client handler for the ImportsSameNameContext protocol.
///
/// See [`ImportsSameNameContext`] for more details.
pub trait ImportsSameNameContextClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for ImportsSameNameContext
where
    ___T: ::fidl_next::Transport,
    ___H: ImportsSameNameContextClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ImportsSameNameContext` server sender.
pub trait ImportsSameNameContextServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> ImportsSameNameContextServerSender
    for ::fidl_next::ServerSender<___T, ImportsSameNameContext>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the ImportsSameNameContext protocol.
///
/// See [`ImportsSameNameContext`] for more details.
pub trait ImportsSameNameContextServerHandler<___T: ::fidl_next::Transport> {
    fn always_denied(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>,

        request: ::fidl_next::RequestBuffer<___T, imports_same_name_context::AlwaysDenied>,
    );

    fn unattributed(&mut self, sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>);

    fn always_appears_in_importing_library(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, ImportsSameNameContext>,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for ImportsSameNameContext
where
    ___T: ::fidl_next::Transport,
    ___H: ImportsSameNameContextServerHandler<___T>,

    ::fidl_next_test_dependent::WireContainsDeniedAlwaysDeniedRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6808317417318106526 => {
                let buffer = ::fidl_next::RequestBuffer::from_untyped(buffer);
                handler.always_denied(sender, buffer);
            }

            475191379775102607 => {
                handler.unattributed(sender);
            }

            2914965219653596920 => {
                handler.always_appears_in_importing_library(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct MemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

impl ::fidl_next::Encodable for MemberOnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireMemberOnlyAppearsInImportingLibrary;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for MemberOnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MemberOnlyAppearsInImportingLibrary> {
    type EncodedOption = ::fidl_next::WireBox<WireMemberOnlyAppearsInImportingLibrary>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<MemberOnlyAppearsInImportingLibrary>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MemberOnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMemberOnlyAppearsInImportingLibrary>
    for MemberOnlyAppearsInImportingLibrary
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <bool as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    #[inline]
    fn take_from(from: &WireMemberOnlyAppearsInImportingLibrary) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corresponding to [`MemberOnlyAppearsInImportingLibrary`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMemberOnlyAppearsInImportingLibrary {
    pub a: bool,
}

unsafe impl ::fidl_next::ZeroPadding for WireMemberOnlyAppearsInImportingLibrary {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMemberOnlyAppearsInImportingLibrary
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct OnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::MemberOnlyAppearsInImportingLibrary,
}

impl ::fidl_next::Encodable for OnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::MemberOnlyAppearsInImportingLibrary as ::fidl_next::Encodable
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    type Encoded = WireOnlyAppearsInImportingLibrary;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyAppearsInImportingLibrary
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                member_only_appears_in_importing_library,

            } = out;
        }

        ::fidl_next::Encode::encode(
            &mut self.member_only_appears_in_importing_library,
            encoder,
            member_only_appears_in_importing_library,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyAppearsInImportingLibrary> {
    type EncodedOption = ::fidl_next::WireBox<WireOnlyAppearsInImportingLibrary>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyAppearsInImportingLibrary>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyAppearsInImportingLibrary: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyAppearsInImportingLibrary> for OnlyAppearsInImportingLibrary {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true

                && <
                    crate::MemberOnlyAppearsInImportingLibrary as ::fidl_next::Encodable
                >::COPY_OPTIMIZATION.is_enabled()

        )
    };

    #[inline]
    fn take_from(from: &WireOnlyAppearsInImportingLibrary) -> Self {
        Self {
            member_only_appears_in_importing_library: ::fidl_next::TakeFrom::take_from(
                &from.member_only_appears_in_importing_library,
            ),
        }
    }
}

/// The wire type corresponding to [`OnlyAppearsInImportingLibrary`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyAppearsInImportingLibrary {
    pub member_only_appears_in_importing_library: crate::WireMemberOnlyAppearsInImportingLibrary,
}

unsafe impl ::fidl_next::ZeroPadding for WireOnlyAppearsInImportingLibrary {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyAppearsInImportingLibrary
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut member_only_appears_in_importing_library,

            } = slot;
        }

        ::fidl_next::Decode::decode(member_only_appears_in_importing_library.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the OnlyCppAndDeps protocol.
#[derive(Debug)]
pub struct OnlyCppAndDeps;

pub mod only_cpp_and_deps {
    pub mod prelude {
        pub use crate::{
            only_cpp_and_deps, OnlyCppAndDeps, OnlyCppAndDepsClientHandler,
            OnlyCppAndDepsClientSender, OnlyCppAndDepsServerHandler, OnlyCppAndDepsServerSender,
        };
    }
}

/// A helper trait for the `OnlyCppAndDeps` client sender.
pub trait OnlyCppAndDepsClientSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OnlyCppAndDepsClientSender for ::fidl_next::ClientSender<___T, OnlyCppAndDeps>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A client handler for the OnlyCppAndDeps protocol.
///
/// See [`OnlyCppAndDeps`] for more details.
pub trait OnlyCppAndDepsClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for OnlyCppAndDeps
where
    ___T: ::fidl_next::Transport,
    ___H: OnlyCppAndDepsClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `OnlyCppAndDeps` server sender.
pub trait OnlyCppAndDepsServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> OnlyCppAndDepsServerSender for ::fidl_next::ServerSender<___T, OnlyCppAndDeps>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the OnlyCppAndDeps protocol.
///
/// See [`OnlyCppAndDeps`] for more details.
pub trait OnlyCppAndDepsServerHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for OnlyCppAndDeps
where
    ___T: ::fidl_next::Transport,
    ___H: OnlyCppAndDepsServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum OnlyDart {
    A = 1,
}

impl ::fidl_next::Encodable for OnlyDart {
    type Encoded = WireOnlyDart;
}
impl ::std::convert::TryFrom<u32> for OnlyDart {
    type Error = ::fidl_next::UnknownStrictEnumMemberError;
    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::A),

            _ => Err(Self::Error::new(value.into())),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyDart
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyDart { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::A => 1,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireOnlyDart> for OnlyDart {
    fn from(wire: WireOnlyDart) -> Self {
        match u32::from(wire.value) {
            1 => Self::A,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOnlyDart> for OnlyDart {
    #[inline]
    fn take_from(from: &WireOnlyDart) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`OnlyDart`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireOnlyDart {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireOnlyDart {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireOnlyDart {
    pub const A: WireOnlyDart = WireOnlyDart { value: ::fidl_next::WireU32(1) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyDart
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<OnlyDart> for WireOnlyDart {
    fn from(natural: OnlyDart) -> Self {
        match natural {
            OnlyDart::A => WireOnlyDart::A,
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct OnlyGo {}

impl ::fidl_next::Encodable for OnlyGo {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireOnlyGo;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyGo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyGo> {
    type EncodedOption = ::fidl_next::WireBox<WireOnlyGo>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyGo>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    OnlyGo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyGo> for OnlyGo {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn take_from(from: &WireOnlyGo) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`OnlyGo`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireOnlyGo {}

unsafe impl ::fidl_next::ZeroPadding for WireOnlyGo {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyGo
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

/// The type corresponding to the OnlyHlcpp service.
#[derive(Debug)]
pub struct OnlyHlcpp;

/// A helper trait for instances of the `OnlyHlcpp` service.
pub trait OnlyHlcppInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::Transport;
}

impl<___I> OnlyHlcppInstance for ::fidl_next::ServiceInstance<___I, OnlyHlcpp>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;
}

#[derive(Clone, Debug)]
pub enum OnlyLlcpp {
    X(u32),
}

impl ::fidl_next::Encodable for OnlyLlcpp {
    type Encoded = WireOnlyLlcpp;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyLlcpp
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyLlcpp { raw } = out);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<OnlyLlcpp> {
    type EncodedOption = WireOptionalOnlyLlcpp;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<OnlyLlcpp>
where
    ___E: ?Sized,
    OnlyLlcpp: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOnlyLlcpp { raw } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(&mut **inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyLlcpp> for OnlyLlcpp {
    #[inline]
    fn take_from(from: &WireOnlyLlcpp) -> Self {
        match from.raw.ordinal() {
            1 => Self::X(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalOnlyLlcpp> for Option<Box<OnlyLlcpp>> {
    #[inline]
    fn take_from(from: &WireOptionalOnlyLlcpp) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`OnlyLlcpp`].
#[repr(transparent)]
pub struct WireOnlyLlcpp {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOnlyLlcpp {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod only_llcpp {
    pub enum Ref<'union> {
        X(&'union ::fidl_next::WireU32),
    }
}

impl WireOnlyLlcpp {
    pub fn as_ref(&self) -> crate::only_llcpp::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::only_llcpp::Ref::X(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireOnlyLlcpp {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyLlcpp
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOnlyLlcpp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOnlyLlcpp {
    raw: ::fidl_next::RawWireUnion,
}

unsafe impl ::fidl_next::ZeroPadding for WireOptionalOnlyLlcpp {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalOnlyLlcpp {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOnlyLlcpp> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalOnlyLlcpp {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalOnlyLlcpp { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::WireU32>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalOnlyLlcpp
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalOnlyLlcpp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct OnlyPython {}

impl OnlyPython {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for OnlyPython {
    type Encoded = WireOnlyPython;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyPython
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyPython { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyPython> for OnlyPython {
    #[inline]
    fn take_from(from: &WireOnlyPython) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`OnlyPython`].
#[repr(C)]
pub struct WireOnlyPython {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireOnlyPython {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyPython
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireOnlyPython {}

impl ::core::fmt::Debug for WireOnlyPython {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OnlyPython").finish()
    }
}

#[derive(Clone, Debug, Default)]
pub struct OnlyRust {}

impl OnlyRust {
    fn __max_ordinal(&self) -> usize {
        0
    }
}

impl ::fidl_next::Encodable for OnlyRust {
    type Encoded = WireOnlyRust;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlyRust
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlyRust { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::ZeroPadding::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireOnlyRust> for OnlyRust {
    #[inline]
    fn take_from(from: &WireOnlyRust) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`OnlyRust`].
#[repr(C)]
pub struct WireOnlyRust {
    table: ::fidl_next::WireTable,
}

unsafe impl ::fidl_next::ZeroPadding for WireOnlyRust {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlyRust
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl WireOnlyRust {}

impl ::core::fmt::Debug for WireOnlyRust {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("OnlyRust").finish()
    }
}

::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct OnlySyzkaller: u32 {
        const A = 1;

    }
}

impl ::fidl_next::Encodable for OnlySyzkaller {
    type Encoded = WireOnlySyzkaller;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OnlySyzkaller
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOnlySyzkaller { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(self.bits()));
        Ok(())
    }
}

impl ::core::convert::From<WireOnlySyzkaller> for OnlySyzkaller {
    fn from(wire: WireOnlySyzkaller) -> Self {
        Self::from_bits_retain(u32::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<WireOnlySyzkaller> for OnlySyzkaller {
    #[inline]
    fn take_from(from: &WireOnlySyzkaller) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`OnlySyzkaller`].
#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct WireOnlySyzkaller {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireOnlySyzkaller {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire bits have no padding
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOnlySyzkaller
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);
        let set = u32::from(*value);
        if set & !OnlySyzkaller::all().bits() != 0 {
            return Err(::fidl_next::DecodeError::InvalidBits {
                expected: OnlySyzkaller::all().bits() as usize,
                actual: set as usize,
            });
        }

        Ok(())
    }
}

impl ::core::convert::From<OnlySyzkaller> for WireOnlySyzkaller {
    fn from(natural: OnlySyzkaller) -> Self {
        Self { value: ::fidl_next::WireU32::from(natural.bits()) }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `Allowed`
    /// protocol.
    pub type AllowedProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::Allowed>;

    impl ::fidl_next::TakeFrom<crate::Allowed> for ::fidl_test_bindingsdenylist::AllowedMarker {
        #[inline]
        fn take_from(from: &crate::Allowed) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenyCppRequest>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenyCppRequest
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenyCppRequest) -> Self {
            Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenyCppResponse>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenyCppResponse
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenyCppResponse) -> Self {
            Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenyDartRequest>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenyDartRequest) -> Self {
            Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenyDartResponse>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenyDartResponse) -> Self {
            Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenyGoRequest>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenyGoRequest) -> Self {
            Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenyGoResponse>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenyGoResponse) -> Self {
            Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenyPythonRequest>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenyPythonRequest
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenyPythonRequest) -> Self {
            Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenyPythonResponse>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenyPythonResponse) -> Self {
            Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenySyzkallerRequest>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenySyzkallerRequest) -> Self {
            Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireDenyEachBindingOnlyDenySyzkallerResponse>
        for ::fidl_test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse
    {
        #[inline]
        fn take_from(from: &crate::WireDenyEachBindingOnlyDenySyzkallerResponse) -> Self {
            Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `DenyEachBinding`
    /// protocol.
    pub type DenyEachBindingProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::DenyEachBinding>;

    impl ::fidl_next::TakeFrom<crate::DenyEachBinding>
        for ::fidl_test_bindingsdenylist::DenyEachBindingMarker
    {
        #[inline]
        fn take_from(from: &crate::DenyEachBinding) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `ImportsSameNameContext`
    /// protocol.
    pub type ImportsSameNameContextProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::ImportsSameNameContext>;

    impl ::fidl_next::TakeFrom<crate::ImportsSameNameContext>
        for ::fidl_test_bindingsdenylist::ImportsSameNameContextMarker
    {
        #[inline]
        fn take_from(from: &crate::ImportsSameNameContext) -> Self {
            Self
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireMemberOnlyAppearsInImportingLibrary>
        for ::fidl_test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary
    {
        #[inline]
        fn take_from(from: &crate::WireMemberOnlyAppearsInImportingLibrary) -> Self {
            Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOnlyAppearsInImportingLibrary>
        for ::fidl_test_bindingsdenylist::OnlyAppearsInImportingLibrary
    {
        #[inline]
        fn take_from(from: &crate::WireOnlyAppearsInImportingLibrary) -> Self {
            Self {
                member_only_appears_in_importing_library: ::fidl_next::TakeFrom::take_from(
                    &from.member_only_appears_in_importing_library,
                ),
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireOnlyRust> for ::fidl_test_bindingsdenylist::OnlyRust {
        #[inline]
        fn take_from(from: &crate::WireOnlyRust) -> Self {
            Self { __source_breaking: ::fidl::marker::SourceBreaking }
        }
    }
}
