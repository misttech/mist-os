// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
{
    type Decoded<'de> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    type EncodedOption = WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    type Decoded<'de> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de>,
    > for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl
    ::fidl_next::FromWireRef<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    type EncodedOption =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> =
        WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de>,
    > for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<
        WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de>,
    > for UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsAjarDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsAjarDriverProtocol;

pub mod unknown_interactions_ajar_driver_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_ajar_driver_protocol, UnknownInteractionsAjarDriverProtocol,
            UnknownInteractionsAjarDriverProtocolClientHandler,
            UnknownInteractionsAjarDriverProtocolServerHandler,
        };

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 200845620698173917;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 3790953144423004126;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 523076268125513549;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 902155904889801604;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 8952307689721713673;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 3114064683372134045;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse<'static>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 7057260423103547829;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 6490530264582540031;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 2319476129312263555;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 6883106306697493305;

        type Protocol = crate::UnknownInteractionsAjarDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse<'static>,
            ::fidl_next::WireI32,
        >;
    }

    mod ___detail {
        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::UnknownInteractionsAjarDriverProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = UnknownInteractionsAjarDriverProtocolClientSender<___T>;
            type ServerSender = UnknownInteractionsAjarDriverProtocolServerSender<___T>;
        }

        /// The client sender for the `UnknownInteractionsAjarDriverProtocol` protocol.
        pub struct UnknownInteractionsAjarDriverProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> UnknownInteractionsAjarDriverProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(200845620698173917, ())
            }

            pub fn flexible_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(3790953144423004126, ())
            }

            pub fn strict_two_way(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWay, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(523076268125513549, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFields, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(902155904889801604, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnion, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(8952307689721713673, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTable, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(3114064683372134045, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(7057260423103547829, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFieldsErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6490530264582540031, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnionErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(2319476129312263555, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTableErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6883106306697493305, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `UnknownInteractionsAjarDriverProtocol` protocol.
        #[repr(transparent)]
        pub struct UnknownInteractionsAjarDriverProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> UnknownInteractionsAjarDriverProtocolServerSender<___T> where ___T: ::fidl_next::Transport
        {}
    }
}

/// A client handler for the UnknownInteractionsAjarDriverProtocol protocol.
///
/// See [`UnknownInteractionsAjarDriverProtocol`] for more details.
pub trait UnknownInteractionsAjarDriverProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarDriverProtocol, ___T>,
        ordinal: u64,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send {
        sender.close();
        ::core::future::ready(())
    }
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for UnknownInteractionsAjarDriverProtocol
where
    ___H: UnknownInteractionsAjarDriverProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,









            <unknown_interactions_ajar_driver_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,


{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
































                ordinal => handler.on_unknown_interaction(sender, ordinal).await,

        }
    }
}

/// A server handler for the UnknownInteractionsAjarDriverProtocol protocol.
///
/// See [`UnknownInteractionsAjarDriverProtocol`] for more details.
pub trait UnknownInteractionsAjarDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_driver_protocol::StrictTwoWay>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFields,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnion,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTable,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayFieldsErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayUnionErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_driver_protocol::StrictTwoWayTableErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarDriverProtocol, ___T>,
        ordinal: u64,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send {
        sender.close();
        ::core::future::ready(())
    }
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for UnknownInteractionsAjarDriverProtocol
where
    ___H: UnknownInteractionsAjarDriverProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            200845620698173917 => {
                handler.strict_one_way(sender).await;
            }

            3790953144423004126 => {
                handler.flexible_one_way(sender).await;
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            523076268125513549 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder).await;
            }

            902155904889801604 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder).await;
            }

            8952307689721713673 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder).await;
            }

            3114064683372134045 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder).await;
            }

            7057260423103547829 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder).await;
            }

            6490530264582540031 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder).await;
            }

            2319476129312263555 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder).await;
            }

            6883106306697493305 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder).await;
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsAjarProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_protocol_strict_two_way_union_err_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de>>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de>>
    for UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolStrictEventFieldsRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest>
    for UnknownInteractionsAjarProtocolStrictEventFieldsRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest {
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsAjarProtocolStrictEventUnionRequest {
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolStrictEventUnionRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolStrictEventUnionRequest) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for UnknownInteractionsAjarProtocolStrictEventUnionRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsAjarProtocolStrictEventUnionRequest) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest>
    for Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest,
    > for Box<UnknownInteractionsAjarProtocolStrictEventUnionRequest>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_protocol_strict_event_union_request {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest
{
    type Decoded<'de> = WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnknownInteractionsAjarProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolStrictEventUnionRequest {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de>>
    for UnknownInteractionsAjarProtocolStrictEventTableRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de>>
    for UnknownInteractionsAjarProtocolStrictEventTableRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'static>
{
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    type EncodedOption = WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsAjarProtocolFlexibleEventUnionRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsAjarProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
    > for Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
    > for Box<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_ajar_protocol_flexible_event_union_request {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_ajar_protocol_flexible_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
{
    type Decoded<'de> = WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
    type Encoded = WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de>>
    for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de>>
    for UnknownInteractionsAjarProtocolFlexibleEventTableRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsAjarProtocolFlexibleEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'static>
{
    type Decoded<'de> = WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsAjarProtocolFlexibleEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsAjarProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsAjarProtocol;

pub mod unknown_interactions_ajar_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_ajar_protocol, UnknownInteractionsAjarProtocol,
            UnknownInteractionsAjarProtocolClientHandler,
            UnknownInteractionsAjarProtocolServerHandler,
        };

        pub use crate::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;

        pub use crate::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;

        pub use crate::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest;

        pub use crate::UnknownInteractionsAjarProtocolStrictEventFieldsRequest;

        pub use crate::UnknownInteractionsAjarProtocolStrictEventTableRequest;

        pub use crate::UnknownInteractionsAjarProtocolStrictEventUnionRequest;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 956561744635167883;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 2483093178939638607;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 364341676962177080;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 1821674633227946298;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 5870221221557233361;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 8038805778859962068;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableResponse<'static>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 6577335136969723910;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 595881957484758745;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 3224530777258896533;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 3515589146717969463;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse<'static>,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 6927291151663612592;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 5838220329633564521;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 6303151946645602671;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 659277224687564957;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolStrictEventTableRequest<'static>;
    }

    pub struct FlexibleEvent;

    impl ::fidl_next::Method for FlexibleEvent {
        const ORDINAL: u64 = 1281760452005010931;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct FlexibleEventFields;

    impl ::fidl_next::Method for FlexibleEventFields {
        const ORDINAL: u64 = 4298964238728681570;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
    }

    pub struct FlexibleEventUnion;

    impl ::fidl_next::Method for FlexibleEventUnion {
        const ORDINAL: u64 = 8950943792372972717;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
    }

    pub struct FlexibleEventTable;

    impl ::fidl_next::Method for FlexibleEventTable {
        const ORDINAL: u64 = 705539350563403440;

        type Protocol = crate::UnknownInteractionsAjarProtocol;

        type Request = ::fidl_next::Never;

        type Response =
            crate::WireUnknownInteractionsAjarProtocolFlexibleEventTableRequest<'static>;
    }

    mod ___detail {
        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::UnknownInteractionsAjarProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = UnknownInteractionsAjarProtocolClientSender<___T>;
            type ServerSender = UnknownInteractionsAjarProtocolServerSender<___T>;
        }

        /// The client sender for the `UnknownInteractionsAjarProtocol` protocol.
        pub struct UnknownInteractionsAjarProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> UnknownInteractionsAjarProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(956561744635167883, ())
            }

            pub fn flexible_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(2483093178939638607, ())
            }

            pub fn strict_two_way(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWay, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(364341676962177080, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFields, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1821674633227946298, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnion, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(5870221221557233361, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTable, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(8038805778859962068, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6577335136969723910, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFieldsErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(595881957484758745, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnionErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(3224530777258896533, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTableErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(3515589146717969463, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `UnknownInteractionsAjarProtocol` protocol.
        #[repr(transparent)]
        pub struct UnknownInteractionsAjarProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> UnknownInteractionsAjarProtocolServerSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_event(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_event(6927291151663612592, ())
            }

            pub fn strict_event_fields<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventFields as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(5838220329633564521, request)
            }

            pub fn strict_event_union<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventUnion as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(6303151946645602671, request)
            }

            pub fn strict_event_table<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventTable as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(659277224687564957, request)
            }

            pub fn flexible_event(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_event(1281760452005010931, ())
            }

            pub fn flexible_event_fields<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::FlexibleEventFields as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(4298964238728681570, request)
            }

            pub fn flexible_event_union<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::FlexibleEventUnion as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(8950943792372972717, request)
            }

            pub fn flexible_event_table<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::FlexibleEventTable as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(705539350563403440, request)
            }
        }
    }
}

/// A client handler for the UnknownInteractionsAjarProtocol protocol.
///
/// See [`UnknownInteractionsAjarProtocol`] for more details.
pub trait UnknownInteractionsAjarProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_ajar_protocol::StrictEventFields, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_ajar_protocol::StrictEventUnion, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_ajar_protocol::StrictEventTable, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_event(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_ajar_protocol::FlexibleEventFields, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_ajar_protocol::FlexibleEventUnion, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_ajar_protocol::FlexibleEventTable, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsAjarProtocol, ___T>,
        ordinal: u64,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send {
        sender.close();
        ::core::future::ready(())
    }
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for UnknownInteractionsAjarProtocol
where
    ___H: UnknownInteractionsAjarProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <unknown_interactions_ajar_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::StrictEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::FlexibleEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::FlexibleEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_ajar_protocol::FlexibleEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6927291151663612592 => {
                handler.strict_event(sender).await;
            }

            5838220329633564521 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_fields(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            6303151946645602671 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_union(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            659277224687564957 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_table(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            1281760452005010931 => {
                handler.flexible_event(sender).await;
            }

            4298964238728681570 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.flexible_event_fields(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            8950943792372972717 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.flexible_event_union(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            705539350563403440 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.flexible_event_table(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }
}

/// A server handler for the UnknownInteractionsAjarProtocol protocol.
///
/// See [`UnknownInteractionsAjarProtocol`] for more details.
pub trait UnknownInteractionsAjarProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWay>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayFields>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayUnion>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayTable>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_ajar_protocol::StrictTwoWayFieldsErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayUnionErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_ajar_protocol::StrictTwoWayTableErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsAjarProtocol, ___T>,
        ordinal: u64,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send {
        sender.close();
        ::core::future::ready(())
    }
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for UnknownInteractionsAjarProtocol
where
    ___H: UnknownInteractionsAjarProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            956561744635167883 => {
                handler.strict_one_way(sender).await;
            }

            2483093178939638607 => {
                handler.flexible_one_way(sender).await;
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            364341676962177080 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder).await;
            }

            1821674633227946298 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder).await;
            }

            5870221221557233361 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder).await;
            }

            8038805778859962068 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder).await;
            }

            6577335136969723910 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder).await;
            }

            595881957484758745 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder).await;
            }

            3224530777258896533 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder).await;
            }

            3515589146717969463 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder).await;
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
{
    type Decoded<'de> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    type Decoded<'de> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    type Decoded<'de> =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de>,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse:
        ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl
    ::fidl_next::FromWireRef<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    type EncodedOption =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse:
        ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireRef<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> =
        WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
                    raw: ::fidl_next::RawWireUnion::absent(),
                    _phantom: ::core::marker::PhantomData,
                };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    type Encoded = WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de>,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de>,
    > for UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'static>
{
    type Decoded<'de> =
        WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsClosedDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsClosedDriverProtocol;

pub mod unknown_interactions_closed_driver_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_closed_driver_protocol, UnknownInteractionsClosedDriverProtocol,
            UnknownInteractionsClosedDriverProtocolClientHandler,
            UnknownInteractionsClosedDriverProtocolServerHandler,
        };

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 9111839835597799810;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 2815690661228737027;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 5761316743698652038;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 7235351480214368636;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 1839495150551777151;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse<'static>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 4350840352076287137;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 3933117456632607830;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 4598950031783776653;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 1456858375973362525;

        type Protocol = crate::UnknownInteractionsClosedDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse<'static>,
            ::fidl_next::WireI32,
        >;
    }

    mod ___detail {
        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::UnknownInteractionsClosedDriverProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = UnknownInteractionsClosedDriverProtocolClientSender<___T>;
            type ServerSender = UnknownInteractionsClosedDriverProtocolServerSender<___T>;
        }

        /// The client sender for the `UnknownInteractionsClosedDriverProtocol` protocol.
        pub struct UnknownInteractionsClosedDriverProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> UnknownInteractionsClosedDriverProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(9111839835597799810, ())
            }

            pub fn strict_two_way(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWay, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(2815690661228737027, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFields, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(5761316743698652038, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnion, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(7235351480214368636, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTable, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1839495150551777151, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(4350840352076287137, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFieldsErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(3933117456632607830, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnionErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(4598950031783776653, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTableErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1456858375973362525, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `UnknownInteractionsClosedDriverProtocol` protocol.
        #[repr(transparent)]
        pub struct UnknownInteractionsClosedDriverProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> UnknownInteractionsClosedDriverProtocolServerSender<___T> where
            ___T: ::fidl_next::Transport
        {
        }
    }
}

/// A client handler for the UnknownInteractionsClosedDriverProtocol protocol.
///
/// See [`UnknownInteractionsClosedDriverProtocol`] for more details.
pub trait UnknownInteractionsClosedDriverProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for UnknownInteractionsClosedDriverProtocol
where
    ___H: UnknownInteractionsClosedDriverProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,







            <unknown_interactions_closed_driver_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,


{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {





























                ordinal => {

                    sender.close();
                }

        }
    }
}

/// A server handler for the UnknownInteractionsClosedDriverProtocol protocol.
///
/// See [`UnknownInteractionsClosedDriverProtocol`] for more details.
pub trait UnknownInteractionsClosedDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWay,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayFields,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnion,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayTable,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayFieldsErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayUnionErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_driver_protocol::StrictTwoWayTableErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for UnknownInteractionsClosedDriverProtocol
where
    ___H: UnknownInteractionsClosedDriverProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            9111839835597799810 => {
                handler.strict_one_way(sender).await;
            }

            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            2815690661228737027 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder).await;
            }

            5761316743698652038 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder).await;
            }

            7235351480214368636 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder).await;
            }

            1839495150551777151 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder).await;
            }

            4350840352076287137 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder).await;
            }

            3933117456632607830 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder).await;
            }

            4598950031783776653 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder).await;
            }

            1456858375973362525 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder).await;
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsClosedProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_protocol_strict_two_way_union_err_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de>>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de>>
    for UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsClosedProtocolStrictEventFieldsRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest>
    for UnknownInteractionsClosedProtocolStrictEventFieldsRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest {
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsClosedProtocolStrictEventUnionRequest {
    type EncodedOption = WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsClosedProtocolStrictEventUnionRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictEventUnionRequest>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsClosedProtocolStrictEventUnionRequest) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictEventUnionRequest>
    for UnknownInteractionsClosedProtocolStrictEventUnionRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsClosedProtocolStrictEventUnionRequest) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest,
    > for Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest,
    > for Box<UnknownInteractionsClosedProtocolStrictEventUnionRequest>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_closed_protocol_strict_event_union_request {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_closed_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest
{
    type Decoded<'de> = WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsClosedProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsClosedProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsClosedProtocolStrictEventUnionRequest {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsClosedProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsClosedProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsClosedProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsClosedProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsClosedProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsClosedProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsClosedProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de>>
    for UnknownInteractionsClosedProtocolStrictEventTableRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de>>
    for UnknownInteractionsClosedProtocolStrictEventTableRequest
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsClosedProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'static>
{
    type Decoded<'de> = WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsClosedProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsClosedProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsClosedProtocol;

pub mod unknown_interactions_closed_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_closed_protocol, UnknownInteractionsClosedProtocol,
            UnknownInteractionsClosedProtocolClientHandler,
            UnknownInteractionsClosedProtocolServerHandler,
        };

        pub use crate::UnknownInteractionsClosedProtocolStrictEventFieldsRequest;

        pub use crate::UnknownInteractionsClosedProtocolStrictEventTableRequest;

        pub use crate::UnknownInteractionsClosedProtocolStrictEventUnionRequest;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 401526495318825508;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 6834828562275693047;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 1379139029283639891;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 7544414847426850727;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 7947328131967870853;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableResponse<'static>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 5738532966428790074;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 802395819586836733;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 925029359463709824;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 1260407702860823440;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse<'static>,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 760799297757210939;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 6736355582617074292;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 4288682345454280036;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsClosedProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 2871682464255309246;

        type Protocol = crate::UnknownInteractionsClosedProtocol;

        type Request = ::fidl_next::Never;

        type Response =
            crate::WireUnknownInteractionsClosedProtocolStrictEventTableRequest<'static>;
    }

    mod ___detail {
        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::UnknownInteractionsClosedProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = UnknownInteractionsClosedProtocolClientSender<___T>;
            type ServerSender = UnknownInteractionsClosedProtocolServerSender<___T>;
        }

        /// The client sender for the `UnknownInteractionsClosedProtocol` protocol.
        pub struct UnknownInteractionsClosedProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> UnknownInteractionsClosedProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(401526495318825508, ())
            }

            pub fn strict_two_way(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWay, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6834828562275693047, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFields, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1379139029283639891, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnion, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(7544414847426850727, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTable, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(7947328131967870853, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(5738532966428790074, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFieldsErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(802395819586836733, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnionErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(925029359463709824, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTableErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1260407702860823440, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `UnknownInteractionsClosedProtocol` protocol.
        #[repr(transparent)]
        pub struct UnknownInteractionsClosedProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> UnknownInteractionsClosedProtocolServerSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_event(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_event(760799297757210939, ())
            }

            pub fn strict_event_fields<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventFields as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(6736355582617074292, request)
            }

            pub fn strict_event_union<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventUnion as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(4288682345454280036, request)
            }

            pub fn strict_event_table<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventTable as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(2871682464255309246, request)
            }
        }
    }
}

/// A client handler for the UnknownInteractionsClosedProtocol protocol.
///
/// See [`UnknownInteractionsClosedProtocol`] for more details.
pub trait UnknownInteractionsClosedProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsClosedProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsClosedProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_closed_protocol::StrictEventFields, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsClosedProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_closed_protocol::StrictEventUnion, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsClosedProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_closed_protocol::StrictEventTable, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for UnknownInteractionsClosedProtocol
where
    ___H: UnknownInteractionsClosedProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <unknown_interactions_closed_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_closed_protocol::StrictEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            760799297757210939 => {
                handler.strict_event(sender).await;
            }

            6736355582617074292 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_fields(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            4288682345454280036 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_union(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            2871682464255309246 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_table(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A server handler for the UnknownInteractionsClosedProtocol protocol.
///
/// See [`UnknownInteractionsClosedProtocol`] for more details.
pub trait UnknownInteractionsClosedProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWay>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayFields>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayUnion>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayTable>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_closed_protocol::StrictTwoWayErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayFieldsErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayUnionErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsClosedProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_closed_protocol::StrictTwoWayTableErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for UnknownInteractionsClosedProtocol
where
    ___H: UnknownInteractionsClosedProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            401526495318825508 => {
                handler.strict_one_way(sender).await;
            }

            ordinal => {
                sender.close();
            }
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            6834828562275693047 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder).await;
            }

            1379139029283639891 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder).await;
            }

            7544414847426850727 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder).await;
            }

            7947328131967870853 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder).await;
            }

            5738532966428790074 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder).await;
            }

            802395819586836733 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder).await;
            }

            925029359463709824 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder).await;
            }

            1260407702860823440 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder).await;
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    > for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsDriverProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_driver_protocol_strict_two_way_union_err_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de>>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de>>
    for UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsDriverProtocolFlexibleTwoWayResponse = ();

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayResponse`].
pub type WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    type EncodedOption = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    > for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    > for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse`].
pub type WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    type EncodedOption =
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_driver_protocol_flexible_two_way_union_err_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref<'_>
    {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_driver_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(
        &self,
    ) -> Option<&WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug
    for WireOptionalUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de>>
    for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn from_wire(
        wire: WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de>,
    ) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<
        WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de>,
    > for UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsDriverProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsDriverProtocol;

pub mod unknown_interactions_driver_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_driver_protocol, UnknownInteractionsDriverProtocol,
            UnknownInteractionsDriverProtocolClientHandler,
            UnknownInteractionsDriverProtocolServerHandler,
        };

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;

        pub use crate::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 6982839851953080288;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 1083620022582160398;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 1481114722667499972;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 6841797014773573215;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 1451514501977162287;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 3330693085881435529;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response =
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableResponse<'static>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 8222960355260037542;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 225387363174180470;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 3066880266580913088;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 708169949929096689;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse<'static>,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWay;

    impl ::fidl_next::Method for FlexibleTwoWay {
        const ORDINAL: u64 = 2929398860738426482;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            'static,
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayResponse,
        >;
    }

    pub struct FlexibleTwoWayFields;

    impl ::fidl_next::Method for FlexibleTwoWayFields {
        const ORDINAL: u64 = 8423663794424433896;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            'static,
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse,
        >;
    }

    pub struct FlexibleTwoWayUnion;

    impl ::fidl_next::Method for FlexibleTwoWayUnion {
        const ORDINAL: u64 = 8216450897182897849;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            'static,
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse,
        >;
    }

    pub struct FlexibleTwoWayTable;

    impl ::fidl_next::Method for FlexibleTwoWayTable {
        const ORDINAL: u64 = 1049265954148894210;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            'static,
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse<'static>,
        >;
    }

    pub struct FlexibleTwoWayErr;

    impl ::fidl_next::Method for FlexibleTwoWayErr {
        const ORDINAL: u64 = 5583489590753947170;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            'static,
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayFieldsErr;

    impl ::fidl_next::Method for FlexibleTwoWayFieldsErr {
        const ORDINAL: u64 = 6033174601748665003;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            'static,
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayUnionErr;

    impl ::fidl_next::Method for FlexibleTwoWayUnionErr {
        const ORDINAL: u64 = 6235121653537390575;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            'static,
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayTableErr;

    impl ::fidl_next::Method for FlexibleTwoWayTableErr {
        const ORDINAL: u64 = 940887795361350656;

        type Protocol = crate::UnknownInteractionsDriverProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            'static,
            crate::WireUnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse<'static>,
            ::fidl_next::WireI32,
        >;
    }

    mod ___detail {
        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::UnknownInteractionsDriverProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = UnknownInteractionsDriverProtocolClientSender<___T>;
            type ServerSender = UnknownInteractionsDriverProtocolServerSender<___T>;
        }

        /// The client sender for the `UnknownInteractionsDriverProtocol` protocol.
        pub struct UnknownInteractionsDriverProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> UnknownInteractionsDriverProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(6982839851953080288, ())
            }

            pub fn flexible_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(1083620022582160398, ())
            }

            pub fn strict_two_way(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWay, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1481114722667499972, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFields, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6841797014773573215, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnion, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1451514501977162287, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTable, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(3330693085881435529, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(8222960355260037542, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFieldsErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(225387363174180470, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnionErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(3066880266580913088, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTableErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(708169949929096689, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWay, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(2929398860738426482, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_fields(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayFields, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(8423663794424433896, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_union(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayUnion, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(8216450897182897849, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_table(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayTable, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1049265954148894210, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(5583489590753947170, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_fields_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayFieldsErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6033174601748665003, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_union_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayUnionErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6235121653537390575, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_table_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayTableErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(940887795361350656, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `UnknownInteractionsDriverProtocol` protocol.
        #[repr(transparent)]
        pub struct UnknownInteractionsDriverProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> UnknownInteractionsDriverProtocolServerSender<___T> where ___T: ::fidl_next::Transport {}
    }
}

/// A client handler for the UnknownInteractionsDriverProtocol protocol.
///
/// See [`UnknownInteractionsDriverProtocol`] for more details.
pub trait UnknownInteractionsDriverProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsDriverProtocol, ___T>,
        ordinal: u64,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send {
        sender.close();
        ::core::future::ready(())
    }
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for UnknownInteractionsDriverProtocol
where
    ___H: UnknownInteractionsDriverProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,









            <unknown_interactions_driver_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWay as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayFields as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayUnion as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayTable as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,




            <unknown_interactions_driver_protocol::FlexibleTwoWayTableErr as ::fidl_next::Method>::Response:
                ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,


{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
























































                ordinal => handler.on_unknown_interaction(sender, ordinal).await,

        }
    }
}

/// A server handler for the UnknownInteractionsDriverProtocol protocol.
///
/// See [`UnknownInteractionsDriverProtocol`] for more details.
pub trait UnknownInteractionsDriverProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWay>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayFields>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayUnion>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayTable>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::StrictTwoWayErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayFieldsErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayUnionErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::StrictTwoWayTableErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::FlexibleTwoWay>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayFields,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayUnion,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayTable,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_driver_protocol::FlexibleTwoWayErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayFieldsErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayUnionErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,

        responder: ::fidl_next::Responder<
            unknown_interactions_driver_protocol::FlexibleTwoWayTableErr,
        >,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsDriverProtocol, ___T>,
        ordinal: u64,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send {
        sender.close();
        ::core::future::ready(())
    }
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for UnknownInteractionsDriverProtocol
where
    ___H: UnknownInteractionsDriverProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6982839851953080288 => {
                handler.strict_one_way(sender).await;
            }

            1083620022582160398 => {
                handler.flexible_one_way(sender).await;
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1481114722667499972 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder).await;
            }

            6841797014773573215 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder).await;
            }

            1451514501977162287 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder).await;
            }

            3330693085881435529 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder).await;
            }

            8222960355260037542 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder).await;
            }

            225387363174180470 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder).await;
            }

            3066880266580913088 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder).await;
            }

            708169949929096689 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder).await;
            }

            2929398860738426482 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way(sender, responder).await;
            }

            8423663794424433896 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields(sender, responder).await;
            }

            8216450897182897849 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union(sender, responder).await;
            }

            1049265954148894210 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table(sender, responder).await;
            }

            5583489590753947170 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_err(sender, responder).await;
            }

            6033174601748665003 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields_err(sender, responder).await;
            }

            6235121653537390575 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union_err(sender, responder).await;
            }

            940887795361350656 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table_err(sender, responder).await;
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse {
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolStrictTwoWayUnionResponse {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictTwoWayUnionResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolStrictTwoWayUnionResponse) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_strict_two_way_union_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    type Decoded<'de> = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnknownInteractionsProtocolStrictTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictTwoWayUnionResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de>>
    for UnknownInteractionsProtocolStrictTwoWayTableResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de>) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsProtocolStrictTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayErrResponse`].
pub type WireUnknownInteractionsProtocolStrictTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictTwoWayUnionErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
    for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_strict_two_way_union_err_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de>>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de>>
    for UnknownInteractionsProtocolStrictTwoWayTableErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsProtocolFlexibleTwoWayResponse = ();

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayResponse`].
pub type WireUnknownInteractionsProtocolFlexibleTwoWayResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
    for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
    > for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_flexible_two_way_union_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de>>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de>>
    for UnknownInteractionsProtocolFlexibleTwoWayTableResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleTwoWayTableResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

pub type UnknownInteractionsProtocolFlexibleTwoWayErrResponse = ();

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayErrResponse`].
pub type WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse = ();

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
    ) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
    for UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl
    ::fidl_next::FromWireOption<
        WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<
        WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
    > for Box<UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_flexible_two_way_union_err_response {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_two_way_union_err_response::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
{
    type Decoded<'de> = WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(
        self,
    ) -> Option<WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
    type Encoded = WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de>>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de>>
    for UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de>,
    ) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'static>
{
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug
    for WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'de>
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsProtocolStrictEventFieldsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolStrictEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolStrictEventFieldsRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireUnknownInteractionsProtocolStrictEventFieldsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolStrictEventFieldsRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictEventFieldsRequest>
    for UnknownInteractionsProtocolStrictEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsProtocolStrictEventFieldsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictEventFieldsRequest>
    for UnknownInteractionsProtocolStrictEventFieldsRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolStrictEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolStrictEventFieldsRequest {
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictEventFieldsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolStrictEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventUnionRequest {
    type Encoded = WireUnknownInteractionsProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolStrictEventUnionRequest {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolStrictEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolStrictEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsProtocolStrictEventUnionRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictEventUnionRequest>
    for UnknownInteractionsProtocolStrictEventUnionRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictEventUnionRequest) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictEventUnionRequest>
    for UnknownInteractionsProtocolStrictEventUnionRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolStrictEventUnionRequest) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest>
    for Box<UnknownInteractionsProtocolStrictEventUnionRequest>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest>
    for Box<UnknownInteractionsProtocolStrictEventUnionRequest>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_strict_event_union_request {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolStrictEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_strict_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_strict_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_strict_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    type Decoded<'de> = WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnknownInteractionsProtocolStrictEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolStrictEventUnionRequest {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolStrictEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolStrictEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolStrictEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolStrictEventTableRequest {
    type Encoded = WireUnknownInteractionsProtocolStrictEventTableRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolStrictEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolStrictEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsProtocolStrictEventTableRequest<'de>>
    for UnknownInteractionsProtocolStrictEventTableRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolStrictEventTableRequest<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolStrictEventTableRequest<'de>>
    for UnknownInteractionsProtocolStrictEventTableRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolStrictEventTableRequest<'de>) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolStrictEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolStrictEventTableRequest<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsProtocolStrictEventTableRequest<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolStrictEventTableRequest<'static> {
    type Decoded<'de> = WireUnknownInteractionsProtocolStrictEventTableRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolStrictEventTableRequest<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsProtocolStrictEventTableRequest<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsProtocolStrictEventTableRequest<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolStrictEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: i32,
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        Self,
        WireUnknownInteractionsProtocolFlexibleEventFieldsRequest,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::Encodable>::COPY_OPTIMIZATION.is_enabled(),
        )
    };

    type Encoded = WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::Encode::encode(self.some_field, encoder, some_field)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                some_field,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.some_field, encoder, some_field)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolFlexibleEventFieldsRequest {
    type EncodedOption =
        ::fidl_next::WireBox<'static, WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleEventFieldsRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnknownInteractionsProtocolFlexibleEventFieldsRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
{
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<
        WireUnknownInteractionsProtocolFlexibleEventFieldsRequest,
        Self,
    > = unsafe {
        ::fidl_next::CopyOptimization::enable_if(
            true && <i32 as ::fidl_next::FromWire<::fidl_next::WireI32>>::COPY_OPTIMIZATION
                .is_enabled(),
        )
    };

    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWire::from_wire(wire.some_field) }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleEventFieldsRequest>
    for UnknownInteractionsProtocolFlexibleEventFieldsRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolFlexibleEventFieldsRequest) -> Self {
        Self { some_field: ::fidl_next::FromWireRef::from_wire_ref(&wire.some_field) }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventFieldsRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleEventFieldsRequest {
    pub some_field: ::fidl_next::WireI32,
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolFlexibleEventFieldsRequest {
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventFieldsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut some_field,

            } = slot;
        }

        ::fidl_next::Decode::decode(some_field.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnknownInteractionsProtocolFlexibleEventUnionRequest {
    SomeField(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventUnionRequest {
    type Encoded = WireUnknownInteractionsProtocolFlexibleEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = out);

        match self {
            Self::SomeField(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnknownInteractionsProtocolFlexibleEventUnionRequest {
    type EncodedOption = WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for UnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleEventUnionRequest: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for UnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___E: ?Sized,
    UnknownInteractionsProtocolFlexibleEventUnionRequest: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleEventUnionRequest) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWire::from_wire(unsafe {
                wire.raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for UnknownInteractionsProtocolFlexibleEventUnionRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolFlexibleEventUnionRequest) -> Self {
        match wire.raw.ordinal() {
            1 => Self::SomeField(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for Box<UnknownInteractionsProtocolFlexibleEventUnionRequest>
{
    #[inline]
    fn from_wire_option(
        wire: WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl
    ::fidl_next::FromWireOptionRef<WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest>
    for Box<UnknownInteractionsProtocolFlexibleEventUnionRequest>
{
    #[inline]
    fn from_wire_option_ref(
        wire: &WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest,
    ) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventUnionRequest`].
#[repr(transparent)]
pub struct WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

impl Drop for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn drop(&mut self) {
        match self.raw.ordinal() {
            1 => {
                let _ = unsafe { self.raw.get().read_unchecked::<::fidl_next::WireI32>() };
            }

            _ => (),
        }
    }
}

unsafe impl ::fidl_next::Wire for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod unknown_interactions_protocol_flexible_event_union_request {
    pub enum Ref<'de> {
        SomeField(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    pub fn as_ref(
        &self,
    ) -> crate::unknown_interactions_protocol_flexible_event_union_request::Ref<'_> {
        match self.raw.ordinal() {

                1 => crate::unknown_interactions_protocol_flexible_event_union_request::Ref::SomeField(
                    unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>() }
                ),


                unknown => crate::unknown_interactions_protocol_flexible_event_union_request::Ref::UnknownOrdinal_(unknown),

        }
    }
}

impl Clone for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    type Decoded<'de> = WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnknownInteractionsProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnknownInteractionsProtocolFlexibleEventUnionRequest> {
        if self.is_some() {
            Some(WireUnknownInteractionsProtocolFlexibleEventUnionRequest {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnknownInteractionsProtocolFlexibleEventUnionRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug, Default)]
pub struct UnknownInteractionsProtocolFlexibleEventTableRequest {
    pub some_field: Option<i32>,
}

impl UnknownInteractionsProtocolFlexibleEventTableRequest {
    fn __max_ordinal(&self) -> usize {
        if self.some_field.is_some() {
            return 1;
        }

        0
    }
}

impl ::fidl_next::Encodable for UnknownInteractionsProtocolFlexibleEventTableRequest {
    type Encoded = WireUnknownInteractionsProtocolFlexibleEventTableRequest<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnknownInteractionsProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode(
        mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = self.some_field.take() {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for UnknownInteractionsProtocolFlexibleEventTableRequest
where
    ___E: ::fidl_next::Encoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnknownInteractionsProtocolFlexibleEventTableRequest { table } = out);

        let max_ord = self.__max_ordinal();

        let mut out = ::core::mem::MaybeUninit::<::fidl_next::WireEnvelope>::uninit();
        ::fidl_next::Wire::zero_padding(&mut out);

        let mut preallocated =
            ::fidl_next::EncoderExt::preallocate::<::fidl_next::WireEnvelope>(encoder, max_ord);

        for i in 1..=max_ord {
            match i {
                1 => {
                    if let Some(some_field) = &self.some_field {
                        ::fidl_next::WireEnvelope::encode_value(
                            some_field,
                            preallocated.encoder,
                            &mut out,
                        )?;
                    } else {
                        ::fidl_next::WireEnvelope::encode_zero(&mut out)
                    }
                }

                _ => ::fidl_next::WireEnvelope::encode_zero(&mut out),
            }
            unsafe {
                preallocated.write_next(out.assume_init_ref());
            }
        }

        ::fidl_next::WireTable::encode_len(table, max_ord);

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de>>
    for UnknownInteractionsProtocolFlexibleEventTableRequest
{
    #[inline]
    fn from_wire(wire: WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de>) -> Self {
        let wire = ::core::mem::ManuallyDrop::new(wire);

        let some_field = wire.table.get(1);

        Self {
            some_field: some_field.map(|envelope| {
                ::fidl_next::FromWire::from_wire(unsafe {
                    envelope.read_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de>>
    for UnknownInteractionsProtocolFlexibleEventTableRequest
{
    #[inline]
    fn from_wire_ref(wire: &WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de>) -> Self {
        Self {
            some_field: wire.table.get(1).map(|envelope| {
                ::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    envelope.deref_unchecked::<::fidl_next::WireI32>()
                })
            }),
        }
    }
}

/// The wire type corresponding to [`UnknownInteractionsProtocolFlexibleEventTableRequest`].
#[repr(C)]
pub struct WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de> {
    table: ::fidl_next::WireTable<'de>,
}

impl<'de> Drop for WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de> {
    fn drop(&mut self) {
        let _ = self
            .table
            .get(1)
            .map(|envelope| unsafe { envelope.read_unchecked::<::fidl_next::WireI32>() });
    }
}

unsafe impl ::fidl_next::Wire
    for WireUnknownInteractionsProtocolFlexibleEventTableRequest<'static>
{
    type Decoded<'de> = WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { table } = out);
        ::fidl_next::WireTable::zero_padding(table);
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireUnknownInteractionsProtocolFlexibleEventTableRequest<'static>
where
    ___D: ::fidl_next::Decoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { table } = slot);

        ::fidl_next::WireTable::decode_with(table, decoder, |ordinal, mut slot, decoder| {
            match ordinal {
                0 => unsafe { ::core::hint::unreachable_unchecked() },

                1 => {
                    ::fidl_next::WireEnvelope::decode_as::<___D, ::fidl_next::WireI32>(
                        slot.as_mut(),
                        decoder,
                    )?;

                    Ok(())
                }

                _ => ::fidl_next::WireEnvelope::decode_unknown(slot, decoder),
            }
        })
    }
}

impl<'de> WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de> {
    pub fn some_field(&self) -> Option<&::fidl_next::WireI32> {
        unsafe { Some(self.table.get(1)?.deref_unchecked()) }
    }
}

impl<'de> ::core::fmt::Debug for WireUnknownInteractionsProtocolFlexibleEventTableRequest<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> Result<(), ::core::fmt::Error> {
        f.debug_struct("UnknownInteractionsProtocolFlexibleEventTableRequest")
            .field("some_field", &self.some_field())
            .finish()
    }
}

/// The type corresponding to the UnknownInteractionsProtocol protocol.
#[derive(Debug)]
pub struct UnknownInteractionsProtocol;

pub mod unknown_interactions_protocol {
    pub mod prelude {
        pub use crate::{
            unknown_interactions_protocol, UnknownInteractionsProtocol,
            UnknownInteractionsProtocolClientHandler, UnknownInteractionsProtocolServerHandler,
        };

        pub use crate::UnknownInteractionsProtocolFlexibleEventFieldsRequest;

        pub use crate::UnknownInteractionsProtocolFlexibleEventTableRequest;

        pub use crate::UnknownInteractionsProtocolFlexibleEventUnionRequest;

        pub use crate::UnknownInteractionsProtocolStrictEventFieldsRequest;

        pub use crate::UnknownInteractionsProtocolStrictEventTableRequest;

        pub use crate::UnknownInteractionsProtocolStrictEventUnionRequest;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayTableResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayUnionResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayErrResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse;

        pub use crate::UnknownInteractionsProtocolFlexibleTwoWayResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayErrResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;

        pub use crate::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse;
    }

    pub struct StrictOneWay;

    impl ::fidl_next::Method for StrictOneWay {
        const ORDINAL: u64 = 5652707722400962470;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct FlexibleOneWay;

    impl ::fidl_next::Method for FlexibleOneWay {
        const ORDINAL: u64 = 583422011583300678;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::Never;
    }

    pub struct StrictTwoWay;

    impl ::fidl_next::Method for StrictTwoWay {
        const ORDINAL: u64 = 8308184097687583042;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ();
    }

    pub struct StrictTwoWayFields;

    impl ::fidl_next::Method for StrictTwoWayFields {
        const ORDINAL: u64 = 3697260130745060067;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsResponse;
    }

    pub struct StrictTwoWayUnion;

    impl ::fidl_next::Method for StrictTwoWayUnion {
        const ORDINAL: u64 = 2455165891480464557;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayUnionResponse;
    }

    pub struct StrictTwoWayTable;

    impl ::fidl_next::Method for StrictTwoWayTable {
        const ORDINAL: u64 = 8389853739594228663;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = crate::WireUnknownInteractionsProtocolStrictTwoWayTableResponse<'static>;
    }

    pub struct StrictTwoWayErr;

    impl ::fidl_next::Method for StrictTwoWayErr {
        const ORDINAL: u64 = 7862264614495172967;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsProtocolStrictTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayFieldsErr;

    impl ::fidl_next::Method for StrictTwoWayFieldsErr {
        const ORDINAL: u64 = 2414673307948662059;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsProtocolStrictTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayUnionErr;

    impl ::fidl_next::Method for StrictTwoWayUnionErr {
        const ORDINAL: u64 = 4988571416540160202;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsProtocolStrictTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictTwoWayTableErr;

    impl ::fidl_next::Method for StrictTwoWayTableErr {
        const ORDINAL: u64 = 5487292735562672344;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireResult<
            'static,
            crate::WireUnknownInteractionsProtocolStrictTwoWayTableErrResponse<'static>,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWay;

    impl ::fidl_next::Method for FlexibleTwoWay {
        const ORDINAL: u64 = 334879577560091516;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            'static,
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayResponse,
        >;
    }

    pub struct FlexibleTwoWayFields;

    impl ::fidl_next::Method for FlexibleTwoWayFields {
        const ORDINAL: u64 = 4257018954691721778;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            'static,
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsResponse,
        >;
    }

    pub struct FlexibleTwoWayUnion;

    impl ::fidl_next::Method for FlexibleTwoWayUnion {
        const ORDINAL: u64 = 4913460516188409782;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            'static,
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionResponse,
        >;
    }

    pub struct FlexibleTwoWayTable;

    impl ::fidl_next::Method for FlexibleTwoWayTable {
        const ORDINAL: u64 = 9171907422498283911;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexible<
            'static,
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableResponse<'static>,
        >;
    }

    pub struct FlexibleTwoWayErr;

    impl ::fidl_next::Method for FlexibleTwoWayErr {
        const ORDINAL: u64 = 6999736795697216519;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            'static,
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayFieldsErr;

    impl ::fidl_next::Method for FlexibleTwoWayFieldsErr {
        const ORDINAL: u64 = 1093132337162001157;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            'static,
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayUnionErr;

    impl ::fidl_next::Method for FlexibleTwoWayUnionErr {
        const ORDINAL: u64 = 2410151523245950935;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            'static,
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse,
            ::fidl_next::WireI32,
        >;
    }

    pub struct FlexibleTwoWayTableErr;

    impl ::fidl_next::Method for FlexibleTwoWayTableErr {
        const ORDINAL: u64 = 7893309626427980786;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ();

        type Response = ::fidl_next::WireFlexibleResult<
            'static,
            crate::WireUnknownInteractionsProtocolFlexibleTwoWayTableErrResponse<'static>,
            ::fidl_next::WireI32,
        >;
    }

    pub struct StrictEvent;

    impl ::fidl_next::Method for StrictEvent {
        const ORDINAL: u64 = 685715276307386305;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct StrictEventFields;

    impl ::fidl_next::Method for StrictEventFields {
        const ORDINAL: u64 = 8896208255987935026;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventFieldsRequest;
    }

    pub struct StrictEventUnion;

    impl ::fidl_next::Method for StrictEventUnion {
        const ORDINAL: u64 = 3919175221694221274;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventUnionRequest;
    }

    pub struct StrictEventTable;

    impl ::fidl_next::Method for StrictEventTable {
        const ORDINAL: u64 = 2711448698318579984;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolStrictEventTableRequest<'static>;
    }

    pub struct FlexibleEvent;

    impl ::fidl_next::Method for FlexibleEvent {
        const ORDINAL: u64 = 7042257263728687206;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = ();
    }

    pub struct FlexibleEventFields;

    impl ::fidl_next::Method for FlexibleEventFields {
        const ORDINAL: u64 = 3613822014516746241;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventFieldsRequest;
    }

    pub struct FlexibleEventUnion;

    impl ::fidl_next::Method for FlexibleEventUnion {
        const ORDINAL: u64 = 2499446536152409191;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventUnionRequest;
    }

    pub struct FlexibleEventTable;

    impl ::fidl_next::Method for FlexibleEventTable {
        const ORDINAL: u64 = 5724881371349617120;

        type Protocol = crate::UnknownInteractionsProtocol;

        type Request = ::fidl_next::Never;

        type Response = crate::WireUnknownInteractionsProtocolFlexibleEventTableRequest<'static>;
    }

    mod ___detail {
        unsafe impl<___T> ::fidl_next::Protocol<___T> for crate::UnknownInteractionsProtocol
        where
            ___T: ::fidl_next::Transport,
        {
            type ClientSender = UnknownInteractionsProtocolClientSender<___T>;
            type ServerSender = UnknownInteractionsProtocolServerSender<___T>;
        }

        /// The client sender for the `UnknownInteractionsProtocol` protocol.
        pub struct UnknownInteractionsProtocolClientSender<___T: ::fidl_next::Transport> {
            #[allow(dead_code)]
            sender: ::fidl_next::protocol::ClientSender<___T>,
        }

        impl<___T> UnknownInteractionsProtocolClientSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(5652707722400962470, ())
            }

            pub fn flexible_one_way(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_one_way(583422011583300678, ())
            }

            pub fn strict_two_way(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWay, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(8308184097687583042, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFields, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(3697260130745060067, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnion, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(2455165891480464557, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTable, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(8389853739594228663, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(7862264614495172967, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_fields_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayFieldsErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(2414673307948662059, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_union_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayUnionErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(4988571416540160202, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn strict_two_way_table_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::StrictTwoWayTableErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(5487292735562672344, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWay, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(334879577560091516, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_fields(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayFields, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(4257018954691721778, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_union(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayUnion, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(4913460516188409782, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_table(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayTable, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(9171907422498283911, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(6999736795697216519, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_fields_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayFieldsErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(1093132337162001157, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_union_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayUnionErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(2410151523245950935, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }

            pub fn flexible_two_way_table_err(
                &self,
            ) -> Result<
                ::fidl_next::ResponseFuture<'_, super::FlexibleTwoWayTableErr, ___T>,
                ::fidl_next::EncodeError,
            > {
                self.sender
                    .send_two_way(7893309626427980786, ())
                    .map(::fidl_next::ResponseFuture::from_untyped)
            }
        }

        /// The server sender for the `UnknownInteractionsProtocol` protocol.
        #[repr(transparent)]
        pub struct UnknownInteractionsProtocolServerSender<___T: ::fidl_next::Transport> {
            sender: ::fidl_next::protocol::ServerSender<___T>,
        }

        impl<___T> UnknownInteractionsProtocolServerSender<___T>
        where
            ___T: ::fidl_next::Transport,
        {
            pub fn strict_event(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_event(685715276307386305, ())
            }

            pub fn strict_event_fields<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventFields as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(8896208255987935026, request)
            }

            pub fn strict_event_union<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventUnion as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(3919175221694221274, request)
            }

            pub fn strict_event_table<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::StrictEventTable as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(2711448698318579984, request)
            }

            pub fn flexible_event(
                &self,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError> {
                self.sender.send_event(7042257263728687206, ())
            }

            pub fn flexible_event_fields<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::FlexibleEventFields as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(3613822014516746241, request)
            }

            pub fn flexible_event_union<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::FlexibleEventUnion as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(2499446536152409191, request)
            }

            pub fn flexible_event_table<___R>(
                &self,
                request: ___R,
            ) -> Result<::fidl_next::SendFuture<'_, ___T>, ::fidl_next::EncodeError>
            where
                ___R: ::fidl_next::Encode<
                    <___T as ::fidl_next::Transport>::SendBuffer,
                    Encoded = <super::FlexibleEventTable as ::fidl_next::Method>::Response,
                >,
            {
                self.sender.send_event(5724881371349617120, request)
            }
        }
    }
}

/// A client handler for the UnknownInteractionsProtocol protocol.
///
/// See [`UnknownInteractionsProtocol`] for more details.
pub trait UnknownInteractionsProtocolClientHandler<___T: ::fidl_next::Transport> {
    fn strict_event(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_protocol::StrictEventFields, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_protocol::StrictEventUnion, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_protocol::StrictEventTable, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_event(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_event_fields(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_protocol::FlexibleEventFields, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_event_union(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_protocol::FlexibleEventUnion, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_event_table(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,

        event: ::fidl_next::Response<unknown_interactions_protocol::FlexibleEventTable, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ClientSender<UnknownInteractionsProtocol, ___T>,
        ordinal: u64,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send {
        sender.close();
        ::core::future::ready(())
    }
}

impl<___H, ___T> ::fidl_next::ClientProtocol<___H, ___T> for UnknownInteractionsProtocol
where
    ___H: UnknownInteractionsProtocolClientHandler<___T> + Send,
    ___T: ::fidl_next::Transport,

    <unknown_interactions_protocol::StrictTwoWayFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayFieldsErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayUnionErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictTwoWayTableErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWay as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayFieldsErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayUnionErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleTwoWayTableErr as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::StrictEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleEventFields as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleEventUnion as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <unknown_interactions_protocol::FlexibleEventTable as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    async fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            685715276307386305 => {
                handler.strict_event(sender).await;
            }

            8896208255987935026 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_fields(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            3919175221694221274 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_union(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            2711448698318579984 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.strict_event_table(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            7042257263728687206 => {
                handler.flexible_event(sender).await;
            }

            3613822014516746241 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.flexible_event_fields(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            2499446536152409191 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.flexible_event_union(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            5724881371349617120 => match ::fidl_next::DecoderExt::decode(buffer) {
                Ok(decoded) => handler.flexible_event_table(sender, decoded).await,
                Err(e) => {
                    sender.close();
                }
            },

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }
}

/// A server handler for the UnknownInteractionsProtocol protocol.
///
/// See [`UnknownInteractionsProtocol`] for more details.
pub trait UnknownInteractionsProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_one_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWay>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayFields>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayUnion>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayTable>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayFieldsErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayUnionErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn strict_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::StrictTwoWayTableErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWay>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_fields(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayFields>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_union(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayUnion>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_table(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayTable>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_fields_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayFieldsErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_union_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayUnionErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn flexible_two_way_table_err(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,

        responder: ::fidl_next::Responder<unknown_interactions_protocol::FlexibleTwoWayTableErr>,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send;

    fn on_unknown_interaction(
        &mut self,
        sender: &::fidl_next::ServerSender<UnknownInteractionsProtocol, ___T>,
        ordinal: u64,
    ) -> impl ::core::future::Future<Output = ()> + ::core::marker::Send {
        sender.close();
        ::core::future::ready(())
    }
}

impl<___H, ___T> ::fidl_next::ServerProtocol<___H, ___T> for UnknownInteractionsProtocol
where
    ___H: UnknownInteractionsProtocolServerHandler<___T> + Send,
    ___T: ::fidl_next::Transport,
{
    async fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5652707722400962470 => {
                handler.strict_one_way(sender).await;
            }

            583422011583300678 => {
                handler.flexible_one_way(sender).await;
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }

    async fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<Self, ___T>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8308184097687583042 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way(sender, responder).await;
            }

            3697260130745060067 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields(sender, responder).await;
            }

            2455165891480464557 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union(sender, responder).await;
            }

            8389853739594228663 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table(sender, responder).await;
            }

            7862264614495172967 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_err(sender, responder).await;
            }

            2414673307948662059 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_fields_err(sender, responder).await;
            }

            4988571416540160202 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_union_err(sender, responder).await;
            }

            5487292735562672344 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_two_way_table_err(sender, responder).await;
            }

            334879577560091516 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way(sender, responder).await;
            }

            4257018954691721778 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields(sender, responder).await;
            }

            4913460516188409782 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union(sender, responder).await;
            }

            9171907422498283911 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table(sender, responder).await;
            }

            6999736795697216519 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_err(sender, responder).await;
            }

            1093132337162001157 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_fields_err(sender, responder).await;
            }

            2410151523245950935 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_union_err(sender, responder).await;
            }

            7893309626427980786 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_two_way_table_err(sender, responder).await;
            }

            ordinal => handler.on_unknown_interaction(sender, ordinal).await,
        }
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsAjarDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsAjarDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsAjarDriverProtocol,
    >;

    #[cfg(feature = "driver")]
    impl ::core::convert::From<crate::UnknownInteractionsAjarDriverProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsAjarDriverProtocolMarker
    {
        #[inline]
        fn from(_: crate::UnknownInteractionsAjarDriverProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsAjarProtocol`
    /// protocol.
    pub type UnknownInteractionsAjarProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsAjarProtocol,
    >;

    impl ::core::convert::From<crate::UnknownInteractionsAjarProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsAjarProtocolMarker
    {
        #[inline]
        fn from(_: crate::UnknownInteractionsAjarProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsClosedDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsClosedDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsClosedDriverProtocol,
    >;

    #[cfg(feature = "driver")]
    impl ::core::convert::From<crate::UnknownInteractionsClosedDriverProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsClosedDriverProtocolMarker
    {
        #[inline]
        fn from(_: crate::UnknownInteractionsClosedDriverProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsClosedProtocol`
    /// protocol.
    pub type UnknownInteractionsClosedProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsClosedProtocol,
    >;

    impl ::core::convert::From<crate::UnknownInteractionsClosedProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsClosedProtocolMarker
    {
        #[inline]
        fn from(_: crate::UnknownInteractionsClosedProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsDriverProtocol`
    /// protocol.
    pub type UnknownInteractionsDriverProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsDriverProtocol,
    >;

    #[cfg(feature = "driver")]
    impl ::core::convert::From<crate::UnknownInteractionsDriverProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsDriverProtocolMarker
    {
        #[inline]
        fn from(_: crate::UnknownInteractionsDriverProtocol) -> Self {
            Self
        }
    }

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `UnknownInteractionsProtocol`
    /// protocol.
    pub type UnknownInteractionsProtocolProxy = ::fidl_next::ClientSender<
        ::fidl_next::fuchsia::zx::Channel,
        crate::UnknownInteractionsProtocol,
    >;

    impl ::core::convert::From<crate::UnknownInteractionsProtocol>
        for ::fidl_test_unknowninteractions::UnknownInteractionsProtocolMarker
    {
        #[inline]
        fn from(_: crate::UnknownInteractionsProtocol) -> Self {
            Self
        }
    }
}
