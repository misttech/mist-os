// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub type AliasOfArray = [u64; 1];

/// The wire type corresponding to [`AliasOfArray`].
pub type WireAliasOfArray = [::fidl_next::u64_le; 1];

pub type U64 = u64;

/// The wire type corresponding to [`U64`].
pub type WireU64 = ::fidl_next::u64_le;

pub type AliasOfArrayContainingAliasOfArray = [u64; 2];

/// The wire type corresponding to [`AliasOfArrayContainingAliasOfArray`].
pub type WireAliasOfArrayContainingAliasOfArray = [::fidl_next::u64_le; 2];

pub type AliasOfBytes = Vec<u8>;

/// The wire type corresponding to [`AliasOfBytes`].
pub type WireAliasOfBytes = ::fidl_next::WireVector<u8>;

pub type AliasOfRequest =
    ::fidl_next::bind::ServerEnd<Option<::fidl_next::fuchsia::zx::Handle>, crate::MyProtocol>;

/// The wire type corresponding to [`AliasOfRequest`].
pub type WireAliasOfRequest =
    ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireOptionalHandle, crate::MyProtocol>;

pub type AliasOfString = String;

/// The wire type corresponding to [`AliasOfString`].
pub type WireAliasOfString = ::fidl_next::WireString;

pub type AliasOfVectorContainingAliasOfVector = Vec<u64>;

/// The wire type corresponding to [`AliasOfVectorContainingAliasOfVector`].
pub type WireAliasOfVectorContainingAliasOfVector = ::fidl_next::WireVector<::fidl_next::u64_le>;

/// The type corresponding to the MyProtocol protocol.
#[derive(Debug)]
pub struct MyProtocol;

pub mod my_protocol {}

/// A helper trait for the `MyProtocol` client sender.
pub trait MyProtocolClientSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> MyProtocolClientSender<___T> for ::fidl_next::bind::ClientSender<___T, MyProtocol> where
    ___T: ::fidl_next::protocol::Transport
{
}

/// A client handler for the MyProtocol protocol.
///
/// See [`MyProtocol`] for more details.
pub trait MyProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for MyProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: MyProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `MyProtocol` server sender.
pub trait MyProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> MyProtocolServerSender<___T> for ::fidl_next::bind::ServerSender<___T, MyProtocol> where
    ___T: ::fidl_next::protocol::Transport
{
}

/// A server handler for the MyProtocol protocol.
///
/// See [`MyProtocol`] for more details.
pub trait MyProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for MyProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: MyProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

pub type Vector = Option<Vec<u64>>;

/// The wire type corresponding to [`Vector`].
pub type WireVector = ::fidl_next::WireOptionalVector<::fidl_next::u64_le>;

#[derive(Debug)]
pub struct Testing {
    pub u1: u64,

    pub u2: Vec<u64>,

    pub u3: [u64; 1],

    pub u4: Vec<Vec<u64>>,

    pub u5: Vec<[u64; 1]>,

    pub u6: [Vec<u64>; 4],

    pub u7: [[u64; 1]; 4],

    pub v1: Option<Vec<u64>>,

    pub v2: Vec<Option<Vec<u64>>>,

    pub v3: [Option<Vec<u64>>; 4],

    pub a1: [u64; 1],

    pub a2: Vec<[u64; 1]>,

    pub a3: [[u64; 1]; 4],

    pub r1:
        ::fidl_next::bind::ServerEnd<Option<::fidl_next::fuchsia::zx::Handle>, crate::MyProtocol>,

    pub r2: Vec<
        ::fidl_next::bind::ServerEnd<Option<::fidl_next::fuchsia::zx::Handle>, crate::MyProtocol>,
    >,

    pub r3:
        [::fidl_next::bind::ServerEnd<Option<::fidl_next::fuchsia::zx::Handle>, crate::MyProtocol>;
            4],

    pub b1: Vec<u8>,

    pub b2: Vec<Vec<u8>>,

    pub b3: [Vec<u8>; 4],

    pub s1: String,

    pub s2: Vec<String>,

    pub s3: [String; 4],

    pub vv1: Vec<u64>,

    pub vv2: Vec<Vec<u64>>,

    pub vv3: [Vec<u64>; 3],

    pub aa1: [u64; 2],

    pub aa2: Vec<[u64; 2]>,

    pub aa3: [[u64; 2]; 3],
}

impl ::fidl_next::Encodable for Testing {
    type Encoded = WireTesting;
}

impl<___E> ::fidl_next::Encode<___E> for Testing
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u1,
                u2,
                u3,
                u4,
                u5,
                u6,
                u7,
                v1,
                v2,
                v3,
                a1,
                a2,
                a3,
                r1,
                r2,
                r3,
                b1,
                b2,
                b3,
                s1,
                s2,
                s3,
                vv1,
                vv2,
                vv3,
                aa1,
                aa2,
                aa3,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.u1, encoder, u1)?;

        ::fidl_next::Encode::encode(&mut self.u2, encoder, u2)?;

        ::fidl_next::Encode::encode(&mut self.u3, encoder, u3)?;

        ::fidl_next::Encode::encode(&mut self.u4, encoder, u4)?;

        ::fidl_next::Encode::encode(&mut self.u5, encoder, u5)?;

        ::fidl_next::Encode::encode(&mut self.u6, encoder, u6)?;

        ::fidl_next::Encode::encode(&mut self.u7, encoder, u7)?;

        ::fidl_next::Encode::encode(&mut self.v1, encoder, v1)?;

        ::fidl_next::Encode::encode(&mut self.v2, encoder, v2)?;

        ::fidl_next::Encode::encode(&mut self.v3, encoder, v3)?;

        ::fidl_next::Encode::encode(&mut self.a1, encoder, a1)?;

        ::fidl_next::Encode::encode(&mut self.a2, encoder, a2)?;

        ::fidl_next::Encode::encode(&mut self.a3, encoder, a3)?;

        ::fidl_next::Encode::encode(&mut self.r1, encoder, r1)?;

        ::fidl_next::Encode::encode(&mut self.r2, encoder, r2)?;

        ::fidl_next::Encode::encode(&mut self.r3, encoder, r3)?;

        ::fidl_next::Encode::encode(&mut self.b1, encoder, b1)?;

        ::fidl_next::Encode::encode(&mut self.b2, encoder, b2)?;

        ::fidl_next::Encode::encode(&mut self.b3, encoder, b3)?;

        ::fidl_next::Encode::encode(&mut self.s1, encoder, s1)?;

        ::fidl_next::Encode::encode(&mut self.s2, encoder, s2)?;

        ::fidl_next::Encode::encode(&mut self.s3, encoder, s3)?;

        ::fidl_next::Encode::encode(&mut self.vv1, encoder, vv1)?;

        ::fidl_next::Encode::encode(&mut self.vv2, encoder, vv2)?;

        ::fidl_next::Encode::encode(&mut self.vv3, encoder, vv3)?;

        ::fidl_next::Encode::encode(&mut self.aa1, encoder, aa1)?;

        ::fidl_next::Encode::encode(&mut self.aa2, encoder, aa2)?;

        ::fidl_next::Encode::encode(&mut self.aa3, encoder, aa3)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<Testing> {
    type EncodedOption = ::fidl_next::WireBox<WireTesting>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<Testing>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Testing: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTesting> for Testing {
    fn take_from(from: &WireTesting) -> Self {
        Self {
            u1: ::fidl_next::TakeFrom::take_from(&from.u1),

            u2: ::fidl_next::TakeFrom::take_from(&from.u2),

            u3: ::fidl_next::TakeFrom::take_from(&from.u3),

            u4: ::fidl_next::TakeFrom::take_from(&from.u4),

            u5: ::fidl_next::TakeFrom::take_from(&from.u5),

            u6: ::fidl_next::TakeFrom::take_from(&from.u6),

            u7: ::fidl_next::TakeFrom::take_from(&from.u7),

            v1: ::fidl_next::TakeFrom::take_from(&from.v1),

            v2: ::fidl_next::TakeFrom::take_from(&from.v2),

            v3: ::fidl_next::TakeFrom::take_from(&from.v3),

            a1: ::fidl_next::TakeFrom::take_from(&from.a1),

            a2: ::fidl_next::TakeFrom::take_from(&from.a2),

            a3: ::fidl_next::TakeFrom::take_from(&from.a3),

            r1: ::fidl_next::TakeFrom::take_from(&from.r1),

            r2: ::fidl_next::TakeFrom::take_from(&from.r2),

            r3: ::fidl_next::TakeFrom::take_from(&from.r3),

            b1: ::fidl_next::TakeFrom::take_from(&from.b1),

            b2: ::fidl_next::TakeFrom::take_from(&from.b2),

            b3: ::fidl_next::TakeFrom::take_from(&from.b3),

            s1: ::fidl_next::TakeFrom::take_from(&from.s1),

            s2: ::fidl_next::TakeFrom::take_from(&from.s2),

            s3: ::fidl_next::TakeFrom::take_from(&from.s3),

            vv1: ::fidl_next::TakeFrom::take_from(&from.vv1),

            vv2: ::fidl_next::TakeFrom::take_from(&from.vv2),

            vv3: ::fidl_next::TakeFrom::take_from(&from.vv3),

            aa1: ::fidl_next::TakeFrom::take_from(&from.aa1),

            aa2: ::fidl_next::TakeFrom::take_from(&from.aa2),

            aa3: ::fidl_next::TakeFrom::take_from(&from.aa3),
        }
    }
}

/// The wire type corersponding to [`Testing`].
#[derive(Debug)]
#[repr(C)]
pub struct WireTesting {
    pub u1: ::fidl_next::u64_le,

    pub u2: ::fidl_next::WireVector<::fidl_next::u64_le>,

    pub u3: [::fidl_next::u64_le; 1],

    pub u4: ::fidl_next::WireVector<::fidl_next::WireVector<::fidl_next::u64_le>>,

    pub u5: ::fidl_next::WireVector<[::fidl_next::u64_le; 1]>,

    pub u6: [::fidl_next::WireVector<::fidl_next::u64_le>; 4],

    pub u7: [[::fidl_next::u64_le; 1]; 4],

    pub v1: ::fidl_next::WireOptionalVector<::fidl_next::u64_le>,

    pub v2: ::fidl_next::WireVector<::fidl_next::WireOptionalVector<::fidl_next::u64_le>>,

    pub v3: [::fidl_next::WireOptionalVector<::fidl_next::u64_le>; 4],

    pub a1: [::fidl_next::u64_le; 1],

    pub a2: ::fidl_next::WireVector<[::fidl_next::u64_le; 1]>,

    pub a3: [[::fidl_next::u64_le; 1]; 4],

    pub r1:
        ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireOptionalHandle, crate::MyProtocol>,

    pub r2: ::fidl_next::WireVector<
        ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireOptionalHandle, crate::MyProtocol>,
    >,

    pub r3:
        [::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireOptionalHandle, crate::MyProtocol>;
            4],

    pub b1: ::fidl_next::WireVector<u8>,

    pub b2: ::fidl_next::WireVector<::fidl_next::WireVector<u8>>,

    pub b3: [::fidl_next::WireVector<u8>; 4],

    pub s1: ::fidl_next::WireString,

    pub s2: ::fidl_next::WireVector<::fidl_next::WireString>,

    pub s3: [::fidl_next::WireString; 4],

    pub vv1: ::fidl_next::WireVector<::fidl_next::u64_le>,

    pub vv2: ::fidl_next::WireVector<::fidl_next::WireVector<::fidl_next::u64_le>>,

    pub vv3: [::fidl_next::WireVector<::fidl_next::u64_le>; 3],

    pub aa1: [::fidl_next::u64_le; 2],

    pub aa2: ::fidl_next::WireVector<[::fidl_next::u64_le; 2]>,

    pub aa3: [[::fidl_next::u64_le; 2]; 3],
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireTesting
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder<'buf>,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u1,
                mut u2,
                mut u3,
                mut u4,
                mut u5,
                mut u6,
                mut u7,
                mut v1,
                mut v2,
                mut v3,
                mut a1,
                mut a2,
                mut a3,
                mut r1,
                mut r2,
                mut r3,
                mut b1,
                mut b2,
                mut b3,
                mut s1,
                mut s2,
                mut s3,
                mut vv1,
                mut vv2,
                mut vv3,
                mut aa1,
                mut aa2,
                mut aa3,

            } = slot;
        }

        ::fidl_next::Decode::decode(u1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u2.as_mut(), decoder)?;

        let u2 = unsafe { u2.deref_unchecked() };

        if u2.len() > 1 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: u2.len() as u64,
                limit: 1,
            });
        }

        ::fidl_next::Decode::decode(u3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u6.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(v1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(v2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(v3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(a1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(a2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(a3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(r3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(s1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(s2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(s3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(vv1.as_mut(), decoder)?;

        let vv1 = unsafe { vv1.deref_unchecked() };

        if vv1.len() > 2 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: vv1.len() as u64,
                limit: 2,
            });
        }

        ::fidl_next::Decode::decode(vv2.as_mut(), decoder)?;

        let vv2 = unsafe { vv2.deref_unchecked() };

        if vv2.len() > 3 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: vv2.len() as u64,
                limit: 3,
            });
        }

        ::fidl_next::Decode::decode(vv3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(aa1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(aa2.as_mut(), decoder)?;

        let aa2 = unsafe { aa2.deref_unchecked() };

        if aa2.len() > 3 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: aa2.len() as u64,
                limit: 3,
            });
        }

        ::fidl_next::Decode::decode(aa3.as_mut(), decoder)?;

        Ok(())
    }
}
