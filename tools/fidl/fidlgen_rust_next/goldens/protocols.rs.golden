// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the AnotherDiscoverableProtocol protocol.
#[derive(Debug)]
pub struct AnotherDiscoverableProtocol;

pub mod another_discoverable_protocol {}

/// A helper trait for the `AnotherDiscoverableProtocol` client sender.
pub trait AnotherDiscoverableProtocolClientSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> AnotherDiscoverableProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, AnotherDiscoverableProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A client handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for AnotherDiscoverableProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: AnotherDiscoverableProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `AnotherDiscoverableProtocol` server sender.
pub trait AnotherDiscoverableProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> AnotherDiscoverableProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, AnotherDiscoverableProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the AnotherDiscoverableProtocol protocol.
///
/// See [`AnotherDiscoverableProtocol`] for more details.
pub trait AnotherDiscoverableProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for AnotherDiscoverableProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: AnotherDiscoverableProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct ChannelProtocolMethodARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodARequest {
    type Encoded = WireChannelProtocolMethodARequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodARequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMethodARequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodARequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodARequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodARequest> for ChannelProtocolMethodARequest {
    fn take_from(from: &WireChannelProtocolMethodARequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corersponding to [`ChannelProtocolMethodARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodARequest {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodARequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ChannelProtocolEventARequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolEventARequest {
    type Encoded = WireChannelProtocolEventARequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolEventARequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolEventARequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolEventARequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolEventARequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolEventARequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolEventARequest> for ChannelProtocolEventARequest {
    fn take_from(from: &WireChannelProtocolEventARequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corersponding to [`ChannelProtocolEventARequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolEventARequest {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolEventARequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ChannelProtocolMethodBRequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBRequest {
    type Encoded = WireChannelProtocolMethodBRequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodBRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMethodBRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodBRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodBRequest> for ChannelProtocolMethodBRequest {
    fn take_from(from: &WireChannelProtocolMethodBRequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corersponding to [`ChannelProtocolMethodBRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBRequest {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct ChannelProtocolMethodBResponse {
    pub result: i64,
}

impl ::fidl_next::Encodable for ChannelProtocolMethodBResponse {
    type Encoded = WireChannelProtocolMethodBResponse;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMethodBResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                result,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.result, encoder, result)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMethodBResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMethodBResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMethodBResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMethodBResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMethodBResponse> for ChannelProtocolMethodBResponse {
    fn take_from(from: &WireChannelProtocolMethodBResponse) -> Self {
        Self { result: ::fidl_next::TakeFrom::take_from(&from.result) }
    }
}

/// The wire type corersponding to [`ChannelProtocolMethodBResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireChannelProtocolMethodBResponse {
    pub result: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMethodBResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut result,

            } = slot;
        }

        ::fidl_next::Decode::decode(result.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct ChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolTakeHandleRequest {
    type Encoded = WireChannelProtocolTakeHandleRequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolTakeHandleRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolTakeHandleRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolTakeHandleRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolTakeHandleRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolTakeHandleRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolTakeHandleRequest>
    for ChannelProtocolTakeHandleRequest
{
    fn take_from(from: &WireChannelProtocolTakeHandleRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corersponding to [`ChannelProtocolTakeHandleRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolTakeHandleRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolTakeHandleRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct ChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketRequest {
    type Encoded = WireChannelProtocolMutateSocketRequest;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMutateSocketRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMutateSocketRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMutateSocketRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMutateSocketRequest>
    for ChannelProtocolMutateSocketRequest
{
    fn take_from(from: &WireChannelProtocolMutateSocketRequest) -> Self {
        Self { a: ::fidl_next::TakeFrom::take_from(&from.a) }
    }
}

/// The wire type corersponding to [`ChannelProtocolMutateSocketRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketRequest {
    pub a: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct ChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for ChannelProtocolMutateSocketResponse {
    type Encoded = WireChannelProtocolMutateSocketResponse;
}

impl<___E> ::fidl_next::Encode<___E> for ChannelProtocolMutateSocketResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ChannelProtocolMutateSocketResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireChannelProtocolMutateSocketResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ChannelProtocolMutateSocketResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ChannelProtocolMutateSocketResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireChannelProtocolMutateSocketResponse>
    for ChannelProtocolMutateSocketResponse
{
    fn take_from(from: &WireChannelProtocolMutateSocketResponse) -> Self {
        Self { b: ::fidl_next::TakeFrom::take_from(&from.b) }
    }
}

/// The wire type corersponding to [`ChannelProtocolMutateSocketResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireChannelProtocolMutateSocketResponse {
    pub b: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireChannelProtocolMutateSocketResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ChannelProtocol protocol.
#[derive(Debug)]
pub struct ChannelProtocol;

pub mod channel_protocol {

    pub struct MethodA;

    impl ::fidl_next::bind::Method for MethodA {
        const ORDINAL: u64 = 3155008840945527714;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMethodARequest;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct EventA;

    impl ::fidl_next::bind::Method for EventA {
        const ORDINAL: u64 = 2220452875311597006;

        type Protocol = crate::ChannelProtocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireChannelProtocolEventARequest;
    }

    pub struct MethodB;

    impl ::fidl_next::bind::Method for MethodB {
        const ORDINAL: u64 = 8903004957800778182;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMethodBRequest;

        type Response = crate::WireChannelProtocolMethodBResponse;
    }

    pub struct TakeHandle;

    impl ::fidl_next::bind::Method for TakeHandle {
        const ORDINAL: u64 = 591935489944717925;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolTakeHandleRequest;

        type Response = ();
    }

    pub struct MutateSocket;

    impl ::fidl_next::bind::Method for MutateSocket {
        const ORDINAL: u64 = 7411742788430590287;

        type Protocol = crate::ChannelProtocol;

        type Request = crate::WireChannelProtocolMutateSocketRequest;

        type Response = crate::WireChannelProtocolMutateSocketResponse;
    }
}

/// A helper trait for the `ChannelProtocol` client sender.
pub trait ChannelProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn method_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodARequest,
        >;

    fn method_b<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::MethodB>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodBRequest,
        >;

    fn take_handle<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::TakeHandle>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolTakeHandleRequest,
        >;

    fn mutate_socket<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::MutateSocket>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolMutateSocketRequest,
        >;
}

impl<___T> ChannelProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, ChannelProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn method_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodARequest,
        >,
    {
        self.as_untyped().send_one_way(3155008840945527714, request)
    }

    fn method_b<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::MethodB>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolMethodBRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8903004957800778182, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn take_handle<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::TakeHandle>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolTakeHandleRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(591935489944717925, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn mutate_socket<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, channel_protocol::MutateSocket>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolMutateSocketRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(7411742788430590287, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn event_a(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, ChannelProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, channel_protocol::EventA>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for ChannelProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ChannelProtocolClientHandler<___T>,

    for<'buf> crate::WireChannelProtocolEventARequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireChannelProtocolMethodBResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireChannelProtocolMutateSocketResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            2220452875311597006 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.event_a(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ChannelProtocol` server sender.
pub trait ChannelProtocolServerSender<___T: ::fidl_next::protocol::Transport> {
    fn event_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolEventARequest,
        >;
}

impl<___T> ChannelProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, ChannelProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn event_a<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireChannelProtocolEventARequest,
        >,
    {
        self.as_untyped().send_event(2220452875311597006, request)
    }
}

/// A server handler for the ChannelProtocol protocol.
///
/// See [`ChannelProtocol`] for more details.
pub trait ChannelProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn method_a(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, channel_protocol::MethodA>,
    );

    fn method_b(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, channel_protocol::MethodB>,

        responder: ::fidl_next::bind::Responder<channel_protocol::MethodB>,
    );

    fn take_handle(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, channel_protocol::TakeHandle>,

        responder: ::fidl_next::bind::Responder<channel_protocol::TakeHandle>,
    );

    fn mutate_socket(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ChannelProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, channel_protocol::MutateSocket>,

        responder: ::fidl_next::bind::Responder<channel_protocol::MutateSocket>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for ChannelProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ChannelProtocolServerHandler<___T>,

    for<'buf> crate::WireChannelProtocolMethodARequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireChannelProtocolMethodBRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireChannelProtocolTakeHandleRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireChannelProtocolMutateSocketRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3155008840945527714 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.method_a(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            8903004957800778182 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.method_b(sender, buffer, responder);
            }

            591935489944717925 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.take_handle(sender, buffer, responder);
            }

            7411742788430590287 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.mutate_socket(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the DiscoverableProtocol protocol.
#[derive(Debug)]
pub struct DiscoverableProtocol;

pub mod discoverable_protocol {

    pub struct Method;

    impl ::fidl_next::bind::Method for Method {
        const ORDINAL: u64 = 3455873048082739435;

        type Protocol = crate::DiscoverableProtocol;

        type Request = ();

        type Response = ::fidl_next::bind::Never;
    }
}

/// A helper trait for the `DiscoverableProtocol` client sender.
pub trait DiscoverableProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn method(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;
}

impl<___T> DiscoverableProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, DiscoverableProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn method(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(3455873048082739435, &mut ())
    }
}

/// A client handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for DiscoverableProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: DiscoverableProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `DiscoverableProtocol` server sender.
pub trait DiscoverableProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> DiscoverableProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, DiscoverableProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the DiscoverableProtocol protocol.
///
/// See [`DiscoverableProtocol`] for more details.
pub trait DiscoverableProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn method(&mut self, sender: &::fidl_next::bind::ServerSender<___T, DiscoverableProtocol>);
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for DiscoverableProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: DiscoverableProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            3455873048082739435 => {
                handler.method(sender);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum ErrorEnum {
    ErrFoo = 1,
    ErrBar = 2,
}

impl ::fidl_next::Encodable for ErrorEnum {
    type Encoded = WireErrorEnum;
}

impl<___E> ::fidl_next::Encode<___E> for ErrorEnum
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireErrorEnum { mut value } = slot);
        *value = ::fidl_next::u32_le::from(match *self {
            Self::ErrFoo => 1,

            Self::ErrBar => 2,
        });

        Ok(())
    }
}

impl ::core::convert::From<WireErrorEnum> for ErrorEnum {
    fn from(wire: WireErrorEnum) -> Self {
        match u32::from(wire.value) {
            1 => Self::ErrFoo,

            2 => Self::ErrBar,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireErrorEnum> for ErrorEnum {
    fn take_from(from: &WireErrorEnum) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`ErrorEnum`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireErrorEnum {
    value: ::fidl_next::u32_le,
}

impl WireErrorEnum {
    pub const ERR_FOO: WireErrorEnum = WireErrorEnum { value: ::fidl_next::u32_le::from_native(1) };

    pub const ERR_BAR: WireErrorEnum = WireErrorEnum { value: ::fidl_next::u32_le::from_native(2) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireErrorEnum
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            1 | 2 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<ErrorEnum> for WireErrorEnum {
    fn from(natural: ErrorEnum) -> Self {
        match natural {
            ErrorEnum::ErrFoo => WireErrorEnum::ERR_FOO,

            ErrorEnum::ErrBar => WireErrorEnum::ERR_BAR,
        }
    }
}

#[derive(Debug)]
pub struct HandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolNoResponseMethodRequest {
    type Encoded = WireHandleRightsProtocolNoResponseMethodRequest;
}

impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolNoResponseMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolNoResponseMethodRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireHandleRightsProtocolNoResponseMethodRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolNoResponseMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolNoResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolNoResponseMethodRequest>
    for HandleRightsProtocolNoResponseMethodRequest
{
    fn take_from(from: &WireHandleRightsProtocolNoResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corersponding to [`HandleRightsProtocolNoResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolNoResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolNoResponseMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct HandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodRequest {
    type Encoded = WireHandleRightsProtocolResponseMethodRequest;
}

impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolResponseMethodRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireHandleRightsProtocolResponseMethodRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolResponseMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolResponseMethodRequest>
    for HandleRightsProtocolResponseMethodRequest
{
    fn take_from(from: &WireHandleRightsProtocolResponseMethodRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corersponding to [`HandleRightsProtocolResponseMethodRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct HandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolResponseMethodResponse {
    type Encoded = WireHandleRightsProtocolResponseMethodResponse;
}

impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolResponseMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolResponseMethodResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireHandleRightsProtocolResponseMethodResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolResponseMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolResponseMethodResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolResponseMethodResponse>
    for HandleRightsProtocolResponseMethodResponse
{
    fn take_from(from: &WireHandleRightsProtocolResponseMethodResponse) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corersponding to [`HandleRightsProtocolResponseMethodResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolResponseMethodResponse {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolResponseMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct HandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for HandleRightsProtocolAnEventRequest {
    type Encoded = WireHandleRightsProtocolAnEventRequest;
}

impl<___E> ::fidl_next::Encode<___E> for HandleRightsProtocolAnEventRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<HandleRightsProtocolAnEventRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireHandleRightsProtocolAnEventRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<HandleRightsProtocolAnEventRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    HandleRightsProtocolAnEventRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireHandleRightsProtocolAnEventRequest>
    for HandleRightsProtocolAnEventRequest
{
    fn take_from(from: &WireHandleRightsProtocolAnEventRequest) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corersponding to [`HandleRightsProtocolAnEventRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireHandleRightsProtocolAnEventRequest {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireHandleRightsProtocolAnEventRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the HandleRightsProtocol protocol.
#[derive(Debug)]
pub struct HandleRightsProtocol;

pub mod handle_rights_protocol {

    pub struct NoResponseMethod;

    impl ::fidl_next::bind::Method for NoResponseMethod {
        const ORDINAL: u64 = 1155044649514904573;

        type Protocol = crate::HandleRightsProtocol;

        type Request = crate::WireHandleRightsProtocolNoResponseMethodRequest;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct ResponseMethod;

    impl ::fidl_next::bind::Method for ResponseMethod {
        const ORDINAL: u64 = 5956276128041940295;

        type Protocol = crate::HandleRightsProtocol;

        type Request = crate::WireHandleRightsProtocolResponseMethodRequest;

        type Response = crate::WireHandleRightsProtocolResponseMethodResponse;
    }

    pub struct AnEvent;

    impl ::fidl_next::bind::Method for AnEvent {
        const ORDINAL: u64 = 476727631355490611;

        type Protocol = crate::HandleRightsProtocol;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireHandleRightsProtocolAnEventRequest;
    }
}

/// A helper trait for the `HandleRightsProtocol` client sender.
pub trait HandleRightsProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn no_response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolNoResponseMethodRequest,
        >;

    fn response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, handle_rights_protocol::ResponseMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolResponseMethodRequest,
        >;
}

impl<___T> HandleRightsProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, HandleRightsProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn no_response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolNoResponseMethodRequest,
        >,
    {
        self.as_untyped().send_one_way(1155044649514904573, request)
    }

    fn response_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, handle_rights_protocol::ResponseMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolResponseMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(5956276128041940295, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn an_event(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, HandleRightsProtocol>,

        message: ::fidl_next::bind::ResponseBuffer<___T, handle_rights_protocol::AnEvent>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for HandleRightsProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: HandleRightsProtocolClientHandler<___T>,

    for<'buf> crate::WireHandleRightsProtocolResponseMethodResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireHandleRightsProtocolAnEventRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            476727631355490611 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.an_event(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `HandleRightsProtocol` server sender.
pub trait HandleRightsProtocolServerSender<___T: ::fidl_next::protocol::Transport> {
    fn an_event<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolAnEventRequest,
        >;
}

impl<___T> HandleRightsProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, HandleRightsProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn an_event<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireHandleRightsProtocolAnEventRequest,
        >,
    {
        self.as_untyped().send_event(476727631355490611, request)
    }
}

/// A server handler for the HandleRightsProtocol protocol.
///
/// See [`HandleRightsProtocol`] for more details.
pub trait HandleRightsProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn no_response_method(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, HandleRightsProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, handle_rights_protocol::NoResponseMethod>,
    );

    fn response_method(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, HandleRightsProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, handle_rights_protocol::ResponseMethod>,

        responder: ::fidl_next::bind::Responder<handle_rights_protocol::ResponseMethod>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for HandleRightsProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: HandleRightsProtocolServerHandler<___T>,

    for<'buf> crate::WireHandleRightsProtocolNoResponseMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireHandleRightsProtocolResponseMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            1155044649514904573 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.no_response_method(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5956276128041940295 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.response_method(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct ManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

impl ::fidl_next::Encodable for ManyParametersFifteenRequest {
    type Encoded = WireManyParametersFifteenRequest;
}

impl<___E> ::fidl_next::Encode<___E> for ManyParametersFifteenRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                p1,
                p2,
                p3,
                p4,
                p5,
                p6,
                p7,
                p8,
                p9,
                p10,
                p11,
                p12,
                p13,
                p14,
                p15,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.p1, encoder, p1)?;

        ::fidl_next::Encode::encode(&mut self.p2, encoder, p2)?;

        ::fidl_next::Encode::encode(&mut self.p3, encoder, p3)?;

        ::fidl_next::Encode::encode(&mut self.p4, encoder, p4)?;

        ::fidl_next::Encode::encode(&mut self.p5, encoder, p5)?;

        ::fidl_next::Encode::encode(&mut self.p6, encoder, p6)?;

        ::fidl_next::Encode::encode(&mut self.p7, encoder, p7)?;

        ::fidl_next::Encode::encode(&mut self.p8, encoder, p8)?;

        ::fidl_next::Encode::encode(&mut self.p9, encoder, p9)?;

        ::fidl_next::Encode::encode(&mut self.p10, encoder, p10)?;

        ::fidl_next::Encode::encode(&mut self.p11, encoder, p11)?;

        ::fidl_next::Encode::encode(&mut self.p12, encoder, p12)?;

        ::fidl_next::Encode::encode(&mut self.p13, encoder, p13)?;

        ::fidl_next::Encode::encode(&mut self.p14, encoder, p14)?;

        ::fidl_next::Encode::encode(&mut self.p15, encoder, p15)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ManyParametersFifteenRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireManyParametersFifteenRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ManyParametersFifteenRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ManyParametersFifteenRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireManyParametersFifteenRequest> for ManyParametersFifteenRequest {
    fn take_from(from: &WireManyParametersFifteenRequest) -> Self {
        Self {
            p1: ::fidl_next::TakeFrom::take_from(&from.p1),

            p2: ::fidl_next::TakeFrom::take_from(&from.p2),

            p3: ::fidl_next::TakeFrom::take_from(&from.p3),

            p4: ::fidl_next::TakeFrom::take_from(&from.p4),

            p5: ::fidl_next::TakeFrom::take_from(&from.p5),

            p6: ::fidl_next::TakeFrom::take_from(&from.p6),

            p7: ::fidl_next::TakeFrom::take_from(&from.p7),

            p8: ::fidl_next::TakeFrom::take_from(&from.p8),

            p9: ::fidl_next::TakeFrom::take_from(&from.p9),

            p10: ::fidl_next::TakeFrom::take_from(&from.p10),

            p11: ::fidl_next::TakeFrom::take_from(&from.p11),

            p12: ::fidl_next::TakeFrom::take_from(&from.p12),

            p13: ::fidl_next::TakeFrom::take_from(&from.p13),

            p14: ::fidl_next::TakeFrom::take_from(&from.p14),

            p15: ::fidl_next::TakeFrom::take_from(&from.p15),
        }
    }
}

/// The wire type corersponding to [`ManyParametersFifteenRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireManyParametersFifteenRequest {
    pub p1: bool,

    pub p2: bool,

    pub p3: bool,

    pub p4: bool,

    pub p5: bool,

    pub p6: bool,

    pub p7: bool,

    pub p8: bool,

    pub p9: bool,

    pub p10: bool,

    pub p11: bool,

    pub p12: bool,

    pub p13: bool,

    pub p14: bool,

    pub p15: bool,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireManyParametersFifteenRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut p1,
                mut p2,
                mut p3,
                mut p4,
                mut p5,
                mut p6,
                mut p7,
                mut p8,
                mut p9,
                mut p10,
                mut p11,
                mut p12,
                mut p13,
                mut p14,
                mut p15,

            } = slot;
        }

        ::fidl_next::Decode::decode(p1.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p2.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p3.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p4.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p5.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p6.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p7.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p8.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p9.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p10.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p11.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p12.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p13.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p14.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(p15.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the ManyParameters protocol.
#[derive(Debug)]
pub struct ManyParameters;

pub mod many_parameters {

    pub struct Fifteen;

    impl ::fidl_next::bind::Method for Fifteen {
        const ORDINAL: u64 = 6423043252952467815;

        type Protocol = crate::ManyParameters;

        type Request = crate::WireManyParametersFifteenRequest;

        type Response = ::fidl_next::bind::Never;
    }
}

/// A helper trait for the `ManyParameters` client sender.
pub trait ManyParametersClientSender<___T: ::fidl_next::protocol::Transport> {
    fn fifteen<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireManyParametersFifteenRequest,
        >;
}

impl<___T> ManyParametersClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, ManyParameters>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn fifteen<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireManyParametersFifteenRequest,
        >,
    {
        self.as_untyped().send_one_way(6423043252952467815, request)
    }
}

/// A client handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for ManyParameters
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ManyParametersClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `ManyParameters` server sender.
pub trait ManyParametersServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> ManyParametersServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, ManyParameters>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the ManyParameters protocol.
///
/// See [`ManyParameters`] for more details.
pub trait ManyParametersServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn fifteen(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, ManyParameters>,

        request: ::fidl_next::bind::RequestBuffer<___T, many_parameters::Fifteen>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for ManyParameters
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: ManyParametersServerHandler<___T>,

    for<'buf> crate::WireManyParametersFifteenRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            6423043252952467815 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.fifteen(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum TheUnion {
    V(u32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for TheUnion {
    type Encoded = WireTheUnion;
}

impl<___E> ::fidl_next::Encode<___E> for TheUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireTheUnion { raw } = slot);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<TheUnion> {
    type EncodedOption = WireOptionalTheUnion;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<TheUnion>
where
    ___E: ?Sized,
    TheUnion: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalTheUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireTheUnion> for TheUnion {
    fn take_from(from: &WireTheUnion) -> Self {
        match from.raw.ordinal() {
            1 => Self::V(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalTheUnion> for Option<Box<TheUnion>> {
    fn take_from(from: &WireOptionalTheUnion) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`TheUnion`].
#[repr(transparent)]
pub struct WireTheUnion {
    raw: ::fidl_next::RawWireUnion,
}

pub mod the_union {
    pub enum Ref<'union> {
        V(&'union ::fidl_next::u32_le),

        UnknownOrdinal_(u64),
    }
}

impl WireTheUnion {
    pub fn as_ref(&self) -> crate::the_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::the_union::Ref::V(unsafe { self.raw.get().deref_unchecked() }),

            unknown => crate::the_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireTheUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalTheUnion {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalTheUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireTheUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalTheUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalTheUnion { raw: ::fidl_next::RawWireUnion::absent() };
        }

        match self.raw.ordinal() {
            1 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() } },

            _ => Self { raw: unsafe { self.raw.clone_unchecked::<()>() } },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalTheUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalTheUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct MethodWithUnionUnionMethodRequest {
    pub u: crate::TheUnion,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodRequest {
    type Encoded = WireMethodWithUnionUnionMethodRequest;
}

impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MethodWithUnionUnionMethodRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireMethodWithUnionUnionMethodRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<MethodWithUnionUnionMethodRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMethodWithUnionUnionMethodRequest>
    for MethodWithUnionUnionMethodRequest
{
    fn take_from(from: &WireMethodWithUnionUnionMethodRequest) -> Self {
        Self { u: ::fidl_next::TakeFrom::take_from(&from.u) }
    }
}

/// The wire type corersponding to [`MethodWithUnionUnionMethodRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodRequest {
    pub u: crate::WireTheUnion,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct MethodWithUnionUnionMethodResponse {
    pub u: Option<Box<crate::TheUnion>>,
}

impl ::fidl_next::Encodable for MethodWithUnionUnionMethodResponse {
    type Encoded = WireMethodWithUnionUnionMethodResponse;
}

impl<___E> ::fidl_next::Encode<___E> for MethodWithUnionUnionMethodResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                u,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.u, encoder, u)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<MethodWithUnionUnionMethodResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireMethodWithUnionUnionMethodResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<MethodWithUnionUnionMethodResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    MethodWithUnionUnionMethodResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireMethodWithUnionUnionMethodResponse>
    for MethodWithUnionUnionMethodResponse
{
    fn take_from(from: &WireMethodWithUnionUnionMethodResponse) -> Self {
        Self { u: ::fidl_next::TakeFrom::take_from(&from.u) }
    }
}

/// The wire type corersponding to [`MethodWithUnionUnionMethodResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireMethodWithUnionUnionMethodResponse {
    pub u: crate::WireOptionalTheUnion,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireMethodWithUnionUnionMethodResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut u,

            } = slot;
        }

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the MethodWithUnion protocol.
#[derive(Debug)]
pub struct MethodWithUnion;

pub mod method_with_union {

    pub struct UnionMethod;

    impl ::fidl_next::bind::Method for UnionMethod {
        const ORDINAL: u64 = 4124874338266649112;

        type Protocol = crate::MethodWithUnion;

        type Request = crate::WireMethodWithUnionUnionMethodRequest;

        type Response = crate::WireMethodWithUnionUnionMethodResponse;
    }
}

/// A helper trait for the `MethodWithUnion` client sender.
pub trait MethodWithUnionClientSender<___T: ::fidl_next::protocol::Transport> {
    fn union_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, method_with_union::UnionMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireMethodWithUnionUnionMethodRequest,
        >;
}

impl<___T> MethodWithUnionClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, MethodWithUnion>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn union_method<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, method_with_union::UnionMethod>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireMethodWithUnionUnionMethodRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(4124874338266649112, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for MethodWithUnion
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: MethodWithUnionClientHandler<___T>,

    for<'buf> crate::WireMethodWithUnionUnionMethodResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `MethodWithUnion` server sender.
pub trait MethodWithUnionServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> MethodWithUnionServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, MethodWithUnion>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the MethodWithUnion protocol.
///
/// See [`MethodWithUnion`] for more details.
pub trait MethodWithUnionServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn union_method(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, MethodWithUnion>,

        request: ::fidl_next::bind::RequestBuffer<___T, method_with_union::UnionMethod>,

        responder: ::fidl_next::bind::Responder<method_with_union::UnionMethod>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for MethodWithUnion
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: MethodWithUnionServerHandler<___T>,

    for<'buf> crate::WireMethodWithUnionUnionMethodRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            4124874338266649112 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.union_method(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// The type corresponding to the PlatformServer protocol.
#[derive(Debug)]
pub struct PlatformServer;

pub mod platform_server {}

/// A helper trait for the `PlatformServer` client sender.
pub trait PlatformServerClientSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> PlatformServerClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, PlatformServer>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A client handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for PlatformServer
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: PlatformServerClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `PlatformServer` server sender.
pub trait PlatformServerServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> PlatformServerServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, PlatformServer>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the PlatformServer protocol.
///
/// See [`PlatformServer`] for more details.
pub trait PlatformServerServerHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for PlatformServer
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: PlatformServerServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
pub struct ProtocolEnds {
    pub client:
        ::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::zx::Handle, crate::DiscoverableProtocol>,

    pub server:
        ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::zx::Handle, crate::DiscoverableProtocol>,

    pub client_opt: ::fidl_next::bind::ClientEnd<
        Option<::fidl_next::fuchsia::zx::Handle>,
        crate::DiscoverableProtocol,
    >,

    pub server_opt: ::fidl_next::bind::ServerEnd<
        Option<::fidl_next::fuchsia::zx::Handle>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for ProtocolEnds {
    type Encoded = WireProtocolEnds;
}

impl<___E> ::fidl_next::Encode<___E> for ProtocolEnds
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                client,
                server,
                client_opt,
                server_opt,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.client, encoder, client)?;

        ::fidl_next::Encode::encode(&mut self.server, encoder, server)?;

        ::fidl_next::Encode::encode(&mut self.client_opt, encoder, client_opt)?;

        ::fidl_next::Encode::encode(&mut self.server_opt, encoder, server_opt)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ProtocolEnds> {
    type EncodedOption = ::fidl_next::WireBox<WireProtocolEnds>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<ProtocolEnds>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ProtocolEnds: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireProtocolEnds> for ProtocolEnds {
    fn take_from(from: &WireProtocolEnds) -> Self {
        Self {
            client: ::fidl_next::TakeFrom::take_from(&from.client),

            server: ::fidl_next::TakeFrom::take_from(&from.server),

            client_opt: ::fidl_next::TakeFrom::take_from(&from.client_opt),

            server_opt: ::fidl_next::TakeFrom::take_from(&from.server_opt),
        }
    }
}

/// The wire type corersponding to [`ProtocolEnds`].
#[derive(Debug)]
#[repr(C)]
pub struct WireProtocolEnds {
    pub client:
        ::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::WireHandle, crate::DiscoverableProtocol>,

    pub server:
        ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireHandle, crate::DiscoverableProtocol>,

    pub client_opt: ::fidl_next::bind::ClientEnd<
        ::fidl_next::fuchsia::WireOptionalHandle,
        crate::DiscoverableProtocol,
    >,

    pub server_opt: ::fidl_next::bind::ServerEnd<
        ::fidl_next::fuchsia::WireOptionalHandle,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireProtocolEnds
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut client,
                mut server,
                mut client_opt,
                mut server_opt,

            } = slot;
        }

        ::fidl_next::Decode::decode(client.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(client_opt.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(server_opt.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct SyscallProtocolMethodCRequest {
    pub a: i64,

    pub b: i64,
}

impl ::fidl_next::Encodable for SyscallProtocolMethodCRequest {
    type Encoded = WireSyscallProtocolMethodCRequest;
}

impl<___E> ::fidl_next::Encode<___E> for SyscallProtocolMethodCRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<SyscallProtocolMethodCRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireSyscallProtocolMethodCRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<SyscallProtocolMethodCRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    SyscallProtocolMethodCRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireSyscallProtocolMethodCRequest> for SyscallProtocolMethodCRequest {
    fn take_from(from: &WireSyscallProtocolMethodCRequest) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),
        }
    }
}

/// The wire type corersponding to [`SyscallProtocolMethodCRequest`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireSyscallProtocolMethodCRequest {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireSyscallProtocolMethodCRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the SyscallProtocol protocol.
#[derive(Debug)]
pub struct SyscallProtocol;

pub mod syscall_protocol {

    pub struct MethodC;

    impl ::fidl_next::bind::Method for MethodC {
        const ORDINAL: u64 = 1468025868259603279;

        type Protocol = crate::SyscallProtocol;

        type Request = crate::WireSyscallProtocolMethodCRequest;

        type Response = ::fidl_next::bind::Never;
    }
}

/// A helper trait for the `SyscallProtocol` client sender.
pub trait SyscallProtocolClientSender<___T: ::fidl_next::protocol::Transport> {
    fn method_c<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireSyscallProtocolMethodCRequest,
        >;
}

impl<___T> SyscallProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, SyscallProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn method_c<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireSyscallProtocolMethodCRequest,
        >,
    {
        self.as_untyped().send_one_way(1468025868259603279, request)
    }
}

/// A client handler for the SyscallProtocol protocol.
///
/// See [`SyscallProtocol`] for more details.
pub trait SyscallProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for SyscallProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: SyscallProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `SyscallProtocol` server sender.
pub trait SyscallProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> SyscallProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, SyscallProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the SyscallProtocol protocol.
///
/// See [`SyscallProtocol`] for more details.
pub trait SyscallProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn method_c(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, SyscallProtocol>,

        request: ::fidl_next::bind::RequestBuffer<___T, syscall_protocol::MethodC>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for SyscallProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: SyscallProtocolServerHandler<___T>,

    for<'buf> crate::WireSyscallProtocolMethodCRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            1468025868259603279 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.method_c(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseNoRequestWithResponseResponse {
    type Encoded = WireWithAndWithoutRequestResponseNoRequestWithResponseResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseNoRequestWithResponseResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseNoRequestWithResponseResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseNoRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseNoRequestWithResponseResponse>
    for WithAndWithoutRequestResponseNoRequestWithResponseResponse
{
    fn take_from(from: &WireWithAndWithoutRequestResponseNoRequestWithResponseResponse) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseNoRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseNoRequestWithResponseResponse {
    pub ret: ::fidl_next::WireString,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseNoRequestWithResponseResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestNoResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestNoResponseRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestNoResponseRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestNoResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestNoResponseRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestNoResponseRequest>
    for WithAndWithoutRequestResponseWithRequestNoResponseRequest
{
    fn take_from(from: &WireWithAndWithoutRequestResponseWithRequestNoResponseRequest) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseWithRequestNoResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestNoResponseRequest {
    pub arg: ::fidl_next::WireString,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestNoResponseRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
}

impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
    for WithAndWithoutRequestResponseWithRequestEmptyResponseRequest
{
    fn take_from(from: &WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseWithRequestEmptyResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
    pub arg: ::fidl_next::WireString,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    pub arg: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestWithResponseRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                arg,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.arg, encoder, arg)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseRequest>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestWithResponseRequest>
    for WithAndWithoutRequestResponseWithRequestWithResponseRequest
{
    fn take_from(from: &WireWithAndWithoutRequestResponseWithRequestWithResponseRequest) -> Self {
        Self { arg: ::fidl_next::TakeFrom::take_from(&from.arg) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseWithRequestWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseRequest {
    pub arg: ::fidl_next::WireString,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut arg,

            } = slot;
        }

        ::fidl_next::Decode::decode(arg.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseWithRequestWithResponseResponse {
    type Encoded = WireWithAndWithoutRequestResponseWithRequestWithResponseResponse;
}

impl<___E> ::fidl_next::Encode<___E>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseResponse>
{
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseWithRequestWithResponseResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseWithRequestWithResponseResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseWithRequestWithResponseResponse>
    for WithAndWithoutRequestResponseWithRequestWithResponseResponse
{
    fn take_from(from: &WireWithAndWithoutRequestResponseWithRequestWithResponseResponse) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseWithRequestWithResponseResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseWithRequestWithResponseResponse {
    pub ret: ::fidl_next::WireString,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseWithRequestWithResponseResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct WithAndWithoutRequestResponseOnWithResponseRequest {
    pub ret: String,
}

impl ::fidl_next::Encodable for WithAndWithoutRequestResponseOnWithResponseRequest {
    type Encoded = WireWithAndWithoutRequestResponseOnWithResponseRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithAndWithoutRequestResponseOnWithResponseRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                ret,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.ret, encoder, ret)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithAndWithoutRequestResponseOnWithResponseRequest> {
    type EncodedOption =
        ::fidl_next::WireBox<WireWithAndWithoutRequestResponseOnWithResponseRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E>
    for Box<WithAndWithoutRequestResponseOnWithResponseRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithAndWithoutRequestResponseOnWithResponseRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithAndWithoutRequestResponseOnWithResponseRequest>
    for WithAndWithoutRequestResponseOnWithResponseRequest
{
    fn take_from(from: &WireWithAndWithoutRequestResponseOnWithResponseRequest) -> Self {
        Self { ret: ::fidl_next::TakeFrom::take_from(&from.ret) }
    }
}

/// The wire type corersponding to [`WithAndWithoutRequestResponseOnWithResponseRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithAndWithoutRequestResponseOnWithResponseRequest {
    pub ret: ::fidl_next::WireString,
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireWithAndWithoutRequestResponseOnWithResponseRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut ret,

            } = slot;
        }

        ::fidl_next::Decode::decode(ret.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithAndWithoutRequestResponse protocol.
#[derive(Debug)]
pub struct WithAndWithoutRequestResponse;

pub mod with_and_without_request_response {

    pub struct NoRequestNoResponse;

    impl ::fidl_next::bind::Method for NoRequestNoResponse {
        const ORDINAL: u64 = 5413654872775949227;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = ::fidl_next::bind::Never;
    }

    pub struct NoRequestEmptyResponse;

    impl ::fidl_next::bind::Method for NoRequestEmptyResponse {
        const ORDINAL: u64 = 1631193469798418024;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = ();
    }

    pub struct NoRequestWithResponse;

    impl ::fidl_next::bind::Method for NoRequestWithResponse {
        const ORDINAL: u64 = 9037369643591427517;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ();

        type Response = crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse;
    }

    pub struct WithRequestNoResponse;

    impl ::fidl_next::bind::Method for WithRequestNoResponse {
        const ORDINAL: u64 = 7326057319832554103;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest;

        type Response = ::fidl_next::bind::Never;
    }

    pub struct WithRequestEmptyResponse;

    impl ::fidl_next::bind::Method for WithRequestEmptyResponse {
        const ORDINAL: u64 = 2877322062572412767;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

        type Response = ();
    }

    pub struct WithRequestWithResponse;

    impl ::fidl_next::bind::Method for WithRequestWithResponse {
        const ORDINAL: u64 = 6417226585456833969;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest;

        type Response = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse;
    }

    pub struct OnEmptyResponse;

    impl ::fidl_next::bind::Method for OnEmptyResponse {
        const ORDINAL: u64 = 5397663296507358806;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ::fidl_next::bind::Never;

        type Response = ();
    }

    pub struct OnWithResponse;

    impl ::fidl_next::bind::Method for OnWithResponse {
        const ORDINAL: u64 = 5811598563493228968;

        type Protocol = crate::WithAndWithoutRequestResponse;

        type Request = ::fidl_next::bind::Never;

        type Response = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest;
    }
}

/// A helper trait for the `WithAndWithoutRequestResponse` client sender.
pub trait WithAndWithoutRequestResponseClientSender<___T: ::fidl_next::protocol::Transport> {
    fn no_request_no_response(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn no_request_empty_response(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >;

    fn no_request_with_response(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::NoRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >;

    fn with_request_no_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest,
        >;

    fn with_request_empty_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
        >;

    fn with_request_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::WithRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest,
        >;
}

impl<___T> WithAndWithoutRequestResponseClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, WithAndWithoutRequestResponse>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn no_request_no_response(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_one_way(5413654872775949227, &mut ())
    }

    fn no_request_empty_response(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1631193469798418024, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn no_request_with_response(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::NoRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(9037369643591427517, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn with_request_no_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest,
        >,
    {
        self.as_untyped().send_one_way(7326057319832554103, request)
    }

    fn with_request_empty_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(2877322062572412767, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn with_request_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<
            '_,
            ___T,
            with_and_without_request_response::WithRequestWithResponse,
        >,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(6417226585456833969, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseClientHandler<___T: ::fidl_next::protocol::Transport> {
    fn on_empty_response(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, WithAndWithoutRequestResponse>,
    );

    fn on_with_response(
        &mut self,
        sender: &::fidl_next::bind::ClientSender<___T, WithAndWithoutRequestResponse>,

        message: ::fidl_next::bind::ResponseBuffer<
            ___T,
            with_and_without_request_response::OnWithResponse,
        >,
    );
}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for WithAndWithoutRequestResponse
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithAndWithoutRequestResponseClientHandler<___T>,

    for<'buf> crate::WireWithAndWithoutRequestResponseNoRequestWithResponseResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithAndWithoutRequestResponseWithRequestWithResponseResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithAndWithoutRequestResponseOnWithResponseRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5397663296507358806 => {
                handler.on_empty_response(sender);
            }

            5811598563493228968 => {
                let buffer = ::fidl_next::bind::ResponseBuffer::from_untyped(buffer);
                handler.on_with_response(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithAndWithoutRequestResponse` server sender.
pub trait WithAndWithoutRequestResponseServerSender<___T: ::fidl_next::protocol::Transport> {
    fn on_empty_response(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>;

    fn on_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest,
        >;
}

impl<___T> WithAndWithoutRequestResponseServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn on_empty_response(&self) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError> {
        self.as_untyped().send_event(5397663296507358806, &mut ())
    }

    fn on_with_response<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<___T::SendFuture<'_>, ::fidl_next::EncodeError>
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithAndWithoutRequestResponseOnWithResponseRequest,
        >,
    {
        self.as_untyped().send_event(5811598563493228968, request)
    }
}

/// A server handler for the WithAndWithoutRequestResponse protocol.
///
/// See [`WithAndWithoutRequestResponse`] for more details.
pub trait WithAndWithoutRequestResponseServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn no_request_no_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,
    );

    fn no_request_empty_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        responder: ::fidl_next::bind::Responder<
            with_and_without_request_response::NoRequestEmptyResponse,
        >,
    );

    fn no_request_with_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        responder: ::fidl_next::bind::Responder<
            with_and_without_request_response::NoRequestWithResponse,
        >,
    );

    fn with_request_no_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::bind::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestNoResponse,
        >,
    );

    fn with_request_empty_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::bind::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestEmptyResponse,
        >,

        responder: ::fidl_next::bind::Responder<
            with_and_without_request_response::WithRequestEmptyResponse,
        >,
    );

    fn with_request_with_response(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithAndWithoutRequestResponse>,

        request: ::fidl_next::bind::RequestBuffer<
            ___T,
            with_and_without_request_response::WithRequestWithResponse,
        >,

        responder: ::fidl_next::bind::Responder<
            with_and_without_request_response::WithRequestWithResponse,
        >,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for WithAndWithoutRequestResponse
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithAndWithoutRequestResponseServerHandler<___T>,

    for<'buf> crate::WireWithAndWithoutRequestResponseWithRequestNoResponseRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithAndWithoutRequestResponseWithRequestEmptyResponseRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithAndWithoutRequestResponseWithRequestWithResponseRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            5413654872775949227 => {
                handler.no_request_no_response(sender);
            }

            7326057319832554103 => {
                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.with_request_no_response(sender, buffer);
            }

            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            1631193469798418024 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.no_request_empty_response(sender, responder);
            }

            9037369643591427517 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.no_request_with_response(sender, responder);
            }

            2877322062572412767 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.with_request_empty_response(sender, buffer, responder);
            }

            6417226585456833969 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.with_request_with_response(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub struct WithErrorSyntaxResponseAsStructResponse {
    pub a: i64,

    pub b: i64,

    pub c: i64,
}

impl ::fidl_next::Encodable for WithErrorSyntaxResponseAsStructResponse {
    type Encoded = WireWithErrorSyntaxResponseAsStructResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxResponseAsStructResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                b,
                c,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.a, encoder, a)?;

        ::fidl_next::Encode::encode(&mut self.b, encoder, b)?;

        ::fidl_next::Encode::encode(&mut self.c, encoder, c)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxResponseAsStructResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithErrorSyntaxResponseAsStructResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxResponseAsStructResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxResponseAsStructResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxResponseAsStructResponse>
    for WithErrorSyntaxResponseAsStructResponse
{
    fn take_from(from: &WireWithErrorSyntaxResponseAsStructResponse) -> Self {
        Self {
            a: ::fidl_next::TakeFrom::take_from(&from.a),

            b: ::fidl_next::TakeFrom::take_from(&from.b),

            c: ::fidl_next::TakeFrom::take_from(&from.c),
        }
    }
}

/// The wire type corersponding to [`WithErrorSyntaxResponseAsStructResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxResponseAsStructResponse {
    pub a: ::fidl_next::i64_le,

    pub b: ::fidl_next::i64_le,

    pub c: ::fidl_next::i64_le,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxResponseAsStructResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut b,
                mut c,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(c.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum WithErrorSyntaxResponseAsStructResult {
    Response(crate::WithErrorSyntaxResponseAsStructResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for WithErrorSyntaxResponseAsStructResult {
    type Encoded = WireWithErrorSyntaxResponseAsStructResult;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxResponseAsStructResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireWithErrorSyntaxResponseAsStructResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as::<
                ___E,
                crate::WithErrorSyntaxResponseAsStructResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxResponseAsStructResult> {
    type EncodedOption = WireOptionalWithErrorSyntaxResponseAsStructResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxResponseAsStructResult>
where
    ___E: ?Sized,
    WithErrorSyntaxResponseAsStructResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalWithErrorSyntaxResponseAsStructResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxResponseAsStructResult>
    for WithErrorSyntaxResponseAsStructResult
{
    fn take_from(from: &WireWithErrorSyntaxResponseAsStructResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalWithErrorSyntaxResponseAsStructResult>
    for Option<Box<WithErrorSyntaxResponseAsStructResult>>
{
    fn take_from(from: &WireOptionalWithErrorSyntaxResponseAsStructResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxResponseAsStructResult`].
#[repr(transparent)]
pub struct WireWithErrorSyntaxResponseAsStructResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod with_error_syntax_response_as_struct_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireWithErrorSyntaxResponseAsStructResponse),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireWithErrorSyntaxResponseAsStructResult {
    pub fn as_ref(&self) -> crate::with_error_syntax_response_as_struct_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_response_as_struct_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::with_error_syntax_response_as_struct_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxResponseAsStructResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireWithErrorSyntaxResponseAsStructResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireWithErrorSyntaxResponseAsStructResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireWithErrorSyntaxResponseAsStructResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalWithErrorSyntaxResponseAsStructResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalWithErrorSyntaxResponseAsStructResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireWithErrorSyntaxResponseAsStructResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<'buf, ___D> ::fidl_next::Decode<___D>
    for WireOptionalWithErrorSyntaxResponseAsStructResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                crate::WireWithErrorSyntaxResponseAsStructResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::u32_le>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalWithErrorSyntaxResponseAsStructResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct WithErrorSyntaxErrorAsPrimitiveResponse {}

impl ::fidl_next::Encodable for WithErrorSyntaxErrorAsPrimitiveResponse {
    type Encoded = WireWithErrorSyntaxErrorAsPrimitiveResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxErrorAsPrimitiveResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxErrorAsPrimitiveResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithErrorSyntaxErrorAsPrimitiveResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxErrorAsPrimitiveResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxErrorAsPrimitiveResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxErrorAsPrimitiveResponse>
    for WithErrorSyntaxErrorAsPrimitiveResponse
{
    fn take_from(from: &WireWithErrorSyntaxErrorAsPrimitiveResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`WithErrorSyntaxErrorAsPrimitiveResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxErrorAsPrimitiveResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxErrorAsPrimitiveResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum WithErrorSyntaxErrorAsPrimitiveResult {
    Response(crate::WithErrorSyntaxErrorAsPrimitiveResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for WithErrorSyntaxErrorAsPrimitiveResult {
    type Encoded = WireWithErrorSyntaxErrorAsPrimitiveResult;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxErrorAsPrimitiveResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireWithErrorSyntaxErrorAsPrimitiveResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::WithErrorSyntaxErrorAsPrimitiveResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxErrorAsPrimitiveResult> {
    type EncodedOption = WireOptionalWithErrorSyntaxErrorAsPrimitiveResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxErrorAsPrimitiveResult>
where
    ___E: ?Sized,
    WithErrorSyntaxErrorAsPrimitiveResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalWithErrorSyntaxErrorAsPrimitiveResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxErrorAsPrimitiveResult>
    for WithErrorSyntaxErrorAsPrimitiveResult
{
    fn take_from(from: &WireWithErrorSyntaxErrorAsPrimitiveResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalWithErrorSyntaxErrorAsPrimitiveResult>
    for Option<Box<WithErrorSyntaxErrorAsPrimitiveResult>>
{
    fn take_from(from: &WireOptionalWithErrorSyntaxErrorAsPrimitiveResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxErrorAsPrimitiveResult`].
#[repr(transparent)]
pub struct WireWithErrorSyntaxErrorAsPrimitiveResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod with_error_syntax_error_as_primitive_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireWithErrorSyntaxErrorAsPrimitiveResponse),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireWithErrorSyntaxErrorAsPrimitiveResult {
    pub fn as_ref(&self) -> crate::with_error_syntax_error_as_primitive_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_error_as_primitive_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::with_error_syntax_error_as_primitive_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireWithErrorSyntaxErrorAsPrimitiveResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireWithErrorSyntaxErrorAsPrimitiveResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxErrorAsPrimitiveResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxErrorAsPrimitiveResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireWithErrorSyntaxErrorAsPrimitiveResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireWithErrorSyntaxErrorAsPrimitiveResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireWithErrorSyntaxErrorAsPrimitiveResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireWithErrorSyntaxErrorAsPrimitiveResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<::fidl_next::u32_le>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalWithErrorSyntaxErrorAsPrimitiveResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxErrorAsPrimitiveResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalWithErrorSyntaxErrorAsPrimitiveResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct WithErrorSyntaxErrorAsEnumResponse {}

impl ::fidl_next::Encodable for WithErrorSyntaxErrorAsEnumResponse {
    type Encoded = WireWithErrorSyntaxErrorAsEnumResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxErrorAsEnumResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = slot;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxErrorAsEnumResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithErrorSyntaxErrorAsEnumResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxErrorAsEnumResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxErrorAsEnumResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxErrorAsEnumResponse>
    for WithErrorSyntaxErrorAsEnumResponse
{
    fn take_from(from: &WireWithErrorSyntaxErrorAsEnumResponse) -> Self {
        Self {}
    }
}

/// The wire type corersponding to [`WithErrorSyntaxErrorAsEnumResponse`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxErrorAsEnumResponse {}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxErrorAsEnumResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum WithErrorSyntaxErrorAsEnumResult {
    Response(crate::WithErrorSyntaxErrorAsEnumResponse),

    Err(crate::ErrorEnum),
}

impl ::fidl_next::Encodable for WithErrorSyntaxErrorAsEnumResult {
    type Encoded = WireWithErrorSyntaxErrorAsEnumResult;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxErrorAsEnumResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireWithErrorSyntaxErrorAsEnumResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::WithErrorSyntaxErrorAsEnumResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::ErrorEnum,
            >(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxErrorAsEnumResult> {
    type EncodedOption = WireOptionalWithErrorSyntaxErrorAsEnumResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxErrorAsEnumResult>
where
    ___E: ?Sized,
    WithErrorSyntaxErrorAsEnumResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalWithErrorSyntaxErrorAsEnumResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxErrorAsEnumResult>
    for WithErrorSyntaxErrorAsEnumResult
{
    fn take_from(from: &WireWithErrorSyntaxErrorAsEnumResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalWithErrorSyntaxErrorAsEnumResult>
    for Option<Box<WithErrorSyntaxErrorAsEnumResult>>
{
    fn take_from(from: &WireOptionalWithErrorSyntaxErrorAsEnumResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxErrorAsEnumResult`].
#[repr(transparent)]
pub struct WireWithErrorSyntaxErrorAsEnumResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod with_error_syntax_error_as_enum_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireWithErrorSyntaxErrorAsEnumResponse),

        Err(&'union crate::WireErrorEnum),
    }
}

impl WireWithErrorSyntaxErrorAsEnumResult {
    pub fn as_ref(&self) -> crate::with_error_syntax_error_as_enum_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_error_as_enum_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::with_error_syntax_error_as_enum_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireWithErrorSyntaxErrorAsEnumResult {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireWithErrorSyntaxErrorAsEnumResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<crate::WireErrorEnum>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxErrorAsEnumResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxErrorAsEnumResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireErrorEnum>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireWithErrorSyntaxErrorAsEnumResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireWithErrorSyntaxErrorAsEnumResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WireErrorEnum>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalWithErrorSyntaxErrorAsEnumResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalWithErrorSyntaxErrorAsEnumResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireWithErrorSyntaxErrorAsEnumResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalWithErrorSyntaxErrorAsEnumResult {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalWithErrorSyntaxErrorAsEnumResult {
                raw: ::fidl_next::RawWireUnion::absent(),
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe {
                    self.raw.clone_unchecked::<crate::WireWithErrorSyntaxErrorAsEnumResponse>()
                },
            },

            2 => Self { raw: unsafe { self.raw.clone_unchecked::<crate::WireErrorEnum>() } },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalWithErrorSyntaxErrorAsEnumResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxErrorAsEnumResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireErrorEnum>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalWithErrorSyntaxErrorAsEnumResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Debug)]
pub struct WithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::fuchsia::zx::Handle,
}

impl ::fidl_next::Encodable for WithErrorSyntaxHandleInResultResponse {
    type Encoded = WireWithErrorSyntaxHandleInResultResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxHandleInResultResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                h,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.h, encoder, h)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxHandleInResultResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithErrorSyntaxHandleInResultResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxHandleInResultResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithErrorSyntaxHandleInResultResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxHandleInResultResponse>
    for WithErrorSyntaxHandleInResultResponse
{
    fn take_from(from: &WireWithErrorSyntaxHandleInResultResponse) -> Self {
        Self { h: ::fidl_next::TakeFrom::take_from(&from.h) }
    }
}

/// The wire type corersponding to [`WithErrorSyntaxHandleInResultResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithErrorSyntaxHandleInResultResponse {
    pub h: ::fidl_next::fuchsia::WireHandle,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxHandleInResultResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut h,

            } = slot;
        }

        ::fidl_next::Decode::decode(h.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub enum WithErrorSyntaxHandleInResultResult {
    Response(crate::WithErrorSyntaxHandleInResultResponse),

    Err(u32),
}

impl ::fidl_next::Encodable for WithErrorSyntaxHandleInResultResult {
    type Encoded = WireWithErrorSyntaxHandleInResultResult;
}

impl<___E> ::fidl_next::Encode<___E> for WithErrorSyntaxHandleInResultResult
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireWithErrorSyntaxHandleInResultResult { raw } = slot);

        match self {
            Self::Response(value) => ::fidl_next::RawWireUnion::encode_as_static::<
                ___E,
                crate::WithErrorSyntaxHandleInResultResponse,
            >(value, 1, encoder, raw)?,

            Self::Err(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithErrorSyntaxHandleInResultResult> {
    type EncodedOption = WireOptionalWithErrorSyntaxHandleInResultResult;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithErrorSyntaxHandleInResultResult>
where
    ___E: ?Sized,
    WithErrorSyntaxHandleInResultResult: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalWithErrorSyntaxHandleInResultResult { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl_next::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl_next::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithErrorSyntaxHandleInResultResult>
    for WithErrorSyntaxHandleInResultResult
{
    fn take_from(from: &WireWithErrorSyntaxHandleInResultResult) -> Self {
        match from.raw.ordinal() {
            1 => Self::Response(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            2 => Self::Err(::fidl_next::TakeFrom::take_from(unsafe {
                from.raw.get().deref_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireOptionalWithErrorSyntaxHandleInResultResult>
    for Option<Box<WithErrorSyntaxHandleInResultResult>>
{
    fn take_from(from: &WireOptionalWithErrorSyntaxHandleInResultResult) -> Self {
        if let Some(inner) = from.as_ref() {
            Some(::fidl_next::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`WithErrorSyntaxHandleInResultResult`].
#[repr(transparent)]
pub struct WireWithErrorSyntaxHandleInResultResult {
    raw: ::fidl_next::RawWireUnion,
}

pub mod with_error_syntax_handle_in_result_result {
    pub enum Ref<'union> {
        Response(&'union crate::WireWithErrorSyntaxHandleInResultResponse),

        Err(&'union ::fidl_next::u32_le),
    }
}

impl WireWithErrorSyntaxHandleInResultResult {
    pub fn as_ref(&self) -> crate::with_error_syntax_handle_in_result_result::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::with_error_syntax_handle_in_result_result::Ref::Response(unsafe {
                self.raw.get().deref_unchecked()
            }),

            2 => crate::with_error_syntax_handle_in_result_result::Ref::Err(unsafe {
                self.raw.get().deref_unchecked()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithErrorSyntaxHandleInResultResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxHandleInResultResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireWithErrorSyntaxHandleInResultResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<crate::WireWithErrorSyntaxHandleInResultResponse>()
                    .fmt(f)
            },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::u32_le>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalWithErrorSyntaxHandleInResultResult {
    raw: ::fidl_next::RawWireUnion,
}

impl WireOptionalWithErrorSyntaxHandleInResultResult {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireWithErrorSyntaxHandleInResultResult> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalWithErrorSyntaxHandleInResultResult
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<
                ___D,
                crate::WireWithErrorSyntaxHandleInResultResponse,
            >(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::u32_le>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalWithErrorSyntaxHandleInResultResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// The type corresponding to the WithErrorSyntax protocol.
#[derive(Debug)]
pub struct WithErrorSyntax;

pub mod with_error_syntax {

    pub struct ResponseAsStruct;

    impl ::fidl_next::bind::Method for ResponseAsStruct {
        const ORDINAL: u64 = 268248568430741139;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = crate::WireWithErrorSyntaxResponseAsStructResult;
    }

    pub struct ErrorAsPrimitive;

    impl ::fidl_next::bind::Method for ErrorAsPrimitive {
        const ORDINAL: u64 = 6930994461233198567;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = crate::WireWithErrorSyntaxErrorAsPrimitiveResult;
    }

    pub struct ErrorAsEnum;

    impl ::fidl_next::bind::Method for ErrorAsEnum {
        const ORDINAL: u64 = 5491891352371277635;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = crate::WireWithErrorSyntaxErrorAsEnumResult;
    }

    pub struct HandleInResult;

    impl ::fidl_next::bind::Method for HandleInResult {
        const ORDINAL: u64 = 1371676333068455103;

        type Protocol = crate::WithErrorSyntax;

        type Request = ();

        type Response = crate::WireWithErrorSyntaxHandleInResultResult;
    }
}

/// A helper trait for the `WithErrorSyntax` client sender.
pub trait WithErrorSyntaxClientSender<___T: ::fidl_next::protocol::Transport> {
    fn response_as_struct(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ResponseAsStruct>,
        ::fidl_next::EncodeError,
    >;

    fn error_as_primitive(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ErrorAsPrimitive>,
        ::fidl_next::EncodeError,
    >;

    fn error_as_enum(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ErrorAsEnum>,
        ::fidl_next::EncodeError,
    >;

    fn handle_in_result(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::HandleInResult>,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> WithErrorSyntaxClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, WithErrorSyntax>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn response_as_struct(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ResponseAsStruct>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(268248568430741139, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_as_primitive(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ErrorAsPrimitive>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6930994461233198567, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn error_as_enum(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::ErrorAsEnum>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(5491891352371277635, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn handle_in_result(
        &self,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_error_syntax::HandleInResult>,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(1371676333068455103, &mut ())
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for WithErrorSyntax
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithErrorSyntaxClientHandler<___T>,

    for<'buf> crate::WireWithErrorSyntaxResponseAsStructResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithErrorSyntaxErrorAsPrimitiveResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithErrorSyntaxErrorAsEnumResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithErrorSyntaxHandleInResultResult:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithErrorSyntax` server sender.
pub trait WithErrorSyntaxServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> WithErrorSyntaxServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, WithErrorSyntax>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the WithErrorSyntax protocol.
///
/// See [`WithErrorSyntax`] for more details.
pub trait WithErrorSyntaxServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn response_as_struct(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::bind::Responder<with_error_syntax::ResponseAsStruct>,
    );

    fn error_as_primitive(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::bind::Responder<with_error_syntax::ErrorAsPrimitive>,
    );

    fn error_as_enum(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::bind::Responder<with_error_syntax::ErrorAsEnum>,
    );

    fn handle_in_result(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithErrorSyntax>,

        responder: ::fidl_next::bind::Responder<with_error_syntax::HandleInResult>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for WithErrorSyntax
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithErrorSyntaxServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            268248568430741139 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.response_as_struct(sender, responder);
            }

            6930994461233198567 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_as_primitive(sender, responder);
            }

            5491891352371277635 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.error_as_enum(sender, responder);
            }

            1371676333068455103 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                handler.handle_in_result(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsClientEndsRequest {
    pub in_:
        ::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::zx::Handle, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsRequest {
    type Encoded = WireWithProtocolEndsClientEndsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsClientEndsRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsClientEndsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsClientEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsClientEndsRequest>
    for WithProtocolEndsClientEndsRequest
{
    fn take_from(from: &WireWithProtocolEndsClientEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsClientEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsRequest {
    pub in_:
        ::fidl_next::bind::ClientEnd<::fidl_next::fuchsia::WireHandle, crate::DiscoverableProtocol>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsClientEndsResponse {
    pub out: ::fidl_next::bind::ClientEnd<
        Option<::fidl_next::fuchsia::zx::Handle>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for WithProtocolEndsClientEndsResponse {
    type Encoded = WireWithProtocolEndsClientEndsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsClientEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsClientEndsResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsClientEndsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsClientEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsClientEndsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsClientEndsResponse>
    for WithProtocolEndsClientEndsResponse
{
    fn take_from(from: &WireWithProtocolEndsClientEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsClientEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsClientEndsResponse {
    pub out: ::fidl_next::bind::ClientEnd<
        ::fidl_next::fuchsia::WireOptionalHandle,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsClientEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsServerEndsRequest {
    pub in_: ::fidl_next::bind::ServerEnd<
        Option<::fidl_next::fuchsia::zx::Handle>,
        crate::DiscoverableProtocol,
    >,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsRequest {
    type Encoded = WireWithProtocolEndsServerEndsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsServerEndsRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsServerEndsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsServerEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsServerEndsRequest>
    for WithProtocolEndsServerEndsRequest
{
    fn take_from(from: &WireWithProtocolEndsServerEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsServerEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsRequest {
    pub in_: ::fidl_next::bind::ServerEnd<
        ::fidl_next::fuchsia::WireOptionalHandle,
        crate::DiscoverableProtocol,
    >,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsServerEndsResponse {
    pub out:
        ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::zx::Handle, crate::DiscoverableProtocol>,
}

impl ::fidl_next::Encodable for WithProtocolEndsServerEndsResponse {
    type Encoded = WireWithProtocolEndsServerEndsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsServerEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsServerEndsResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsServerEndsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsServerEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsServerEndsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsServerEndsResponse>
    for WithProtocolEndsServerEndsResponse
{
    fn take_from(from: &WireWithProtocolEndsServerEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsServerEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsServerEndsResponse {
    pub out:
        ::fidl_next::bind::ServerEnd<::fidl_next::fuchsia::WireHandle, crate::DiscoverableProtocol>,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsServerEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsRequest {
    type Encoded = WireWithProtocolEndsStructContainingEndsRequest;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsRequest
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                in_,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.in_, encoder, in_)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsStructContainingEndsRequest> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsStructContainingEndsRequest>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsStructContainingEndsRequest>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsRequest: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsStructContainingEndsRequest>
    for WithProtocolEndsStructContainingEndsRequest
{
    fn take_from(from: &WireWithProtocolEndsStructContainingEndsRequest) -> Self {
        Self { in_: ::fidl_next::TakeFrom::take_from(&from.in_) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsStructContainingEndsRequest`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsRequest {
    pub in_: crate::WireProtocolEnds,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsRequest
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut in_,

            } = slot;
        }

        ::fidl_next::Decode::decode(in_.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Debug)]
pub struct WithProtocolEndsStructContainingEndsResponse {
    pub out: crate::ProtocolEnds,
}

impl ::fidl_next::Encodable for WithProtocolEndsStructContainingEndsResponse {
    type Encoded = WireWithProtocolEndsStructContainingEndsResponse;
}

impl<___E> ::fidl_next::Encode<___E> for WithProtocolEndsStructContainingEndsResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                out,

            } = slot;
        }

        ::fidl_next::Encode::encode(&mut self.out, encoder, out)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<WithProtocolEndsStructContainingEndsResponse> {
    type EncodedOption = ::fidl_next::WireBox<WireWithProtocolEndsStructContainingEndsResponse>;
}

impl<___E> ::fidl_next::EncodeOption<___E> for Box<WithProtocolEndsStructContainingEndsResponse>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    WithProtocolEndsStructContainingEndsResponse: ::fidl_next::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(slot);
        } else {
            ::fidl_next::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireWithProtocolEndsStructContainingEndsResponse>
    for WithProtocolEndsStructContainingEndsResponse
{
    fn take_from(from: &WireWithProtocolEndsStructContainingEndsResponse) -> Self {
        Self { out: ::fidl_next::TakeFrom::take_from(&from.out) }
    }
}

/// The wire type corersponding to [`WithProtocolEndsStructContainingEndsResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireWithProtocolEndsStructContainingEndsResponse {
    pub out: crate::WireProtocolEnds,
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireWithProtocolEndsStructContainingEndsResponse
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut out,

            } = slot;
        }

        ::fidl_next::Decode::decode(out.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the WithProtocolEnds protocol.
#[derive(Debug)]
pub struct WithProtocolEnds;

pub mod with_protocol_ends {

    pub struct ClientEnds;

    impl ::fidl_next::bind::Method for ClientEnds {
        const ORDINAL: u64 = 5870448041025163330;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsClientEndsRequest;

        type Response = crate::WireWithProtocolEndsClientEndsResponse;
    }

    pub struct ServerEnds;

    impl ::fidl_next::bind::Method for ServerEnds {
        const ORDINAL: u64 = 8115535094437022259;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsServerEndsRequest;

        type Response = crate::WireWithProtocolEndsServerEndsResponse;
    }

    pub struct StructContainingEnds;

    impl ::fidl_next::bind::Method for StructContainingEnds {
        const ORDINAL: u64 = 4076866772260025813;

        type Protocol = crate::WithProtocolEnds;

        type Request = crate::WireWithProtocolEndsStructContainingEndsRequest;

        type Response = crate::WireWithProtocolEndsStructContainingEndsResponse;
    }
}

/// A helper trait for the `WithProtocolEnds` client sender.
pub trait WithProtocolEndsClientSender<___T: ::fidl_next::protocol::Transport> {
    fn client_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::ClientEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithProtocolEndsClientEndsRequest,
        >;

    fn server_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::ServerEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithProtocolEndsServerEndsRequest,
        >;

    fn struct_containing_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::StructContainingEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithProtocolEndsStructContainingEndsRequest,
        >;
}

impl<___T> WithProtocolEndsClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, WithProtocolEnds>
where
    ___T: ::fidl_next::protocol::Transport,
{
    fn client_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::ClientEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithProtocolEndsClientEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(5870448041025163330, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn server_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::ServerEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithProtocolEndsServerEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(8115535094437022259, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }

    fn struct_containing_ends<___R>(
        &self,
        request: &mut ___R,
    ) -> Result<
        ::fidl_next::bind::ResponseFuture<'_, ___T, with_protocol_ends::StructContainingEnds>,
        ::fidl_next::EncodeError,
    >
    where
        for<'buf> ___R: ::fidl_next::Encode<
            ___T::SendBuffer,
            Encoded = crate::WireWithProtocolEndsStructContainingEndsRequest,
        >,
    {
        self.as_untyped()
            .send_two_way(4076866772260025813, request)
            .map(::fidl_next::bind::ResponseFuture::from_untyped)
    }
}

/// A client handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for WithProtocolEnds
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithProtocolEndsClientHandler<___T>,

    for<'buf> crate::WireWithProtocolEndsClientEndsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithProtocolEndsServerEndsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithProtocolEndsStructContainingEndsResponse:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `WithProtocolEnds` server sender.
pub trait WithProtocolEndsServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> WithProtocolEndsServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, WithProtocolEnds>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the WithProtocolEnds protocol.
///
/// See [`WithProtocolEnds`] for more details.
pub trait WithProtocolEndsServerHandler<___T: ::fidl_next::protocol::Transport> {
    fn client_ends(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::bind::RequestBuffer<___T, with_protocol_ends::ClientEnds>,

        responder: ::fidl_next::bind::Responder<with_protocol_ends::ClientEnds>,
    );

    fn server_ends(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::bind::RequestBuffer<___T, with_protocol_ends::ServerEnds>,

        responder: ::fidl_next::bind::Responder<with_protocol_ends::ServerEnds>,
    );

    fn struct_containing_ends(
        &mut self,
        sender: &::fidl_next::bind::ServerSender<___T, WithProtocolEnds>,

        request: ::fidl_next::bind::RequestBuffer<___T, with_protocol_ends::StructContainingEnds>,

        responder: ::fidl_next::bind::Responder<with_protocol_ends::StructContainingEnds>,
    );
}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for WithProtocolEnds
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: WithProtocolEndsServerHandler<___T>,

    for<'buf> crate::WireWithProtocolEndsClientEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithProtocolEndsServerEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,

    for<'buf> crate::WireWithProtocolEndsStructContainingEndsRequest:
        ::fidl_next::Decode<<___T as ::fidl_next::protocol::Transport>::RecvBuffer>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            5870448041025163330 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.client_ends(sender, buffer, responder);
            }

            8115535094437022259 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.server_ends(sender, buffer, responder);
            }

            4076866772260025813 => {
                let responder = ::fidl_next::bind::Responder::from_untyped(responder);

                let buffer = ::fidl_next::bind::RequestBuffer::from_untyped(buffer);
                handler.struct_containing_ends(sender, buffer, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}
