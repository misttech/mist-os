// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

pub type U32 = u32;

/// The wire type corresponding to [`U32`].
pub type WireU32 = ::fidl_next::WireU32;

pub type VecOfStrings = Vec<String>;

/// The wire type corresponding to [`VecOfStrings`].
pub type WireVecOfStrings = ::fidl_next::WireVector<::fidl_next::WireString>;

pub type VecOfStringsAtMost5 = Vec<String>;

/// The wire type corresponding to [`VecOfStringsAtMost5`].
pub type WireVecOfStringsAtMost5 = ::fidl_next::WireVector<::fidl_next::WireString>;

pub type ReferenceMe = ::fidl_next_test_someotherlibrary::ReferenceMe;

/// The wire type corresponding to [`ReferenceMe`].
pub type WireReferenceMe = ::fidl_next_test_someotherlibrary::WireReferenceMe;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum ObjType {
    None = 0,
    Channel = 4,
}

impl ::fidl_next::Encodable for ObjType {
    type Encoded = WireObjType;
}
impl ::std::convert::TryFrom<u32> for ObjType {
    type Error = ::fidl_next::UnknownStrictEnumMemberError;
    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(Self::None),
            4 => Ok(Self::Channel),

            _ => Err(Self::Error::new(value.into())),
        }
    }
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ObjType
where
    ___E: ?Sized,
{
    #[inline]
    fn encode(
        &mut self,
        _: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireObjType { value } = out);
        let _ = value.write(::fidl_next::WireU32::from(match *self {
            Self::None => 0,

            Self::Channel => 4,
        }));

        Ok(())
    }
}

impl ::core::convert::From<WireObjType> for ObjType {
    fn from(wire: WireObjType) -> Self {
        match u32::from(wire.value) {
            0 => Self::None,

            4 => Self::Channel,

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::TakeFrom<WireObjType> for ObjType {
    #[inline]
    fn take_from(from: &WireObjType) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`ObjType`].
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct WireObjType {
    value: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::ZeroPadding for WireObjType {
    #[inline]
    fn zero_padding(_: &mut ::core::mem::MaybeUninit<Self>) {
        // Wire enums have no padding
    }
}

impl WireObjType {
    pub const NONE: WireObjType = WireObjType { value: ::fidl_next::WireU32(0) };

    pub const CHANNEL: WireObjType = WireObjType { value: ::fidl_next::WireU32(4) };
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireObjType
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { value } = slot);

        match u32::from(*value) {
            0 | 4 => (),
            unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(unknown as i128)),
        }

        Ok(())
    }
}

impl ::core::convert::From<ObjType> for WireObjType {
    fn from(natural: ObjType) -> Self {
        match natural {
            ObjType::None => WireObjType::NONE,

            ObjType::Channel => WireObjType::CHANNEL,
        }
    }
}

pub type Channel = ::fidl_next::fuchsia::zx::Handle;

/// The wire type corresponding to [`Channel`].
pub type WireChannel = ::fidl_next::fuchsia::WireHandle;

pub type AliasOfChannel = ::fidl_next::fuchsia::zx::Handle;

/// The wire type corresponding to [`AliasOfChannel`].
pub type WireAliasOfChannel = ::fidl_next::fuchsia::WireHandle;

#[derive(Debug)]
pub struct ExampleOfUseOfAliases {
    pub field_of_u32: u32,

    pub field_of_vec_of_strings: Vec<String>,

    pub field_of_vec_of_strings_at_most_nine: Vec<String>,

    pub field_of_vec_of_strings_at_most_5: Vec<String>,

    pub field_of_vec_of_ref_me_at_most_5: Vec<::fidl_next_test_someotherlibrary::ReferenceMe>,

    pub field_of_channel: ::fidl_next::fuchsia::zx::Handle,

    pub field_of_client_end: ::fidl_next::fuchsia::zx::Handle,

    pub field_of_nullable_client_end: Option<::fidl_next::fuchsia::zx::Handle>,
}

impl ::fidl_next::Encodable for ExampleOfUseOfAliases {
    type Encoded = WireExampleOfUseOfAliases;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ExampleOfUseOfAliases
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,

    ___E: ::fidl_next::fuchsia::HandleEncoder,
{
    #[inline]
    fn encode(
        &mut self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                field_of_u32,
                field_of_vec_of_strings,
                field_of_vec_of_strings_at_most_nine,
                field_of_vec_of_strings_at_most_5,
                field_of_vec_of_ref_me_at_most_5,
                field_of_channel,
                field_of_client_end,
                field_of_nullable_client_end,

            } = out;
        }

        ::fidl_next::Encode::encode(&mut self.field_of_u32, encoder, field_of_u32)?;

        ::fidl_next::Encode::encode(
            &mut self.field_of_vec_of_strings,
            encoder,
            field_of_vec_of_strings,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.field_of_vec_of_strings_at_most_nine,
            encoder,
            field_of_vec_of_strings_at_most_nine,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.field_of_vec_of_strings_at_most_5,
            encoder,
            field_of_vec_of_strings_at_most_5,
        )?;

        ::fidl_next::Encode::encode(
            &mut self.field_of_vec_of_ref_me_at_most_5,
            encoder,
            field_of_vec_of_ref_me_at_most_5,
        )?;

        ::fidl_next::Encode::encode(&mut self.field_of_channel, encoder, field_of_channel)?;

        ::fidl_next::Encode::encode(&mut self.field_of_client_end, encoder, field_of_client_end)?;

        ::fidl_next::Encode::encode(
            &mut self.field_of_nullable_client_end,
            encoder,
            field_of_nullable_client_end,
        )?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Box<ExampleOfUseOfAliases> {
    type EncodedOption = ::fidl_next::WireBox<WireExampleOfUseOfAliases>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Box<ExampleOfUseOfAliases>
where
    ___E: ::fidl_next::Encoder + ?Sized,
    ExampleOfUseOfAliases: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::TakeFrom<WireExampleOfUseOfAliases> for ExampleOfUseOfAliases {
    #[inline]
    fn take_from(from: &WireExampleOfUseOfAliases) -> Self {
        Self {
            field_of_u32: ::fidl_next::TakeFrom::take_from(&from.field_of_u32),

            field_of_vec_of_strings: ::fidl_next::TakeFrom::take_from(
                &from.field_of_vec_of_strings,
            ),

            field_of_vec_of_strings_at_most_nine: ::fidl_next::TakeFrom::take_from(
                &from.field_of_vec_of_strings_at_most_nine,
            ),

            field_of_vec_of_strings_at_most_5: ::fidl_next::TakeFrom::take_from(
                &from.field_of_vec_of_strings_at_most_5,
            ),

            field_of_vec_of_ref_me_at_most_5: ::fidl_next::TakeFrom::take_from(
                &from.field_of_vec_of_ref_me_at_most_5,
            ),

            field_of_channel: ::fidl_next::TakeFrom::take_from(&from.field_of_channel),

            field_of_client_end: ::fidl_next::TakeFrom::take_from(&from.field_of_client_end),

            field_of_nullable_client_end: ::fidl_next::TakeFrom::take_from(
                &from.field_of_nullable_client_end,
            ),
        }
    }
}

/// The wire type corresponding to [`ExampleOfUseOfAliases`].
#[derive(Debug)]
#[repr(C)]
pub struct WireExampleOfUseOfAliases {
    pub field_of_u32: ::fidl_next::WireU32,

    pub field_of_vec_of_strings: ::fidl_next::WireVector<::fidl_next::WireString>,

    pub field_of_vec_of_strings_at_most_nine: ::fidl_next::WireVector<::fidl_next::WireString>,

    pub field_of_vec_of_strings_at_most_5: ::fidl_next::WireVector<::fidl_next::WireString>,

    pub field_of_vec_of_ref_me_at_most_5:
        ::fidl_next::WireVector<::fidl_next_test_someotherlibrary::WireReferenceMe>,

    pub field_of_channel: ::fidl_next::fuchsia::WireHandle,

    pub field_of_client_end: ::fidl_next::fuchsia::WireHandle,

    pub field_of_nullable_client_end: ::fidl_next::fuchsia::WireOptionalHandle,
}

unsafe impl ::fidl_next::ZeroPadding for WireExampleOfUseOfAliases {
    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(84).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(4).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExampleOfUseOfAliases
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,

    ___D: ::fidl_next::fuchsia::HandleDecoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut field_of_u32,
                mut field_of_vec_of_strings,
                mut field_of_vec_of_strings_at_most_nine,
                mut field_of_vec_of_strings_at_most_5,
                mut field_of_vec_of_ref_me_at_most_5,
                mut field_of_channel,
                mut field_of_client_end,
                mut field_of_nullable_client_end,

            } = slot;
        }

        ::fidl_next::Decode::decode(field_of_u32.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(field_of_vec_of_strings.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(field_of_vec_of_strings_at_most_nine.as_mut(), decoder)?;

        let field_of_vec_of_strings_at_most_nine =
            unsafe { field_of_vec_of_strings_at_most_nine.deref_unchecked() };

        if field_of_vec_of_strings_at_most_nine.len() > 9 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: field_of_vec_of_strings_at_most_nine.len() as u64,
                limit: 9,
            });
        }

        ::fidl_next::Decode::decode(field_of_vec_of_strings_at_most_5.as_mut(), decoder)?;

        let field_of_vec_of_strings_at_most_5 =
            unsafe { field_of_vec_of_strings_at_most_5.deref_unchecked() };

        if field_of_vec_of_strings_at_most_5.len() > 5 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: field_of_vec_of_strings_at_most_5.len() as u64,
                limit: 5,
            });
        }

        ::fidl_next::Decode::decode(field_of_vec_of_ref_me_at_most_5.as_mut(), decoder)?;

        let field_of_vec_of_ref_me_at_most_5 =
            unsafe { field_of_vec_of_ref_me_at_most_5.deref_unchecked() };

        if field_of_vec_of_ref_me_at_most_5.len() > 5 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: field_of_vec_of_ref_me_at_most_5.len() as u64,
                limit: 5,
            });
        }

        ::fidl_next::Decode::decode(field_of_channel.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(field_of_client_end.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(field_of_nullable_client_end.as_mut(), decoder)?;

        Ok(())
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    impl ::fidl_next::TakeFrom<crate::WireObjType> for ::fidl_test_aliases::ObjType {
        #[inline]
        fn take_from(from: &crate::WireObjType) -> Self {
            match crate::ObjType::from(*from) {
                crate::ObjType::None => Self::None,

                crate::ObjType::Channel => Self::Channel,
            }
        }
    }

    impl ::fidl_next::TakeFrom<crate::WireExampleOfUseOfAliases>
        for ::fidl_test_aliases::ExampleOfUseOfAliases
    {
        #[inline]
        fn take_from(from: &crate::WireExampleOfUseOfAliases) -> Self {
            Self {
                field_of_u32: ::fidl_next::TakeFrom::take_from(&from.field_of_u32),

                field_of_vec_of_strings: ::fidl_next::TakeFrom::take_from(
                    &from.field_of_vec_of_strings,
                ),

                field_of_vec_of_strings_at_most_nine: ::fidl_next::TakeFrom::take_from(
                    &from.field_of_vec_of_strings_at_most_nine,
                ),

                field_of_vec_of_strings_at_most_5: ::fidl_next::TakeFrom::take_from(
                    &from.field_of_vec_of_strings_at_most_5,
                ),

                field_of_vec_of_ref_me_at_most_5: ::fidl_next::TakeFrom::take_from(
                    &from.field_of_vec_of_ref_me_at_most_5,
                ),

                field_of_channel: ::fidl_next::TakeFrom::take_from(&from.field_of_channel),

                field_of_client_end: ::fidl_next::TakeFrom::take_from(&from.field_of_client_end),

                field_of_nullable_client_end: ::fidl_next::TakeFrom::take_from(
                    &from.field_of_nullable_client_end,
                ),
            }
        }
    }
}
