// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

#[derive(Clone, Debug)]
#[repr(C)]
pub struct Empty {}

impl ::fidl_next::Encodable for Empty {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<Self, WireEmpty> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    type Encoded = WireEmpty;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Empty
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Empty
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {

            } = out;
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Empty {
    type EncodedOption = ::fidl_next::WireBox<'static, WireEmpty>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Empty
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Empty: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Empty
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Empty: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireEmpty> for Empty {
    const COPY_OPTIMIZATION: ::fidl_next::CopyOptimization<WireEmpty, Self> =
        unsafe { ::fidl_next::CopyOptimization::enable_if(true) };

    #[inline]
    fn from_wire(wire: WireEmpty) -> Self {
        Self {}
    }
}

impl ::fidl_next::FromWireRef<WireEmpty> for Empty {
    #[inline]
    fn from_wire_ref(wire: &WireEmpty) -> Self {
        Self {}
    }
}

/// The wire type corresponding to [`Empty`].
#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireEmpty {}

unsafe impl ::fidl_next::Wire for WireEmpty {
    type Decoded<'de> = WireEmpty;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEmpty
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {

            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum EmptyFlexibleUnion {
    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for EmptyFlexibleUnion {
    type Encoded = WireEmptyFlexibleUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for EmptyFlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEmptyFlexibleUnion { raw, _phantom: _ } = out);

        match self {
            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for EmptyFlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireEmptyFlexibleUnion { raw, _phantom: _ } = out);

        match self {
            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for EmptyFlexibleUnion {
    type EncodedOption = WireOptionalEmptyFlexibleUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for EmptyFlexibleUnion
where
    ___E: ?Sized,
    EmptyFlexibleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalEmptyFlexibleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for EmptyFlexibleUnion
where
    ___E: ?Sized,
    EmptyFlexibleUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalEmptyFlexibleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireEmptyFlexibleUnion> for EmptyFlexibleUnion {
    #[inline]
    fn from_wire(wire: WireEmptyFlexibleUnion) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireEmptyFlexibleUnion> for EmptyFlexibleUnion {
    #[inline]
    fn from_wire_ref(wire: &WireEmptyFlexibleUnion) -> Self {
        match wire.raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalEmptyFlexibleUnion> for Box<EmptyFlexibleUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalEmptyFlexibleUnion) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalEmptyFlexibleUnion> for Box<EmptyFlexibleUnion> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalEmptyFlexibleUnion) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`EmptyFlexibleUnion`].
#[repr(transparent)]
pub struct WireEmptyFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireEmptyFlexibleUnion {
    type Decoded<'de> = WireEmptyFlexibleUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod empty_flexible_union {
    pub enum Ref {
        UnknownOrdinal_(u64),
    }
}

impl WireEmptyFlexibleUnion {
    pub fn as_ref(&self) -> crate::empty_flexible_union::Ref {
        match self.raw.ordinal() {
            unknown => crate::empty_flexible_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireEmptyFlexibleUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireEmptyFlexibleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireEmptyFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalEmptyFlexibleUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalEmptyFlexibleUnion {
    type Decoded<'de> = WireOptionalEmptyFlexibleUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalEmptyFlexibleUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireEmptyFlexibleUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireEmptyFlexibleUnion> {
        if self.is_some() {
            Some(WireEmptyFlexibleUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalEmptyFlexibleUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalEmptyFlexibleUnion {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalEmptyFlexibleUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalEmptyFlexibleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitFlexibleUnion {
    I(i64),

    F(f32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ExplicitFlexibleUnion {
    type Encoded = WireExplicitFlexibleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ExplicitFlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitFlexibleUnion { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 4, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ExplicitFlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitFlexibleUnion { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i64>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &f32>(value, 4, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ExplicitFlexibleUnion {
    type EncodedOption = WireOptionalExplicitFlexibleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ExplicitFlexibleUnion
where
    ___E: ?Sized,
    ExplicitFlexibleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitFlexibleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ExplicitFlexibleUnion
where
    ___E: ?Sized,
    ExplicitFlexibleUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitFlexibleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireExplicitFlexibleUnion<'de>> for ExplicitFlexibleUnion {
    #[inline]
    fn from_wire(wire: WireExplicitFlexibleUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::I(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI64>()
            })),

            4 => Self::F(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireF32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireExplicitFlexibleUnion<'de>> for ExplicitFlexibleUnion {
    #[inline]
    fn from_wire_ref(wire: &WireExplicitFlexibleUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::I(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI64>()
            })),

            4 => Self::F(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireF32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalExplicitFlexibleUnion<'de>>
    for Box<ExplicitFlexibleUnion>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalExplicitFlexibleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalExplicitFlexibleUnion<'de>>
    for Box<ExplicitFlexibleUnion>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalExplicitFlexibleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitFlexibleUnion`].
#[repr(transparent)]
pub struct WireExplicitFlexibleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireExplicitFlexibleUnion<'static> {
    type Decoded<'de> = WireExplicitFlexibleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod explicit_flexible_union {
    pub enum Ref<'de> {
        I(&'de ::fidl_next::WireI64),

        F(&'de ::fidl_next::WireF32),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireExplicitFlexibleUnion<'de> {
    pub fn as_ref(&self) -> crate::explicit_flexible_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::explicit_flexible_union::Ref::I(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI64>()
            }),

            4 => crate::explicit_flexible_union::Ref::F(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireF32>()
            }),

            unknown => crate::explicit_flexible_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitFlexibleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireExplicitFlexibleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI64>().fmt(f) },
            4 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireF32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitFlexibleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalExplicitFlexibleUnion<'static> {
    type Decoded<'de> = WireOptionalExplicitFlexibleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalExplicitFlexibleUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitFlexibleUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireExplicitFlexibleUnion<'de>> {
        if self.is_some() {
            Some(WireExplicitFlexibleUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitFlexibleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalExplicitFlexibleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitFoo {
    I(i32),

    S(String),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for ExplicitFoo {
    type Encoded = WireExplicitFoo<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ExplicitFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitFoo { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ExplicitFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitFoo { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ExplicitFoo {
    type EncodedOption = WireOptionalExplicitFoo<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ExplicitFoo
where
    ___E: ?Sized,
    ExplicitFoo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitFoo { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ExplicitFoo
where
    ___E: ?Sized,
    ExplicitFoo: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitFoo { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireExplicitFoo<'de>> for ExplicitFoo {
    #[inline]
    fn from_wire(wire: WireExplicitFoo<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::I(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::S(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireExplicitFoo<'de>> for ExplicitFoo {
    #[inline]
    fn from_wire_ref(wire: &WireExplicitFoo<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::I(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::S(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalExplicitFoo<'de>> for Box<ExplicitFoo> {
    #[inline]
    fn from_wire_option(wire: WireOptionalExplicitFoo<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalExplicitFoo<'de>> for Box<ExplicitFoo> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalExplicitFoo<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitFoo`].
#[repr(transparent)]
pub struct WireExplicitFoo<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireExplicitFoo<'static> {
    type Decoded<'de> = WireExplicitFoo<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod explicit_foo {
    pub enum Ref<'de> {
        I(&'de ::fidl_next::WireI32),

        S(&'de ::fidl_next::WireString<'de>),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireExplicitFoo<'de> {
    pub fn as_ref(&self) -> crate::explicit_foo::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::explicit_foo::Ref::I(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            2 => crate::explicit_foo::Ref::S(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            unknown => crate::explicit_foo::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitFoo<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireExplicitFoo<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitFoo<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalExplicitFoo<'static> {
    type Decoded<'de> = WireOptionalExplicitFoo<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalExplicitFoo<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitFoo<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireExplicitFoo<'de>> {
        if self.is_some() {
            Some(WireExplicitFoo { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitFoo<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalExplicitFoo<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct Pizza {
    pub toppings: Vec<String>,
}

impl ::fidl_next::Encodable for Pizza {
    type Encoded = WirePizza<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Pizza
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                toppings,

            } = out;
        }

        ::fidl_next::Encode::encode(self.toppings, encoder, toppings)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Pizza
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                toppings,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.toppings, encoder, toppings)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Pizza {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePizza<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Pizza
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Pizza: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Pizza
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Pizza: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WirePizza<'de>> for Pizza {
    #[inline]
    fn from_wire(wire: WirePizza<'de>) -> Self {
        Self { toppings: ::fidl_next::FromWire::from_wire(wire.toppings) }
    }
}

impl<'de> ::fidl_next::FromWireRef<WirePizza<'de>> for Pizza {
    #[inline]
    fn from_wire_ref(wire: &WirePizza<'de>) -> Self {
        Self { toppings: ::fidl_next::FromWireRef::from_wire_ref(&wire.toppings) }
    }
}

/// The wire type corresponding to [`Pizza`].
#[derive(Debug)]
#[repr(C)]
pub struct WirePizza<'de> {
    pub toppings: ::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>,
}

unsafe impl ::fidl_next::Wire for WirePizza<'static> {
    type Decoded<'de> = WirePizza<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePizza<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut toppings,

            } = slot;
        }

        ::fidl_next::Decode::decode(toppings.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Pasta {
    pub sauce: String,
}

impl ::fidl_next::Encodable for Pasta {
    type Encoded = WirePasta<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Pasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                sauce,

            } = out;
        }

        ::fidl_next::Encode::encode(self.sauce, encoder, sauce)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Pasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                sauce,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.sauce, encoder, sauce)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Pasta {
    type EncodedOption = ::fidl_next::WireBox<'static, WirePasta<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Pasta
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Pasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Pasta
where
    ___E: ::fidl_next::Encoder + ?Sized,
    Pasta: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WirePasta<'de>> for Pasta {
    #[inline]
    fn from_wire(wire: WirePasta<'de>) -> Self {
        Self { sauce: ::fidl_next::FromWire::from_wire(wire.sauce) }
    }
}

impl<'de> ::fidl_next::FromWireRef<WirePasta<'de>> for Pasta {
    #[inline]
    fn from_wire_ref(wire: &WirePasta<'de>) -> Self {
        Self { sauce: ::fidl_next::FromWireRef::from_wire_ref(&wire.sauce) }
    }
}

/// The wire type corresponding to [`Pasta`].
#[derive(Debug)]
#[repr(C)]
pub struct WirePasta<'de> {
    pub sauce: ::fidl_next::WireString<'de>,
}

unsafe impl ::fidl_next::Wire for WirePasta<'static> {
    type Decoded<'de> = WirePasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut sauce,

            } = slot;
        }

        ::fidl_next::Decode::decode(sauce.as_mut(), decoder)?;

        let sauce = unsafe { sauce.deref_unchecked() };

        if sauce.len() > 16 {
            return Err(::fidl_next::DecodeError::VectorTooLong {
                size: sauce.len() as u64,
                limit: 16,
            });
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitPizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for ExplicitPizzaOrPasta {
    type Encoded = WireExplicitPizzaOrPasta<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ExplicitPizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitPizzaOrPasta { raw, _phantom: _ } = out);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 4, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ExplicitPizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitPizzaOrPasta { raw, _phantom: _ } = out);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::Pasta>(value, 4, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ExplicitPizzaOrPasta {
    type EncodedOption = WireOptionalExplicitPizzaOrPasta<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ExplicitPizzaOrPasta
where
    ___E: ?Sized,
    ExplicitPizzaOrPasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitPizzaOrPasta { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ExplicitPizzaOrPasta
where
    ___E: ?Sized,
    ExplicitPizzaOrPasta: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitPizzaOrPasta { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireExplicitPizzaOrPasta<'de>> for ExplicitPizzaOrPasta {
    #[inline]
    fn from_wire(wire: WireExplicitPizzaOrPasta<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Pizza(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WirePizza<'de>>()
            })),

            4 => Self::Pasta(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WirePasta<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireExplicitPizzaOrPasta<'de>> for ExplicitPizzaOrPasta {
    #[inline]
    fn from_wire_ref(wire: &WireExplicitPizzaOrPasta<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WirePizza<'de>>()
            })),

            4 => Self::Pasta(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WirePasta<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalExplicitPizzaOrPasta<'de>>
    for Box<ExplicitPizzaOrPasta>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalExplicitPizzaOrPasta<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalExplicitPizzaOrPasta<'de>>
    for Box<ExplicitPizzaOrPasta>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalExplicitPizzaOrPasta<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitPizzaOrPasta`].
#[repr(transparent)]
pub struct WireExplicitPizzaOrPasta<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireExplicitPizzaOrPasta<'static> {
    type Decoded<'de> = WireExplicitPizzaOrPasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod explicit_pizza_or_pasta {
    pub enum Ref<'de> {
        Pizza(&'de crate::WirePizza<'de>),

        Pasta(&'de crate::WirePasta<'de>),
    }
}

impl<'de> WireExplicitPizzaOrPasta<'de> {
    pub fn as_ref(&self) -> crate::explicit_pizza_or_pasta::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::explicit_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked::<crate::WirePizza<'_>>()
            }),

            4 => crate::explicit_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked::<crate::WirePasta<'_>>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitPizzaOrPasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'static>>(
                raw, decoder,
            )?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'static>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireExplicitPizzaOrPasta<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'_>>().fmt(f) },
            4 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'_>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitPizzaOrPasta<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalExplicitPizzaOrPasta<'static> {
    type Decoded<'de> = WireOptionalExplicitPizzaOrPasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalExplicitPizzaOrPasta<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitPizzaOrPasta<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireExplicitPizzaOrPasta<'de>> {
        if self.is_some() {
            Some(WireExplicitPizzaOrPasta { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitPizzaOrPasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'static>>(
                raw, decoder,
            )?,

            4 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'static>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalExplicitPizzaOrPasta<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitStrictFoo {
    I(i32),

    S(String),
}

impl ::fidl_next::Encodable for ExplicitStrictFoo {
    type Encoded = WireExplicitStrictFoo<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ExplicitStrictFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitStrictFoo { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ExplicitStrictFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitStrictFoo { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 2, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ExplicitStrictFoo {
    type EncodedOption = WireOptionalExplicitStrictFoo<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ExplicitStrictFoo
where
    ___E: ?Sized,
    ExplicitStrictFoo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitStrictFoo { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ExplicitStrictFoo
where
    ___E: ?Sized,
    ExplicitStrictFoo: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitStrictFoo { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireExplicitStrictFoo<'de>> for ExplicitStrictFoo {
    #[inline]
    fn from_wire(wire: WireExplicitStrictFoo<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            2 => Self::I(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            3 => Self::S(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireExplicitStrictFoo<'de>> for ExplicitStrictFoo {
    #[inline]
    fn from_wire_ref(wire: &WireExplicitStrictFoo<'de>) -> Self {
        match wire.raw.ordinal() {
            2 => Self::I(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            3 => Self::S(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalExplicitStrictFoo<'de>>
    for Box<ExplicitStrictFoo>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalExplicitStrictFoo<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalExplicitStrictFoo<'de>>
    for Box<ExplicitStrictFoo>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalExplicitStrictFoo<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitStrictFoo`].
#[repr(transparent)]
pub struct WireExplicitStrictFoo<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireExplicitStrictFoo<'static> {
    type Decoded<'de> = WireExplicitStrictFoo<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod explicit_strict_foo {
    pub enum Ref<'de> {
        I(&'de ::fidl_next::WireI32),

        S(&'de ::fidl_next::WireString<'de>),
    }
}

impl<'de> WireExplicitStrictFoo<'de> {
    pub fn as_ref(&self) -> crate::explicit_strict_foo::Ref<'_> {
        match self.raw.ordinal() {
            2 => crate::explicit_strict_foo::Ref::I(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            3 => crate::explicit_strict_foo::Ref::S(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitStrictFoo<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireExplicitStrictFoo<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitStrictFoo<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalExplicitStrictFoo<'static> {
    type Decoded<'de> = WireOptionalExplicitStrictFoo<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalExplicitStrictFoo<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitStrictFoo<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireExplicitStrictFoo<'de>> {
        if self.is_some() {
            Some(WireExplicitStrictFoo { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitStrictFoo<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalExplicitStrictFoo<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ExplicitUnion {
    Primitive(i32),

    StringNeedsConstructor(String),
}

impl ::fidl_next::Encodable for ExplicitUnion {
    type Encoded = WireExplicitUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ExplicitUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitUnion { raw, _phantom: _ } = out);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ExplicitUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireExplicitUnion { raw, _phantom: _ } = out);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ExplicitUnion {
    type EncodedOption = WireOptionalExplicitUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ExplicitUnion
where
    ___E: ?Sized,
    ExplicitUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ExplicitUnion
where
    ___E: ?Sized,
    ExplicitUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalExplicitUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireExplicitUnion<'de>> for ExplicitUnion {
    #[inline]
    fn from_wire(wire: WireExplicitUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Primitive(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            3 => Self::StringNeedsConstructor(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireExplicitUnion<'de>> for ExplicitUnion {
    #[inline]
    fn from_wire_ref(wire: &WireExplicitUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            3 => Self::StringNeedsConstructor(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalExplicitUnion<'de>> for Box<ExplicitUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalExplicitUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalExplicitUnion<'de>> for Box<ExplicitUnion> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalExplicitUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ExplicitUnion`].
#[repr(transparent)]
pub struct WireExplicitUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireExplicitUnion<'static> {
    type Decoded<'de> = WireExplicitUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod explicit_union {
    pub enum Ref<'de> {
        Primitive(&'de ::fidl_next::WireI32),

        StringNeedsConstructor(&'de ::fidl_next::WireString<'de>),
    }
}

impl<'de> WireExplicitUnion<'de> {
    pub fn as_ref(&self) -> crate::explicit_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::explicit_union::Ref::Primitive(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            3 => crate::explicit_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireExplicitUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireExplicitUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalExplicitUnion<'static> {
    type Decoded<'de> = WireOptionalExplicitUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalExplicitUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireExplicitUnion<'de>> {
        if self.is_some() {
            Some(WireExplicitUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalExplicitUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalExplicitUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FieldCollision {
    FieldCollisionTag(i32),
}

impl ::fidl_next::Encodable for FieldCollision {
    type Encoded = WireFieldCollision;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for FieldCollision
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFieldCollision { raw, _phantom: _ } = out);

        match self {
            Self::FieldCollisionTag(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, i32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for FieldCollision
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFieldCollision { raw, _phantom: _ } = out);

        match self {
            Self::FieldCollisionTag(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &i32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for FieldCollision {
    type EncodedOption = WireOptionalFieldCollision;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for FieldCollision
where
    ___E: ?Sized,
    FieldCollision: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFieldCollision { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for FieldCollision
where
    ___E: ?Sized,
    FieldCollision: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFieldCollision { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireFieldCollision> for FieldCollision {
    #[inline]
    fn from_wire(wire: WireFieldCollision) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::FieldCollisionTag(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireFieldCollision> for FieldCollision {
    #[inline]
    fn from_wire_ref(wire: &WireFieldCollision) -> Self {
        match wire.raw.ordinal() {
            1 => Self::FieldCollisionTag(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalFieldCollision> for Box<FieldCollision> {
    #[inline]
    fn from_wire_option(wire: WireOptionalFieldCollision) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalFieldCollision> for Box<FieldCollision> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalFieldCollision) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FieldCollision`].
#[repr(transparent)]
pub struct WireFieldCollision {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireFieldCollision {
    type Decoded<'de> = WireFieldCollision;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod field_collision {
    pub enum Ref<'de> {
        FieldCollisionTag(&'de ::fidl_next::WireI32),
    }
}

impl WireFieldCollision {
    pub fn as_ref(&self) -> crate::field_collision::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::field_collision::Ref::FieldCollisionTag(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireFieldCollision {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFieldCollision
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireFieldCollision {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFieldCollision {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalFieldCollision {
    type Decoded<'de> = WireOptionalFieldCollision;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalFieldCollision {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFieldCollision> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireFieldCollision> {
        if self.is_some() {
            Some(WireFieldCollision { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalFieldCollision {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalFieldCollision {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireI32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalFieldCollision
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireI32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalFieldCollision {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexibleFoo {
    S(String),

    I(i32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for FlexibleFoo {
    type Encoded = WireFlexibleFoo<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for FlexibleFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexibleFoo { raw, _phantom: _ } = out);

        match self {
            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 1, encoder, raw)?
            }

            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for FlexibleFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexibleFoo { raw, _phantom: _ } = out);

        match self {
            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 1, encoder, raw)?
            }

            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for FlexibleFoo {
    type EncodedOption = WireOptionalFlexibleFoo<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for FlexibleFoo
where
    ___E: ?Sized,
    FlexibleFoo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexibleFoo { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for FlexibleFoo
where
    ___E: ?Sized,
    FlexibleFoo: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexibleFoo { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireFlexibleFoo<'de>> for FlexibleFoo {
    #[inline]
    fn from_wire(wire: WireFlexibleFoo<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::S(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            2 => Self::I(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireFlexibleFoo<'de>> for FlexibleFoo {
    #[inline]
    fn from_wire_ref(wire: &WireFlexibleFoo<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::S(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            2 => Self::I(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalFlexibleFoo<'de>> for Box<FlexibleFoo> {
    #[inline]
    fn from_wire_option(wire: WireOptionalFlexibleFoo<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalFlexibleFoo<'de>> for Box<FlexibleFoo> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalFlexibleFoo<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexibleFoo`].
#[repr(transparent)]
pub struct WireFlexibleFoo<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireFlexibleFoo<'static> {
    type Decoded<'de> = WireFlexibleFoo<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod flexible_foo {
    pub enum Ref<'de> {
        S(&'de ::fidl_next::WireString<'de>),

        I(&'de ::fidl_next::WireI32),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireFlexibleFoo<'de> {
    pub fn as_ref(&self) -> crate::flexible_foo::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::flexible_foo::Ref::S(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            2 => crate::flexible_foo::Ref::I(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            unknown => crate::flexible_foo::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlexibleFoo<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireFlexibleFoo<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexibleFoo<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalFlexibleFoo<'static> {
    type Decoded<'de> = WireOptionalFlexibleFoo<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalFlexibleFoo<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexibleFoo<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireFlexibleFoo<'de>> {
        if self.is_some() {
            Some(WireFlexibleFoo { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalFlexibleFoo<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalFlexibleFoo<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexiblePizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for FlexiblePizzaOrPasta {
    type Encoded = WireFlexiblePizzaOrPasta<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for FlexiblePizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexiblePizzaOrPasta { raw, _phantom: _ } = out);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for FlexiblePizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexiblePizzaOrPasta { raw, _phantom: _ } = out);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::Pasta>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for FlexiblePizzaOrPasta {
    type EncodedOption = WireOptionalFlexiblePizzaOrPasta<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for FlexiblePizzaOrPasta
where
    ___E: ?Sized,
    FlexiblePizzaOrPasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexiblePizzaOrPasta { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for FlexiblePizzaOrPasta
where
    ___E: ?Sized,
    FlexiblePizzaOrPasta: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexiblePizzaOrPasta { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireFlexiblePizzaOrPasta<'de>> for FlexiblePizzaOrPasta {
    #[inline]
    fn from_wire(wire: WireFlexiblePizzaOrPasta<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Pizza(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WirePizza<'de>>()
            })),

            2 => Self::Pasta(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WirePasta<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireFlexiblePizzaOrPasta<'de>> for FlexiblePizzaOrPasta {
    #[inline]
    fn from_wire_ref(wire: &WireFlexiblePizzaOrPasta<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WirePizza<'de>>()
            })),

            2 => Self::Pasta(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WirePasta<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalFlexiblePizzaOrPasta<'de>>
    for Box<FlexiblePizzaOrPasta>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalFlexiblePizzaOrPasta<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalFlexiblePizzaOrPasta<'de>>
    for Box<FlexiblePizzaOrPasta>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalFlexiblePizzaOrPasta<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexiblePizzaOrPasta`].
#[repr(transparent)]
pub struct WireFlexiblePizzaOrPasta<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireFlexiblePizzaOrPasta<'static> {
    type Decoded<'de> = WireFlexiblePizzaOrPasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod flexible_pizza_or_pasta {
    pub enum Ref<'de> {
        Pizza(&'de crate::WirePizza<'de>),

        Pasta(&'de crate::WirePasta<'de>),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireFlexiblePizzaOrPasta<'de> {
    pub fn as_ref(&self) -> crate::flexible_pizza_or_pasta::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::flexible_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked::<crate::WirePizza<'_>>()
            }),

            2 => crate::flexible_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked::<crate::WirePasta<'_>>()
            }),

            unknown => crate::flexible_pizza_or_pasta::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlexiblePizzaOrPasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'static>>(
                raw, decoder,
            )?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireFlexiblePizzaOrPasta<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'_>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'_>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexiblePizzaOrPasta<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalFlexiblePizzaOrPasta<'static> {
    type Decoded<'de> = WireOptionalFlexiblePizzaOrPasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalFlexiblePizzaOrPasta<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexiblePizzaOrPasta<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireFlexiblePizzaOrPasta<'de>> {
        if self.is_some() {
            Some(WireFlexiblePizzaOrPasta { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalFlexiblePizzaOrPasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'static>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalFlexiblePizzaOrPasta<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum FlexibleUnion {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for FlexibleUnion {
    type Encoded = WireFlexibleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for FlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexibleUnion { raw, _phantom: _ } = out);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for FlexibleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireFlexibleUnion { raw, _phantom: _ } = out);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &Vec<String>>(value, 3, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for FlexibleUnion {
    type EncodedOption = WireOptionalFlexibleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for FlexibleUnion
where
    ___E: ?Sized,
    FlexibleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexibleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for FlexibleUnion
where
    ___E: ?Sized,
    FlexibleUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalFlexibleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireFlexibleUnion<'de>> for FlexibleUnion {
    #[inline]
    fn from_wire(wire: WireFlexibleUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Primitive(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::FromWire::from_wire(unsafe {
                raw.get()
                    .read_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireFlexibleUnion<'de>> for FlexibleUnion {
    #[inline]
    fn from_wire_ref(wire: &WireFlexibleUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::FromWireRef::from_wire_ref(
                unsafe {
                    wire.raw.get().deref_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>>()
                },
            )),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalFlexibleUnion<'de>> for Box<FlexibleUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalFlexibleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalFlexibleUnion<'de>> for Box<FlexibleUnion> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalFlexibleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`FlexibleUnion`].
#[repr(transparent)]
pub struct WireFlexibleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireFlexibleUnion<'static> {
    type Decoded<'de> = WireFlexibleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod flexible_union {
    pub enum Ref<'de> {
        Primitive(&'de ::fidl_next::WireI32),

        StringNeedsConstructor(&'de ::fidl_next::WireString<'de>),

        VectorStringAlsoNeedsConstructor(
            &'de ::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>,
        ),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireFlexibleUnion<'de> {
    pub fn as_ref(&self) -> crate::flexible_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::flexible_union::Ref::Primitive(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            2 => crate::flexible_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            3 => {
                crate::flexible_union::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                    self.raw.get().deref_unchecked::<::fidl_next::WireVector<'_, ::fidl_next::WireString<'_>>>()
                })
            }

            unknown => crate::flexible_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireFlexibleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireFlexibleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl_next::WireVector<'_, ::fidl_next::WireString<'_>>>()
                    .fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexibleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalFlexibleUnion<'static> {
    type Decoded<'de> = WireOptionalFlexibleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalFlexibleUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexibleUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireFlexibleUnion<'de>> {
        if self.is_some() {
            Some(WireFlexibleUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalFlexibleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalFlexibleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum NewerSimpleUnion {
    I(i64),

    S(String),

    V(Vec<String>),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for NewerSimpleUnion {
    type Encoded = WireNewerSimpleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for NewerSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireNewerSimpleUnion { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for NewerSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireNewerSimpleUnion { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i64>(value, 1, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 2, encoder, raw)?
            }

            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &Vec<String>>(value, 3, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for NewerSimpleUnion {
    type EncodedOption = WireOptionalNewerSimpleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for NewerSimpleUnion
where
    ___E: ?Sized,
    NewerSimpleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalNewerSimpleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for NewerSimpleUnion
where
    ___E: ?Sized,
    NewerSimpleUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalNewerSimpleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireNewerSimpleUnion<'de>> for NewerSimpleUnion {
    #[inline]
    fn from_wire(wire: WireNewerSimpleUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::I(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI64>()
            })),

            2 => Self::S(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            3 => Self::V(::fidl_next::FromWire::from_wire(unsafe {
                raw.get()
                    .read_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireNewerSimpleUnion<'de>> for NewerSimpleUnion {
    #[inline]
    fn from_wire_ref(wire: &WireNewerSimpleUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::I(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI64>()
            })),

            2 => Self::S(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            3 => {
                Self::V(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                    wire.raw.get().deref_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>>()
                }))
            }

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalNewerSimpleUnion<'de>> for Box<NewerSimpleUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalNewerSimpleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalNewerSimpleUnion<'de>>
    for Box<NewerSimpleUnion>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalNewerSimpleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`NewerSimpleUnion`].
#[repr(transparent)]
pub struct WireNewerSimpleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireNewerSimpleUnion<'static> {
    type Decoded<'de> = WireNewerSimpleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod newer_simple_union {
    pub enum Ref<'de> {
        I(&'de ::fidl_next::WireI64),

        S(&'de ::fidl_next::WireString<'de>),

        V(&'de ::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireNewerSimpleUnion<'de> {
    pub fn as_ref(&self) -> crate::newer_simple_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::newer_simple_union::Ref::I(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI64>()
            }),

            2 => crate::newer_simple_union::Ref::S(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            3 => {
                crate::newer_simple_union::Ref::V(unsafe {
                    self.raw.get().deref_unchecked::<::fidl_next::WireVector<'_, ::fidl_next::WireString<'_>>>()
                })
            }

            unknown => crate::newer_simple_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireNewerSimpleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireNewerSimpleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI64>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl_next::WireVector<'_, ::fidl_next::WireString<'_>>>()
                    .fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalNewerSimpleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalNewerSimpleUnion<'static> {
    type Decoded<'de> = WireOptionalNewerSimpleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalNewerSimpleUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireNewerSimpleUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireNewerSimpleUnion<'de>> {
        if self.is_some() {
            Some(WireNewerSimpleUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalNewerSimpleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalNewerSimpleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct NullableUnionStruct {
    pub the_union: Option<Box<crate::Union>>,
}

impl ::fidl_next::Encodable for NullableUnionStruct {
    type Encoded = WireNullableUnionStruct<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for NullableUnionStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                the_union,

            } = out;
        }

        ::fidl_next::Encode::encode(self.the_union, encoder, the_union)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for NullableUnionStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                the_union,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.the_union, encoder, the_union)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for NullableUnionStruct {
    type EncodedOption = ::fidl_next::WireBox<'static, WireNullableUnionStruct<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for NullableUnionStruct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    NullableUnionStruct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for NullableUnionStruct
where
    ___E: ::fidl_next::Encoder + ?Sized,
    NullableUnionStruct: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireNullableUnionStruct<'de>> for NullableUnionStruct {
    #[inline]
    fn from_wire(wire: WireNullableUnionStruct<'de>) -> Self {
        Self { the_union: ::fidl_next::FromWire::from_wire(wire.the_union) }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireNullableUnionStruct<'de>> for NullableUnionStruct {
    #[inline]
    fn from_wire_ref(wire: &WireNullableUnionStruct<'de>) -> Self {
        Self { the_union: ::fidl_next::FromWireRef::from_wire_ref(&wire.the_union) }
    }
}

/// The wire type corresponding to [`NullableUnionStruct`].
#[derive(Debug)]
#[repr(C)]
pub struct WireNullableUnionStruct<'de> {
    pub the_union: crate::WireOptionalUnion<'de>,
}

unsafe impl ::fidl_next::Wire for WireNullableUnionStruct<'static> {
    type Decoded<'de> = WireNullableUnionStruct<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireNullableUnionStruct<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut the_union,

            } = slot;
        }

        ::fidl_next::Decode::decode(the_union.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum OlderSimpleUnion {
    I(i64),

    F(f32),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for OlderSimpleUnion {
    type Encoded = WireOlderSimpleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for OlderSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOlderSimpleUnion { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for OlderSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOlderSimpleUnion { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i64>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &f32>(value, 2, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for OlderSimpleUnion {
    type EncodedOption = WireOptionalOlderSimpleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for OlderSimpleUnion
where
    ___E: ?Sized,
    OlderSimpleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOlderSimpleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for OlderSimpleUnion
where
    ___E: ?Sized,
    OlderSimpleUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalOlderSimpleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireOlderSimpleUnion<'de>> for OlderSimpleUnion {
    #[inline]
    fn from_wire(wire: WireOlderSimpleUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::I(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI64>()
            })),

            2 => Self::F(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireF32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireOlderSimpleUnion<'de>> for OlderSimpleUnion {
    #[inline]
    fn from_wire_ref(wire: &WireOlderSimpleUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::I(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI64>()
            })),

            2 => Self::F(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireF32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalOlderSimpleUnion<'de>> for Box<OlderSimpleUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalOlderSimpleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalOlderSimpleUnion<'de>>
    for Box<OlderSimpleUnion>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalOlderSimpleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`OlderSimpleUnion`].
#[repr(transparent)]
pub struct WireOlderSimpleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOlderSimpleUnion<'static> {
    type Decoded<'de> = WireOlderSimpleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod older_simple_union {
    pub enum Ref<'de> {
        I(&'de ::fidl_next::WireI64),

        F(&'de ::fidl_next::WireF32),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireOlderSimpleUnion<'de> {
    pub fn as_ref(&self) -> crate::older_simple_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::older_simple_union::Ref::I(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI64>()
            }),

            2 => crate::older_simple_union::Ref::F(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireF32>()
            }),

            unknown => crate::older_simple_union::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOlderSimpleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOlderSimpleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI64>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireF32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOlderSimpleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalOlderSimpleUnion<'static> {
    type Decoded<'de> = WireOptionalOlderSimpleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalOlderSimpleUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOlderSimpleUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireOlderSimpleUnion<'de>> {
        if self.is_some() {
            Some(WireOlderSimpleUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalOlderSimpleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalOlderSimpleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum PizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for PizzaOrPasta {
    type Encoded = WirePizzaOrPasta<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for PizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WirePizzaOrPasta { raw, _phantom: _ } = out);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for PizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WirePizzaOrPasta { raw, _phantom: _ } = out);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for PizzaOrPasta {
    type EncodedOption = WireOptionalPizzaOrPasta<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for PizzaOrPasta
where
    ___E: ?Sized,
    PizzaOrPasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalPizzaOrPasta { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for PizzaOrPasta
where
    ___E: ?Sized,
    PizzaOrPasta: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalPizzaOrPasta { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WirePizzaOrPasta<'de>> for PizzaOrPasta {
    #[inline]
    fn from_wire(wire: WirePizzaOrPasta<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Pizza(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WirePizza<'de>>()
            })),

            2 => Self::Pasta(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WirePasta<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WirePizzaOrPasta<'de>> for PizzaOrPasta {
    #[inline]
    fn from_wire_ref(wire: &WirePizzaOrPasta<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WirePizza<'de>>()
            })),

            2 => Self::Pasta(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WirePasta<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalPizzaOrPasta<'de>> for Box<PizzaOrPasta> {
    #[inline]
    fn from_wire_option(wire: WireOptionalPizzaOrPasta<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalPizzaOrPasta<'de>> for Box<PizzaOrPasta> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalPizzaOrPasta<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`PizzaOrPasta`].
#[repr(transparent)]
pub struct WirePizzaOrPasta<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WirePizzaOrPasta<'static> {
    type Decoded<'de> = WirePizzaOrPasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod pizza_or_pasta {
    pub enum Ref<'de> {
        Pizza(&'de crate::WirePizza<'de>),

        Pasta(&'de crate::WirePasta<'de>),
    }
}

impl<'de> WirePizzaOrPasta<'de> {
    pub fn as_ref(&self) -> crate::pizza_or_pasta::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked::<crate::WirePizza<'_>>()
            }),

            2 => crate::pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked::<crate::WirePasta<'_>>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WirePizzaOrPasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'static>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WirePizzaOrPasta<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'_>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'_>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalPizzaOrPasta<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalPizzaOrPasta<'static> {
    type Decoded<'de> = WireOptionalPizzaOrPasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalPizzaOrPasta<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WirePizzaOrPasta<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WirePizzaOrPasta<'de>> {
        if self.is_some() {
            Some(WirePizzaOrPasta { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalPizzaOrPasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'static>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalPizzaOrPasta<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum ReverseOrdinalUnion {
    First(u32),

    Second(u32),
}

impl ::fidl_next::Encodable for ReverseOrdinalUnion {
    type Encoded = WireReverseOrdinalUnion;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for ReverseOrdinalUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireReverseOrdinalUnion { raw, _phantom: _ } = out);

        match self {
            Self::First(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 1, encoder, raw)?
            }

            Self::Second(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for ReverseOrdinalUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireReverseOrdinalUnion { raw, _phantom: _ } = out);

        match self {
            Self::First(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &u32>(value, 1, encoder, raw)?
            }

            Self::Second(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for ReverseOrdinalUnion {
    type EncodedOption = WireOptionalReverseOrdinalUnion;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for ReverseOrdinalUnion
where
    ___E: ?Sized,
    ReverseOrdinalUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalReverseOrdinalUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for ReverseOrdinalUnion
where
    ___E: ?Sized,
    ReverseOrdinalUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalReverseOrdinalUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireReverseOrdinalUnion> for ReverseOrdinalUnion {
    #[inline]
    fn from_wire(wire: WireReverseOrdinalUnion) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::First(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireU32>()
            })),

            2 => Self::Second(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireReverseOrdinalUnion> for ReverseOrdinalUnion {
    #[inline]
    fn from_wire_ref(wire: &WireReverseOrdinalUnion) -> Self {
        match wire.raw.ordinal() {
            1 => Self::First(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            })),

            2 => Self::Second(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalReverseOrdinalUnion> for Box<ReverseOrdinalUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalReverseOrdinalUnion) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalReverseOrdinalUnion> for Box<ReverseOrdinalUnion> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalReverseOrdinalUnion) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`ReverseOrdinalUnion`].
#[repr(transparent)]
pub struct WireReverseOrdinalUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireReverseOrdinalUnion {
    type Decoded<'de> = WireReverseOrdinalUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod reverse_ordinal_union {
    pub enum Ref<'de> {
        First(&'de ::fidl_next::WireU32),

        Second(&'de ::fidl_next::WireU32),
    }
}

impl WireReverseOrdinalUnion {
    pub fn as_ref(&self) -> crate::reverse_ordinal_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::reverse_ordinal_union::Ref::First(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            }),

            2 => crate::reverse_ordinal_union::Ref::Second(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireU32>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl Clone for WireReverseOrdinalUnion {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireReverseOrdinalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireReverseOrdinalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireU32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalReverseOrdinalUnion {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalReverseOrdinalUnion {
    type Decoded<'de> = WireOptionalReverseOrdinalUnion;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalReverseOrdinalUnion {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireReverseOrdinalUnion> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireReverseOrdinalUnion> {
        if self.is_some() {
            Some(WireReverseOrdinalUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalReverseOrdinalUnion {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalReverseOrdinalUnion {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            2 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<::fidl_next::WireU32>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalReverseOrdinalUnion
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as_static::<___D, ::fidl_next::WireU32>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalReverseOrdinalUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictBoundedUnion {
    V(Vec<u8>),
}

impl ::fidl_next::Encodable for StrictBoundedUnion {
    type Encoded = WireStrictBoundedUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for StrictBoundedUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictBoundedUnion { raw, _phantom: _ } = out);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<u8>>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for StrictBoundedUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictBoundedUnion { raw, _phantom: _ } = out);

        match self {
            Self::V(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &Vec<u8>>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for StrictBoundedUnion {
    type EncodedOption = WireOptionalStrictBoundedUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for StrictBoundedUnion
where
    ___E: ?Sized,
    StrictBoundedUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictBoundedUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for StrictBoundedUnion
where
    ___E: ?Sized,
    StrictBoundedUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictBoundedUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireStrictBoundedUnion<'de>> for StrictBoundedUnion {
    #[inline]
    fn from_wire(wire: WireStrictBoundedUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::V(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireVector<'de, u8>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireStrictBoundedUnion<'de>> for StrictBoundedUnion {
    #[inline]
    fn from_wire_ref(wire: &WireStrictBoundedUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::V(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireVector<'de, u8>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalStrictBoundedUnion<'de>>
    for Box<StrictBoundedUnion>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalStrictBoundedUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalStrictBoundedUnion<'de>>
    for Box<StrictBoundedUnion>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalStrictBoundedUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictBoundedUnion`].
#[repr(transparent)]
pub struct WireStrictBoundedUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireStrictBoundedUnion<'static> {
    type Decoded<'de> = WireStrictBoundedUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod strict_bounded_union {
    pub enum Ref<'de> {
        V(&'de ::fidl_next::WireVector<'de, u8>),
    }
}

impl<'de> WireStrictBoundedUnion<'de> {
    pub fn as_ref(&self) -> crate::strict_bounded_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_bounded_union::Ref::V(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireVector<'_, u8>>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictBoundedUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireVector<'static, u8>>(
                    raw, decoder,
                )?
            }

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireStrictBoundedUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireVector<'_, u8>>().fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictBoundedUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalStrictBoundedUnion<'static> {
    type Decoded<'de> = WireOptionalStrictBoundedUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalStrictBoundedUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictBoundedUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireStrictBoundedUnion<'de>> {
        if self.is_some() {
            Some(WireStrictBoundedUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictBoundedUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireVector<'static, u8>>(
                    raw, decoder,
                )?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalStrictBoundedUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictFoo {
    S(String),

    I(i32),
}

impl ::fidl_next::Encodable for StrictFoo {
    type Encoded = WireStrictFoo<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for StrictFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictFoo { raw, _phantom: _ } = out);

        match self {
            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 1, encoder, raw)?
            }

            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for StrictFoo
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictFoo { raw, _phantom: _ } = out);

        match self {
            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 1, encoder, raw)?
            }

            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for StrictFoo {
    type EncodedOption = WireOptionalStrictFoo<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for StrictFoo
where
    ___E: ?Sized,
    StrictFoo: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictFoo { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for StrictFoo
where
    ___E: ?Sized,
    StrictFoo: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictFoo { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireStrictFoo<'de>> for StrictFoo {
    #[inline]
    fn from_wire(wire: WireStrictFoo<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::S(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            2 => Self::I(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireStrictFoo<'de>> for StrictFoo {
    #[inline]
    fn from_wire_ref(wire: &WireStrictFoo<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::S(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            2 => Self::I(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalStrictFoo<'de>> for Box<StrictFoo> {
    #[inline]
    fn from_wire_option(wire: WireOptionalStrictFoo<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalStrictFoo<'de>> for Box<StrictFoo> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalStrictFoo<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictFoo`].
#[repr(transparent)]
pub struct WireStrictFoo<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireStrictFoo<'static> {
    type Decoded<'de> = WireStrictFoo<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod strict_foo {
    pub enum Ref<'de> {
        S(&'de ::fidl_next::WireString<'de>),

        I(&'de ::fidl_next::WireI32),
    }
}

impl<'de> WireStrictFoo<'de> {
    pub fn as_ref(&self) -> crate::strict_foo::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_foo::Ref::S(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            2 => crate::strict_foo::Ref::I(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictFoo<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireStrictFoo<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictFoo<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalStrictFoo<'static> {
    type Decoded<'de> = WireOptionalStrictFoo<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalStrictFoo<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictFoo<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireStrictFoo<'de>> {
        if self.is_some() {
            Some(WireStrictFoo { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictFoo<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalStrictFoo<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictPizzaOrPasta {
    Pizza(crate::Pizza),

    Pasta(crate::Pasta),
}

impl ::fidl_next::Encodable for StrictPizzaOrPasta {
    type Encoded = WireStrictPizzaOrPasta<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for StrictPizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictPizzaOrPasta { raw, _phantom: _ } = out);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for StrictPizzaOrPasta
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictPizzaOrPasta { raw, _phantom: _ } = out);

        match self {
            Self::Pizza(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::Pizza>(value, 1, encoder, raw)?
            }

            Self::Pasta(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for StrictPizzaOrPasta {
    type EncodedOption = WireOptionalStrictPizzaOrPasta<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for StrictPizzaOrPasta
where
    ___E: ?Sized,
    StrictPizzaOrPasta: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictPizzaOrPasta { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for StrictPizzaOrPasta
where
    ___E: ?Sized,
    StrictPizzaOrPasta: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictPizzaOrPasta { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireStrictPizzaOrPasta<'de>> for StrictPizzaOrPasta {
    #[inline]
    fn from_wire(wire: WireStrictPizzaOrPasta<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Pizza(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WirePizza<'de>>()
            })),

            2 => Self::Pasta(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WirePasta<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireStrictPizzaOrPasta<'de>> for StrictPizzaOrPasta {
    #[inline]
    fn from_wire_ref(wire: &WireStrictPizzaOrPasta<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Pizza(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WirePizza<'de>>()
            })),

            2 => Self::Pasta(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WirePasta<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalStrictPizzaOrPasta<'de>>
    for Box<StrictPizzaOrPasta>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalStrictPizzaOrPasta<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalStrictPizzaOrPasta<'de>>
    for Box<StrictPizzaOrPasta>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalStrictPizzaOrPasta<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictPizzaOrPasta`].
#[repr(transparent)]
pub struct WireStrictPizzaOrPasta<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireStrictPizzaOrPasta<'static> {
    type Decoded<'de> = WireStrictPizzaOrPasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod strict_pizza_or_pasta {
    pub enum Ref<'de> {
        Pizza(&'de crate::WirePizza<'de>),

        Pasta(&'de crate::WirePasta<'de>),
    }
}

impl<'de> WireStrictPizzaOrPasta<'de> {
    pub fn as_ref(&self) -> crate::strict_pizza_or_pasta::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_pizza_or_pasta::Ref::Pizza(unsafe {
                self.raw.get().deref_unchecked::<crate::WirePizza<'_>>()
            }),

            2 => crate::strict_pizza_or_pasta::Ref::Pasta(unsafe {
                self.raw.get().deref_unchecked::<crate::WirePasta<'_>>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictPizzaOrPasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'static>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireStrictPizzaOrPasta<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'_>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'_>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictPizzaOrPasta<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalStrictPizzaOrPasta<'static> {
    type Decoded<'de> = WireOptionalStrictPizzaOrPasta<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalStrictPizzaOrPasta<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictPizzaOrPasta<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireStrictPizzaOrPasta<'de>> {
        if self.is_some() {
            Some(WireStrictPizzaOrPasta { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictPizzaOrPasta<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePizza<'static>>(
                raw, decoder,
            )?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, crate::WirePasta<'static>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalStrictPizzaOrPasta<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictSimpleUnion {
    I(i32),

    F(f32),

    S(String),
}

impl ::fidl_next::Encodable for StrictSimpleUnion {
    type Encoded = WireStrictSimpleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for StrictSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictSimpleUnion { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, f32>(value, 2, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for StrictSimpleUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictSimpleUnion { raw, _phantom: _ } = out);

        match self {
            Self::I(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::F(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &f32>(value, 2, encoder, raw)?
            }

            Self::S(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for StrictSimpleUnion {
    type EncodedOption = WireOptionalStrictSimpleUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for StrictSimpleUnion
where
    ___E: ?Sized,
    StrictSimpleUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictSimpleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for StrictSimpleUnion
where
    ___E: ?Sized,
    StrictSimpleUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictSimpleUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireStrictSimpleUnion<'de>> for StrictSimpleUnion {
    #[inline]
    fn from_wire(wire: WireStrictSimpleUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::I(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::F(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireF32>()
            })),

            3 => Self::S(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireStrictSimpleUnion<'de>> for StrictSimpleUnion {
    #[inline]
    fn from_wire_ref(wire: &WireStrictSimpleUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::I(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::F(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireF32>()
            })),

            3 => Self::S(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalStrictSimpleUnion<'de>>
    for Box<StrictSimpleUnion>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalStrictSimpleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalStrictSimpleUnion<'de>>
    for Box<StrictSimpleUnion>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalStrictSimpleUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictSimpleUnion`].
#[repr(transparent)]
pub struct WireStrictSimpleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireStrictSimpleUnion<'static> {
    type Decoded<'de> = WireStrictSimpleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod strict_simple_union {
    pub enum Ref<'de> {
        I(&'de ::fidl_next::WireI32),

        F(&'de ::fidl_next::WireF32),

        S(&'de ::fidl_next::WireString<'de>),
    }
}

impl<'de> WireStrictSimpleUnion<'de> {
    pub fn as_ref(&self) -> crate::strict_simple_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_simple_union::Ref::I(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            2 => crate::strict_simple_union::Ref::F(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireF32>()
            }),

            3 => crate::strict_simple_union::Ref::S(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictSimpleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireStrictSimpleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireF32>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictSimpleUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalStrictSimpleUnion<'static> {
    type Decoded<'de> = WireOptionalStrictSimpleUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalStrictSimpleUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictSimpleUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireStrictSimpleUnion<'de>> {
        if self.is_some() {
            Some(WireStrictSimpleUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictSimpleUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireF32>(raw, decoder)?,

            3 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalStrictSimpleUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum StrictUnion {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),
}

impl ::fidl_next::Encodable for StrictUnion {
    type Encoded = WireStrictUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for StrictUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictUnion { raw, _phantom: _ } = out);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for StrictUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireStrictUnion { raw, _phantom: _ } = out);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for StrictUnion {
    type EncodedOption = WireOptionalStrictUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for StrictUnion
where
    ___E: ?Sized,
    StrictUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for StrictUnion
where
    ___E: ?Sized,
    StrictUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalStrictUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireStrictUnion<'de>> for StrictUnion {
    #[inline]
    fn from_wire(wire: WireStrictUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Primitive(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::FromWire::from_wire(unsafe {
                raw.get()
                    .read_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireStrictUnion<'de>> for StrictUnion {
    #[inline]
    fn from_wire_ref(wire: &WireStrictUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::FromWireRef::from_wire_ref(
                unsafe {
                    wire.raw.get().deref_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>>()
                },
            )),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalStrictUnion<'de>> for Box<StrictUnion> {
    #[inline]
    fn from_wire_option(wire: WireOptionalStrictUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalStrictUnion<'de>> for Box<StrictUnion> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalStrictUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`StrictUnion`].
#[repr(transparent)]
pub struct WireStrictUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireStrictUnion<'static> {
    type Decoded<'de> = WireStrictUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod strict_union {
    pub enum Ref<'de> {
        Primitive(&'de ::fidl_next::WireI32),

        StringNeedsConstructor(&'de ::fidl_next::WireString<'de>),

        VectorStringAlsoNeedsConstructor(
            &'de ::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>,
        ),
    }
}

impl<'de> WireStrictUnion<'de> {
    pub fn as_ref(&self) -> crate::strict_union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::strict_union::Ref::Primitive(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            2 => crate::strict_union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            3 => {
                crate::strict_union::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                    self.raw.get().deref_unchecked::<::fidl_next::WireVector<'_, ::fidl_next::WireString<'_>>>()
                })
            }

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStrictUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireStrictUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl_next::WireVector<'_, ::fidl_next::WireString<'_>>>()
                    .fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalStrictUnion<'static> {
    type Decoded<'de> = WireOptionalStrictUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalStrictUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireStrictUnion<'de>> {
        if self.is_some() {
            Some(WireStrictUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalStrictUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalStrictUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct StructWithNullableUnion {
    pub x1: Option<Box<crate::OlderSimpleUnion>>,
}

impl ::fidl_next::Encodable for StructWithNullableUnion {
    type Encoded = WireStructWithNullableUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for StructWithNullableUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                x1,

            } = out;
        }

        ::fidl_next::Encode::encode(self.x1, encoder, x1)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for StructWithNullableUnion
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                x1,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.x1, encoder, x1)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for StructWithNullableUnion {
    type EncodedOption = ::fidl_next::WireBox<'static, WireStructWithNullableUnion<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for StructWithNullableUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StructWithNullableUnion: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for StructWithNullableUnion
where
    ___E: ::fidl_next::Encoder + ?Sized,
    StructWithNullableUnion: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireStructWithNullableUnion<'de>> for StructWithNullableUnion {
    #[inline]
    fn from_wire(wire: WireStructWithNullableUnion<'de>) -> Self {
        Self { x1: ::fidl_next::FromWire::from_wire(wire.x1) }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireStructWithNullableUnion<'de>> for StructWithNullableUnion {
    #[inline]
    fn from_wire_ref(wire: &WireStructWithNullableUnion<'de>) -> Self {
        Self { x1: ::fidl_next::FromWireRef::from_wire_ref(&wire.x1) }
    }
}

/// The wire type corresponding to [`StructWithNullableUnion`].
#[derive(Debug)]
#[repr(C)]
pub struct WireStructWithNullableUnion<'de> {
    pub x1: crate::WireOptionalOlderSimpleUnion<'de>,
}

unsafe impl ::fidl_next::Wire for WireStructWithNullableUnion<'static> {
    type Decoded<'de> = WireStructWithNullableUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireStructWithNullableUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut x1,

            } = slot;
        }

        ::fidl_next::Decode::decode(x1.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    pub xu: crate::StrictBoundedUnion,
}

impl ::fidl_next::Encodable for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    type Encoded = WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                xu,

            } = out;
        }

        ::fidl_next::Encode::encode(self.xu, encoder, xu)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                xu,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.xu, encoder, xu)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'de>>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
{
    #[inline]
    fn from_wire(
        wire: WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'de>,
    ) -> Self {
        Self { xu: ::fidl_next::FromWire::from_wire(wire.xu) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<
        WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'de>,
    > for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'de>,
    ) -> Self {
        Self { xu: ::fidl_next::FromWireRef::from_wire_ref(&wire.xu) }
    }
}

/// The wire type corresponding to [`TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'de> {
    pub xu: crate::WireStrictBoundedUnion<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'static>
{
    type Decoded<'de> = WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut xu,

            } = slot;
        }

        ::fidl_next::Decode::decode(xu.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    pub xu: crate::OlderSimpleUnion,
}

impl ::fidl_next::Encodable for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    type Encoded = WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                xu,

            } = out;
        }

        ::fidl_next::Encode::encode(self.xu, encoder, xu)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                xu,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.xu, encoder, xu)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
{
    type EncodedOption = ::fidl_next::WireBox<
        'static,
        WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'static>,
    >;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
where
    ___E: ::fidl_next::Encoder + ?Sized,
    TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de>
    ::fidl_next::FromWire<
        WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'de>,
    > for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
{
    #[inline]
    fn from_wire(
        wire: WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'de>,
    ) -> Self {
        Self { xu: ::fidl_next::FromWire::from_wire(wire.xu) }
    }
}

impl<'de>
    ::fidl_next::FromWireRef<
        WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'de>,
    > for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
{
    #[inline]
    fn from_wire_ref(
        wire: &WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'de>,
    ) -> Self {
        Self { xu: ::fidl_next::FromWireRef::from_wire_ref(&wire.xu) }
    }
}

/// The wire type corresponding to [`TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse`].
#[derive(Debug)]
#[repr(C)]
pub struct WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'de> {
    pub xu: crate::WireOlderSimpleUnion<'de>,
}

unsafe impl ::fidl_next::Wire
    for WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'static>
{
    type Decoded<'de> = WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {}
}

unsafe impl<___D> ::fidl_next::Decode<___D>
    for WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut xu,

            } = slot;
        }

        ::fidl_next::Decode::decode(xu.as_mut(), decoder)?;

        Ok(())
    }
}

/// The type corresponding to the TestProtocol protocol.
#[derive(Debug)]
pub struct TestProtocol;

pub mod test_protocol {
    pub mod prelude {
        pub use crate::{
            test_protocol, TestProtocol, TestProtocolClientHandler, TestProtocolClientSender,
            TestProtocolServerHandler, TestProtocolServerSender,
        };

        pub use crate::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse;

        pub use crate::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse;
    }

    pub struct StrictUnionHenceResponseMayBeStackAllocated;

    impl ::fidl_next::Method for StrictUnionHenceResponseMayBeStackAllocated {
        const ORDINAL: u64 = 6628358876445129155;

        type Protocol = crate::TestProtocol;

        type Request = ();

        type Response =
            crate::WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'static>;
    }

    pub struct FlexibleUnionHenceResponseMustBeHeapAllocated;

    impl ::fidl_next::Method for FlexibleUnionHenceResponseMustBeHeapAllocated {
        const ORDINAL: u64 = 7588545459451501794;

        type Protocol = crate::TestProtocol;

        type Request = ();

        type Response =
            crate::WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'static>;
    }
}

/// A helper trait for the `TestProtocol` client sender.
pub trait TestProtocolClientSender {
    type Transport: ::fidl_next::Transport;

    fn strict_union_hence_response_may_be_stack_allocated(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
        ::fidl_next::EncodeError,
    >;

    fn flexible_union_hence_response_must_be_heap_allocated(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
        ::fidl_next::EncodeError,
    >;
}

impl<___T> TestProtocolClientSender for ::fidl_next::ClientSender<___T, TestProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;

    fn strict_union_hence_response_may_be_stack_allocated(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(6628358876445129155, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }

    fn flexible_union_hence_response_must_be_heap_allocated(
        &self,
    ) -> Result<
        ::fidl_next::ResponseFuture<
            '_,
            Self::Transport,
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
        ::fidl_next::EncodeError,
    > {
        self.as_untyped()
            .send_two_way(7588545459451501794, ())
            .map(::fidl_next::ResponseFuture::from_untyped)
    }
}

/// A client handler for the TestProtocol protocol.
///
/// See [`TestProtocol`] for more details.
pub trait TestProtocolClientHandler<___T: ::fidl_next::Transport> {}

impl<___T, ___H> ::fidl_next::ClientProtocol<___T, ___H> for TestProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: TestProtocolClientHandler<___T>,

    <test_protocol::StrictUnionHenceResponseMayBeStackAllocated as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,

    <test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated as ::fidl_next::Method>::Response:
        ::fidl_next::Decode<<___T as ::fidl_next::Transport>::RecvBuffer>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `TestProtocol` server sender.
pub trait TestProtocolServerSender {
    type Transport: ::fidl_next::Transport;
}

impl<___T> TestProtocolServerSender for ::fidl_next::ServerSender<___T, TestProtocol>
where
    ___T: ::fidl_next::Transport,
{
    type Transport = ___T;
}

/// A server handler for the TestProtocol protocol.
///
/// See [`TestProtocol`] for more details.
pub trait TestProtocolServerHandler<___T: ::fidl_next::Transport> {
    fn strict_union_hence_response_may_be_stack_allocated(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, TestProtocol>,

        responder: ::fidl_next::Responder<
            test_protocol::StrictUnionHenceResponseMayBeStackAllocated,
        >,
    );

    fn flexible_union_hence_response_must_be_heap_allocated(
        &mut self,
        sender: &::fidl_next::ServerSender<___T, TestProtocol>,

        responder: ::fidl_next::Responder<
            test_protocol::FlexibleUnionHenceResponseMustBeHeapAllocated,
        >,
    );
}

impl<___T, ___H> ::fidl_next::ServerProtocol<___T, ___H> for TestProtocol
where
    ___T: ::fidl_next::Transport,
    ___H: TestProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            6628358876445129155 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.strict_union_hence_response_may_be_stack_allocated(sender, responder);
            }

            7588545459451501794 => {
                let responder = ::fidl_next::Responder::from_untyped(responder);

                handler.flexible_union_hence_response_must_be_heap_allocated(sender, responder);
            }

            ordinal => {
                sender.close();
            }
        }
    }
}

#[derive(Clone, Debug)]
pub enum Union {
    Primitive(i32),

    StringNeedsConstructor(String),

    VectorStringAlsoNeedsConstructor(Vec<String>),
}

impl ::fidl_next::Encodable for Union {
    type Encoded = WireUnion<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw, _phantom: _ } = out);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for Union
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnion { raw, _phantom: _ } = out);

        match self {
            Self::Primitive(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i32>(value, 1, encoder, raw)?
            }

            Self::StringNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &String>(value, 2, encoder, raw)?
            }

            Self::VectorStringAlsoNeedsConstructor(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for Union {
    type EncodedOption = WireOptionalUnion<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for Union
where
    ___E: ?Sized,
    Union: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for Union
where
    ___E: ?Sized,
    Union: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnion { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnion<'de>> for Union {
    #[inline]
    fn from_wire(wire: WireUnion<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Primitive(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireString<'de>>()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::FromWire::from_wire(unsafe {
                raw.get()
                    .read_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnion<'de>> for Union {
    #[inline]
    fn from_wire_ref(wire: &WireUnion<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Primitive(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            })),

            2 => Self::StringNeedsConstructor(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireString<'de>>()
            })),

            3 => Self::VectorStringAlsoNeedsConstructor(::fidl_next::FromWireRef::from_wire_ref(
                unsafe {
                    wire.raw.get().deref_unchecked::<::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>>()
                },
            )),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalUnion<'de>> for Box<Union> {
    #[inline]
    fn from_wire_option(wire: WireOptionalUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalUnion<'de>> for Box<Union> {
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalUnion<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`Union`].
#[repr(transparent)]
pub struct WireUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireUnion<'static> {
    type Decoded<'de> = WireUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union {
    pub enum Ref<'de> {
        Primitive(&'de ::fidl_next::WireI32),

        StringNeedsConstructor(&'de ::fidl_next::WireString<'de>),

        VectorStringAlsoNeedsConstructor(
            &'de ::fidl_next::WireVector<'de, ::fidl_next::WireString<'de>>,
        ),
    }
}

impl<'de> WireUnion<'de> {
    pub fn as_ref(&self) -> crate::union::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union::Ref::Primitive(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI32>()
            }),

            2 => crate::union::Ref::StringNeedsConstructor(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>()
            }),

            3 => {
                crate::union::Ref::VectorStringAlsoNeedsConstructor(unsafe {
                    self.raw.get().deref_unchecked::<::fidl_next::WireVector<'_, ::fidl_next::WireString<'_>>>()
                })
            }

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >(raw, decoder)?,

            ord => return Err(::fidl_next::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI32>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireString<'_>>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl_next::WireVector<'_, ::fidl_next::WireString<'_>>>()
                    .fmt(f)
            },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnion<'static> {
    type Decoded<'de> = WireOptionalUnion<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalUnion<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnion<'de>> {
        if self.is_some() {
            Some(WireUnion { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnion<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI32>(raw, decoder)?,

            2 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireString<'static>>(
                raw, decoder,
            )?,

            3 => ::fidl_next::RawWireUnion::decode_as::<
                ___D,
                ::fidl_next::WireVector<'static, ::fidl_next::WireString<'static>>,
            >(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalUnion<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub enum UnionContainingEmptyStruct {
    Empty(crate::Empty),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnionContainingEmptyStruct {
    type Encoded = WireUnionContainingEmptyStruct;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnionContainingEmptyStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionContainingEmptyStruct { raw, _phantom: _ } = out);

        match self {
            Self::Empty(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, crate::Empty>(
                    value, 1, encoder, raw,
                )?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for UnionContainingEmptyStruct
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionContainingEmptyStruct { raw, _phantom: _ } = out);

        match self {
            Self::Empty(value) => {
                ::fidl_next::RawWireUnion::encode_as_static::<___E, &crate::Empty>(
                    value, 1, encoder, raw,
                )?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnionContainingEmptyStruct {
    type EncodedOption = WireOptionalUnionContainingEmptyStruct;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for UnionContainingEmptyStruct
where
    ___E: ?Sized,
    UnionContainingEmptyStruct: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionContainingEmptyStruct { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for UnionContainingEmptyStruct
where
    ___E: ?Sized,
    UnionContainingEmptyStruct: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionContainingEmptyStruct { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl ::fidl_next::FromWire<WireUnionContainingEmptyStruct> for UnionContainingEmptyStruct {
    #[inline]
    fn from_wire(wire: WireUnionContainingEmptyStruct) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::Empty(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<crate::WireEmpty>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireRef<WireUnionContainingEmptyStruct> for UnionContainingEmptyStruct {
    #[inline]
    fn from_wire_ref(wire: &WireUnionContainingEmptyStruct) -> Self {
        match wire.raw.ordinal() {
            1 => Self::Empty(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<crate::WireEmpty>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl ::fidl_next::FromWireOption<WireOptionalUnionContainingEmptyStruct>
    for Box<UnionContainingEmptyStruct>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalUnionContainingEmptyStruct) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl ::fidl_next::FromWireOptionRef<WireOptionalUnionContainingEmptyStruct>
    for Box<UnionContainingEmptyStruct>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalUnionContainingEmptyStruct) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionContainingEmptyStruct`].
#[repr(transparent)]
pub struct WireUnionContainingEmptyStruct {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireUnionContainingEmptyStruct {
    type Decoded<'de> = WireUnionContainingEmptyStruct;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union_containing_empty_struct {
    pub enum Ref<'de> {
        Empty(&'de crate::WireEmpty),

        UnknownOrdinal_(u64),
    }
}

impl WireUnionContainingEmptyStruct {
    pub fn as_ref(&self) -> crate::union_containing_empty_struct::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union_containing_empty_struct::Ref::Empty(unsafe {
                self.raw.get().deref_unchecked::<crate::WireEmpty>()
            }),

            unknown => crate::union_containing_empty_struct::Ref::UnknownOrdinal_(unknown),
        }
    }
}

impl Clone for WireUnionContainingEmptyStruct {
    fn clone(&self) -> Self {
        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<crate::WireEmpty>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionContainingEmptyStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireEmpty>(raw, decoder)?
            }

            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireUnionContainingEmptyStruct {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireEmpty>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionContainingEmptyStruct {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<()>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnionContainingEmptyStruct {
    type Decoded<'de> = WireOptionalUnionContainingEmptyStruct;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl WireOptionalUnionContainingEmptyStruct {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionContainingEmptyStruct> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnionContainingEmptyStruct> {
        if self.is_some() {
            Some(WireUnionContainingEmptyStruct {
                raw: self.raw,
                _phantom: ::core::marker::PhantomData,
            })
        } else {
            None
        }
    }
}

impl Clone for WireOptionalUnionContainingEmptyStruct {
    fn clone(&self) -> Self {
        if self.is_none() {
            return WireOptionalUnionContainingEmptyStruct {
                raw: ::fidl_next::RawWireUnion::absent(),
                _phantom: ::core::marker::PhantomData,
            };
        }

        match self.raw.ordinal() {
            1 => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<crate::WireEmpty>() },
                _phantom: ::core::marker::PhantomData,
            },

            _ => Self {
                raw: unsafe { self.raw.clone_inline_unchecked::<()>() },
                _phantom: ::core::marker::PhantomData,
            },
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnionContainingEmptyStruct
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl_next::RawWireUnion::decode_as_static::<___D, crate::WireEmpty>(raw, decoder)?
            }

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown_static(raw, decoder)?,
        }

        Ok(())
    }
}

impl ::core::fmt::Debug for WireOptionalUnionContainingEmptyStruct {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnionSandwich {
    pub a: u32,

    pub u: crate::ExplicitFlexibleUnion,

    pub b: u32,
}

impl ::fidl_next::Encodable for UnionSandwich {
    type Encoded = WireUnionSandwich<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnionSandwich
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                u,
                b,

            } = out;
        }

        ::fidl_next::Encode::encode(self.a, encoder, a)?;

        ::fidl_next::Encode::encode(self.u, encoder, u)?;

        ::fidl_next::Encode::encode(self.b, encoder, b)?;

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for UnionSandwich
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge! {
            let Self::Encoded {
                a,
                u,
                b,

            } = out;
        }

        ::fidl_next::EncodeRef::encode_ref(&self.a, encoder, a)?;

        ::fidl_next::EncodeRef::encode_ref(&self.u, encoder, u)?;

        ::fidl_next::EncodeRef::encode_ref(&self.b, encoder, b)?;

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnionSandwich {
    type EncodedOption = ::fidl_next::WireBox<'static, WireUnionSandwich<'static>>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for UnionSandwich
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnionSandwich: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for UnionSandwich
where
    ___E: ::fidl_next::Encoder + ?Sized,
    UnionSandwich: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        if let Some(inner) = this {
            ::fidl_next::EncoderExt::encode_next(encoder, inner)?;
            ::fidl_next::WireBox::encode_present(out);
        } else {
            ::fidl_next::WireBox::encode_absent(out);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnionSandwich<'de>> for UnionSandwich {
    #[inline]
    fn from_wire(wire: WireUnionSandwich<'de>) -> Self {
        Self {
            a: ::fidl_next::FromWire::from_wire(wire.a),

            u: ::fidl_next::FromWire::from_wire(wire.u),

            b: ::fidl_next::FromWire::from_wire(wire.b),
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnionSandwich<'de>> for UnionSandwich {
    #[inline]
    fn from_wire_ref(wire: &WireUnionSandwich<'de>) -> Self {
        Self {
            a: ::fidl_next::FromWireRef::from_wire_ref(&wire.a),

            u: ::fidl_next::FromWireRef::from_wire_ref(&wire.u),

            b: ::fidl_next::FromWireRef::from_wire_ref(&wire.b),
        }
    }
}

/// The wire type corresponding to [`UnionSandwich`].
#[derive(Debug)]
#[repr(C)]
pub struct WireUnionSandwich<'de> {
    pub a: ::fidl_next::WireU32,

    pub u: crate::WireExplicitFlexibleUnion<'de>,

    pub b: ::fidl_next::WireU32,
}

unsafe impl ::fidl_next::Wire for WireUnionSandwich<'static> {
    type Decoded<'de> = WireUnionSandwich<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        unsafe {
            out.as_mut_ptr().cast::<u8>().add(28).write_bytes(0, 4);
        }

        unsafe {
            out.as_mut_ptr().cast::<u8>().add(4).write_bytes(0, 4);
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionSandwich<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge! {
            let Self {
                mut a,
                mut u,
                mut b,

            } = slot;
        }

        ::fidl_next::Decode::decode(a.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(u.as_mut(), decoder)?;

        ::fidl_next::Decode::decode(b.as_mut(), decoder)?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum UnionWithAttributes {
    X(i64),

    UnknownOrdinal_(u64),
}

impl ::fidl_next::Encodable for UnionWithAttributes {
    type Encoded = WireUnionWithAttributes<'static>;
}

unsafe impl<___E> ::fidl_next::Encode<___E> for UnionWithAttributes
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode(
        self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionWithAttributes { raw, _phantom: _ } = out);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(ordinal as usize))
            }
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeRef<___E> for UnionWithAttributes
where
    ___E: ::fidl_next::encoder::InternalHandleEncoder + ?Sized,

    ___E: ::fidl_next::Encoder,
{
    #[inline]
    fn encode_ref(
        &self,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::Encoded>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireUnionWithAttributes { raw, _phantom: _ } = out);

        match self {
            Self::X(value) => {
                ::fidl_next::RawWireUnion::encode_as::<___E, &i64>(value, 1, encoder, raw)?
            }

            Self::UnknownOrdinal_(ordinal) => {
                return Err(::fidl_next::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl_next::EncodableOption for UnionWithAttributes {
    type EncodedOption = WireOptionalUnionWithAttributes<'static>;
}

unsafe impl<___E> ::fidl_next::EncodeOption<___E> for UnionWithAttributes
where
    ___E: ?Sized,
    UnionWithAttributes: ::fidl_next::Encode<___E>,
{
    #[inline]
    fn encode_option(
        this: Option<Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionWithAttributes { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::Encode::encode(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

unsafe impl<___E> ::fidl_next::EncodeOptionRef<___E> for UnionWithAttributes
where
    ___E: ?Sized,
    UnionWithAttributes: ::fidl_next::EncodeRef<___E>,
{
    #[inline]
    fn encode_option_ref(
        this: Option<&Self>,
        encoder: &mut ___E,
        out: &mut ::core::mem::MaybeUninit<Self::EncodedOption>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let WireOptionalUnionWithAttributes { raw, _phantom: _ } = &mut *out);

        if let Some(inner) = this {
            let value_out = unsafe { &mut *out.as_mut_ptr().cast() };
            ::fidl_next::EncodeRef::encode_ref(inner, encoder, value_out)?;
        } else {
            ::fidl_next::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'de> ::fidl_next::FromWire<WireUnionWithAttributes<'de>> for UnionWithAttributes {
    #[inline]
    fn from_wire(wire: WireUnionWithAttributes<'de>) -> Self {
        let raw = ::core::mem::ManuallyDrop::new(wire.raw);
        match raw.ordinal() {
            1 => Self::X(::fidl_next::FromWire::from_wire(unsafe {
                raw.get().read_unchecked::<::fidl_next::WireI64>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireRef<WireUnionWithAttributes<'de>> for UnionWithAttributes {
    #[inline]
    fn from_wire_ref(wire: &WireUnionWithAttributes<'de>) -> Self {
        match wire.raw.ordinal() {
            1 => Self::X(::fidl_next::FromWireRef::from_wire_ref(unsafe {
                wire.raw.get().deref_unchecked::<::fidl_next::WireI64>()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'de> ::fidl_next::FromWireOption<WireOptionalUnionWithAttributes<'de>>
    for Box<UnionWithAttributes>
{
    #[inline]
    fn from_wire_option(wire: WireOptionalUnionWithAttributes<'de>) -> Option<Self> {
        if let Some(inner) = wire.into_option() {
            Some(Box::new(::fidl_next::FromWire::from_wire(inner)))
        } else {
            None
        }
    }
}

impl<'de> ::fidl_next::FromWireOptionRef<WireOptionalUnionWithAttributes<'de>>
    for Box<UnionWithAttributes>
{
    #[inline]
    fn from_wire_option_ref(wire: &WireOptionalUnionWithAttributes<'de>) -> Option<Self> {
        if let Some(inner) = wire.as_ref() {
            Some(Box::new(::fidl_next::FromWireRef::from_wire_ref(inner)))
        } else {
            None
        }
    }
}

/// The wire type corresponding to [`UnionWithAttributes`].
#[repr(transparent)]
pub struct WireUnionWithAttributes<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireUnionWithAttributes<'static> {
    type Decoded<'de> = WireUnionWithAttributes<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

pub mod union_with_attributes {
    pub enum Ref<'de> {
        X(&'de ::fidl_next::WireI64),

        UnknownOrdinal_(u64),
    }
}

impl<'de> WireUnionWithAttributes<'de> {
    pub fn as_ref(&self) -> crate::union_with_attributes::Ref<'_> {
        match self.raw.ordinal() {
            1 => crate::union_with_attributes::Ref::X(unsafe {
                self.raw.get().deref_unchecked::<::fidl_next::WireI64>()
            }),

            unknown => crate::union_with_attributes::Ref::UnknownOrdinal_(unknown),
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireUnionWithAttributes<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireUnionWithAttributes<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl_next::WireI64>().fmt(f) },
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionWithAttributes<'de> {
    raw: ::fidl_next::RawWireUnion,
    _phantom: ::core::marker::PhantomData<&'de mut [::fidl_next::Chunk]>,
}

unsafe impl ::fidl_next::Wire for WireOptionalUnionWithAttributes<'static> {
    type Decoded<'de> = WireOptionalUnionWithAttributes<'de>;

    #[inline]
    fn zero_padding(out: &mut ::core::mem::MaybeUninit<Self>) {
        ::fidl_next::munge!(let Self { raw, _phantom: _ } = out);
        ::fidl_next::RawWireUnion::zero_padding(raw);
    }
}

impl<'de> WireOptionalUnionWithAttributes<'de> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionWithAttributes<'de>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn into_option(self) -> Option<WireUnionWithAttributes<'de>> {
        if self.is_some() {
            Some(WireUnionWithAttributes { raw: self.raw, _phantom: ::core::marker::PhantomData })
        } else {
            None
        }
    }
}

unsafe impl<___D> ::fidl_next::Decode<___D> for WireOptionalUnionWithAttributes<'static>
where
    ___D: ::fidl_next::decoder::InternalHandleDecoder + ?Sized,

    ___D: ::fidl_next::Decoder,
{
    fn decode(
        mut slot: ::fidl_next::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        ::fidl_next::munge!(let Self { mut raw, _phantom: _ } = slot.as_mut());
        match ::fidl_next::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl_next::RawWireUnion::decode_as::<___D, ::fidl_next::WireI64>(raw, decoder)?,

            0 => ::fidl_next::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl_next::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'de> ::core::fmt::Debug for WireOptionalUnionWithAttributes<'de> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

/// Compatibility shims which mimic some API surfaces of the current Rust bindings.
pub mod compat {

    #[cfg(target_os = "fuchsia")]
    /// An alias for a client sender over `zx::Channel` for the `TestProtocol`
    /// protocol.
    pub type TestProtocolProxy =
        ::fidl_next::ClientSender<::fidl_next::fuchsia::zx::Channel, crate::TestProtocol>;

    impl ::core::convert::From<crate::TestProtocol> for ::fidl_test_union::TestProtocolMarker {
        #[inline]
        fn from(_: crate::TestProtocol) -> Self {
            Self
        }
    }
}
