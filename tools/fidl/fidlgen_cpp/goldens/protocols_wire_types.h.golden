// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <lib/fidl/cpp/wire/array.h>
#include <lib/fidl/cpp/wire/envelope.h>
#include <lib/fidl/cpp/wire/internal/framework_err.h>
#include <lib/fidl/cpp/wire/message.h>
#include <lib/fidl/cpp/wire/message_storage.h>
#include <lib/fidl/cpp/wire/object_view.h>
#include <lib/fidl/cpp/wire/string_view.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/fidl/cpp/wire/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/socket.h>

#endif  // __Fuchsia__

#include <fidl/test.protocols/cpp/common_types.h>
#include <fidl/test.protocols/cpp/markers.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_protocols {

namespace wire {
using ErrorEnum = ::test_protocols::ErrorEnum;

struct WithAndWithoutRequestResponseNoRequestWithResponseResponse;

struct WithAndWithoutRequestResponseWithRequestNoResponseRequest;

struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

struct WithAndWithoutRequestResponseWithRequestWithResponseRequest;

struct WithAndWithoutRequestResponseWithRequestWithResponseResponse;

struct WithAndWithoutRequestResponseOnWithResponseRequest;

struct WithErrorSyntaxResponseAsStructResponse;

struct WithErrorSyntaxErrorAsPrimitiveResponse;

struct WithErrorSyntaxErrorAsEnumResponse;

struct WithErrorSyntaxHandleInResultResponse;

struct ChannelProtocolMethodARequest;

struct ChannelProtocolEventARequest;

struct ChannelProtocolMethodBRequest;

struct ChannelProtocolMethodBResponse;

struct ChannelProtocolTakeHandleRequest;

struct ChannelProtocolMutateSocketRequest;

struct ChannelProtocolMutateSocketResponse;

struct SyscallProtocolMethodCRequest;

struct HandleRightsProtocolNoResponseMethodRequest;

struct HandleRightsProtocolResponseMethodRequest;

struct HandleRightsProtocolResponseMethodResponse;

struct HandleRightsProtocolAnEventRequest;

struct ProtocolEnds;

struct WithProtocolEndsClientEndsRequest;

struct WithProtocolEndsClientEndsResponse;

struct WithProtocolEndsServerEndsRequest;

struct WithProtocolEndsServerEndsResponse;

struct WithProtocolEndsStructContainingEndsRequest;

struct WithProtocolEndsStructContainingEndsResponse;

struct ManyParametersFifteenRequest;

struct MethodWithUnionUnionMethodRequest;

struct MethodWithUnionUnionMethodResponse;

class WithErrorSyntaxResponseAsStructResult;

class WithErrorSyntaxErrorAsPrimitiveResult;

class WithErrorSyntaxErrorAsEnumResult;

class WithErrorSyntaxHandleInResultResult;

class TheUnion;

struct WithErrorSyntaxErrorAsPrimitiveResponse {
  uint8_t __reserved = {};
};

struct WithErrorSyntaxErrorAsEnumResponse {
  uint8_t __reserved = {};
};

#ifdef __Fuchsia__

struct WithErrorSyntaxHandleInResultResponse {
  ::zx::handle h = {};

  void _CloseHandles();
};

struct ChannelProtocolTakeHandleRequest {
  ::zx::handle h = {};

  void _CloseHandles();
};

struct ChannelProtocolMutateSocketRequest {
  ::zx::socket a = {};

  void _CloseHandles();
};

struct ChannelProtocolMutateSocketResponse {
  ::zx::socket b = {};

  void _CloseHandles();
};

struct HandleRightsProtocolNoResponseMethodRequest {
  ::zx::socket h = {};

  void _CloseHandles();
};

struct HandleRightsProtocolResponseMethodRequest {
  ::zx::socket h = {};

  void _CloseHandles();
};

struct HandleRightsProtocolResponseMethodResponse {
  ::zx::socket h = {};

  void _CloseHandles();
};

struct HandleRightsProtocolAnEventRequest {
  ::zx::socket h = {};

  void _CloseHandles();
};

struct WithProtocolEndsClientEndsRequest {
  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in = {};

  void _CloseHandles();
};

struct WithProtocolEndsClientEndsResponse {
  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out = {};

  void _CloseHandles();
};

struct WithProtocolEndsServerEndsRequest {
  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in = {};

  void _CloseHandles();
};

struct WithProtocolEndsServerEndsResponse {
  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

class WithErrorSyntaxResponseAsStructResult {
 public:
  using Response = test_protocols::wire::WithErrorSyntaxResponseAsStructResponse;

  WithErrorSyntaxResponseAsStructResult();

  WithErrorSyntaxResponseAsStructResult(const WithErrorSyntaxResponseAsStructResult&) = default;
  WithErrorSyntaxResponseAsStructResult& operator=(const WithErrorSyntaxResponseAsStructResult&) = default;
  WithErrorSyntaxResponseAsStructResult(WithErrorSyntaxResponseAsStructResult&&) = default;
  WithErrorSyntaxResponseAsStructResult& operator=(WithErrorSyntaxResponseAsStructResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static WithErrorSyntaxResponseAsStructResult WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> val);

  template <typename... Args>
  static WithErrorSyntaxResponseAsStructResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>(allocator,
                                                                                                            std::forward<Args>(args)...));
  }

  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse& response();

  const ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse& response() const;

  bool is_err() const;

  static WithErrorSyntaxResponseAsStructResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class WithErrorSyntaxErrorAsPrimitiveResult {
 public:
  using Response = test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse;

  WithErrorSyntaxErrorAsPrimitiveResult();

  WithErrorSyntaxErrorAsPrimitiveResult(const WithErrorSyntaxErrorAsPrimitiveResult&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(const WithErrorSyntaxErrorAsPrimitiveResult&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult(WithErrorSyntaxErrorAsPrimitiveResult&&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(WithErrorSyntaxErrorAsPrimitiveResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static WithErrorSyntaxErrorAsPrimitiveResult WithResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse val);

  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse& response();

  const ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse& response() const;

  bool is_err() const;

  static WithErrorSyntaxErrorAsPrimitiveResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class WithErrorSyntaxErrorAsEnumResult {
 public:
  using Response = test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse;

  WithErrorSyntaxErrorAsEnumResult();

  WithErrorSyntaxErrorAsEnumResult(const WithErrorSyntaxErrorAsEnumResult&) = default;
  WithErrorSyntaxErrorAsEnumResult& operator=(const WithErrorSyntaxErrorAsEnumResult&) = default;
  WithErrorSyntaxErrorAsEnumResult(WithErrorSyntaxErrorAsEnumResult&&) = default;
  WithErrorSyntaxErrorAsEnumResult& operator=(WithErrorSyntaxErrorAsEnumResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static WithErrorSyntaxErrorAsEnumResult WithResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse val);

  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse& response();

  const ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse& response() const;

  bool is_err() const;

  static WithErrorSyntaxErrorAsEnumResult WithErr(::test_protocols::wire::ErrorEnum val);

  ::test_protocols::wire::ErrorEnum& err();

  const ::test_protocols::wire::ErrorEnum& err() const;

  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#ifdef __Fuchsia__

class WithErrorSyntaxHandleInResultResult {
 public:
  using Response = test_protocols::wire::WithErrorSyntaxHandleInResultResponse;

  WithErrorSyntaxHandleInResultResult();

  ~WithErrorSyntaxHandleInResultResult();
  WithErrorSyntaxHandleInResultResult(WithErrorSyntaxHandleInResultResult&& other);
  WithErrorSyntaxHandleInResultResult& operator=(WithErrorSyntaxHandleInResultResult&& other);

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static WithErrorSyntaxHandleInResultResult WithResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultResponse val);

  ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse& response();

  const ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse& response() const;

  bool is_err() const;

  static WithErrorSyntaxHandleInResultResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag Which() const;
  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };
  void _Move(WithErrorSyntaxHandleInResultResult&& other);

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#endif  // __Fuchsia__

class TheUnion {
 public:
  TheUnion();

  TheUnion(const TheUnion&) = default;
  TheUnion& operator=(const TheUnion&) = default;
  TheUnion(TheUnion&&) = default;
  TheUnion& operator=(TheUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocols::wire::TheUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_v() const;

  static TheUnion WithV(uint32_t val);

  uint32_t& v();

  const uint32_t& v() const;

  ::test_protocols::wire::TheUnion::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kV = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocols::wire::TheUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

struct WithAndWithoutRequestResponseNoRequestWithResponseResponse {
  ::fidl::StringView ret = {};
};

struct WithAndWithoutRequestResponseWithRequestNoResponseRequest {
  ::fidl::StringView arg = {};
};

struct WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
  ::fidl::StringView arg = {};
};

struct WithAndWithoutRequestResponseWithRequestWithResponseRequest {
  ::fidl::StringView arg = {};
};

struct WithAndWithoutRequestResponseWithRequestWithResponseResponse {
  ::fidl::StringView ret = {};
};

struct WithAndWithoutRequestResponseOnWithResponseRequest {
  ::fidl::StringView ret = {};
};

struct WithErrorSyntaxResponseAsStructResponse {
  int64_t a = {};

  int64_t b = {};

  int64_t c = {};
};

struct ChannelProtocolMethodARequest {
  int64_t a = {};

  int64_t b = {};
};

struct ChannelProtocolEventARequest {
  int64_t a = {};

  int64_t b = {};
};

struct ChannelProtocolMethodBRequest {
  int64_t a = {};

  int64_t b = {};
};

struct ChannelProtocolMethodBResponse {
  int64_t result = {};
};

struct SyscallProtocolMethodCRequest {
  int64_t a = {};

  int64_t b = {};
};

#ifdef __Fuchsia__

struct ProtocolEnds {
  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client = {};

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server = {};

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt = {};

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server_opt = {};

  void _CloseHandles();
};

struct WithProtocolEndsStructContainingEndsRequest {
  ::test_protocols::wire::ProtocolEnds in = {};

  void _CloseHandles();
};

struct WithProtocolEndsStructContainingEndsResponse {
  ::test_protocols::wire::ProtocolEnds out = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

struct ManyParametersFifteenRequest {
  bool p1 = {};

  bool p2 = {};

  bool p3 = {};

  bool p4 = {};

  bool p5 = {};

  bool p6 = {};

  bool p7 = {};

  bool p8 = {};

  bool p9 = {};

  bool p10 = {};

  bool p11 = {};

  bool p12 = {};

  bool p13 = {};

  bool p14 = {};

  bool p15 = {};
};

struct MethodWithUnionUnionMethodRequest {
  ::test_protocols::wire::TheUnion u = {};
};

struct MethodWithUnionUnionMethodResponse {
  ::fidl::WireOptional<::test_protocols::wire::TheUnion> u = {};
};

}  // namespace wire
}  // namespace test_protocols
namespace fidl {

template <bool IsRecursive>
struct internal::WireCodingTraits<::test_protocols::wire::ErrorEnum, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = sizeof(uint32_t);
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::ErrorEnum* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 24;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithErrorSyntaxHandleInResultResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodARequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodARequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ChannelProtocolMethodARequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodARequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMethodARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMethodARequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolEventARequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolEventARequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ChannelProtocolEventARequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolEventARequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolEventARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolEventARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolEventARequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodBRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodBRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ChannelProtocolMethodBRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodBRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMethodBRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMethodBRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMethodBResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMethodBResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ChannelProtocolMethodBResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMethodBResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMethodBResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMethodBResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::ChannelProtocolTakeHandleRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolTakeHandleRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ChannelProtocolTakeHandleRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolTakeHandleRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolTakeHandleRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolTakeHandleRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::ChannelProtocolMutateSocketRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMutateSocketRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ChannelProtocolMutateSocketRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMutateSocketRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMutateSocketRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMutateSocketRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::ChannelProtocolMutateSocketResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ChannelProtocolMutateSocketResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ChannelProtocolMutateSocketResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ChannelProtocolMutateSocketResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x80000000, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ChannelProtocolMutateSocketResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ChannelProtocolMutateSocketResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_protocols::wire::SyscallProtocolMethodCRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::SyscallProtocolMethodCRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::SyscallProtocolMethodCRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::SyscallProtocolMethodCRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::SyscallProtocolMethodCRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::SyscallProtocolMethodCRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::SyscallProtocolMethodCRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x2, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::HandleRightsProtocolResponseMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::HandleRightsProtocolResponseMethodResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::HandleRightsProtocolAnEventRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::HandleRightsProtocolAnEventRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::HandleRightsProtocolAnEventRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::HandleRightsProtocolAnEventRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::socket, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET, 0x3, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::HandleRightsProtocolAnEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::HandleRightsProtocolAnEventRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::ProtocolEnds> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::ProtocolEnds> {
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ProtocolEnds> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ProtocolEnds> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ProtocolEnds> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ProtocolEnds, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ProtocolEnds, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ProtocolEnds* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsClientEndsRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsClientEndsRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithProtocolEndsClientEndsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsClientEndsRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsClientEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsClientEndsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsClientEndsResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsClientEndsResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithProtocolEndsClientEndsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsClientEndsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsClientEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsClientEndsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsServerEndsRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsServerEndsRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithProtocolEndsServerEndsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsServerEndsRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsServerEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsServerEndsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsServerEndsResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsServerEndsResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithProtocolEndsServerEndsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsServerEndsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsServerEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsServerEndsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> {
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::ProtocolEnds, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct IsResource<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> {
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::ProtocolEnds, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::WithProtocolEndsStructContainingEndsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_protocols::wire::ManyParametersFifteenRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 15;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocols::wire::ManyParametersFifteenRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::ManyParametersFifteenRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::ManyParametersFifteenRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::ManyParametersFifteenRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 15;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<bool, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::ManyParametersFifteenRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::ManyParametersFifteenRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::MethodWithUnionUnionMethodRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::MethodWithUnionUnionMethodRequest> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::MethodWithUnionUnionMethodRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_protocols::wire::TheUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::MethodWithUnionUnionMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::MethodWithUnionUnionMethodRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::MethodWithUnionUnionMethodResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::MethodWithUnionUnionMethodResponse> : public std::true_type {};
template <>
struct IsStruct<::test_protocols::wire::MethodWithUnionUnionMethodResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_protocols::wire::TheUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_protocols::wire::MethodWithUnionUnionMethodResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_protocols::wire::MethodWithUnionUnionMethodResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> : public std::true_type {};

template <>
struct TypeTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> {
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::WithErrorSyntaxHandleInResultResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::WithErrorSyntaxHandleInResultResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_protocols::wire::TheUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocols::wire::TheUnion> : public std::true_type {};
template <>
struct IsWire<::test_protocols::wire::TheUnion> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::wire::TheUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::TheUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocols::wire::TheUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocols::wire::TheUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocols::wire::TheUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#pragma clang diagnostic pop

}  // namespace fidl
