// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <lib/fidl/cpp/wire/array.h>
#include <lib/fidl/cpp/wire/envelope.h>
#include <lib/fidl/cpp/wire/internal/framework_err.h>
#include <lib/fidl/cpp/wire/message.h>
#include <lib/fidl/cpp/wire/message_storage.h>
#include <lib/fidl/cpp/wire/object_view.h>
#include <lib/fidl/cpp/wire/string_view.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/fidl/cpp/wire/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/vmo.h>

#endif  // __Fuchsia__

#include <fidl/test.typesinprotocols/cpp/common_types.h>
#include <fidl/test.typesinprotocols/cpp/markers.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_typesinprotocols {

namespace wire {
using Bits = ::test_typesinprotocols::Bits;

using Enum = ::test_typesinprotocols::Enum;

struct Struct;

struct ResourceStruct;

struct Basic;

struct Compound;

struct ArrayBasic;

struct ArrayCompound;

struct VectorBasic;

struct VectorCompound;

struct VectorOptional;

struct ArrayVectorNested;

struct Resource;

class Table;

class ResourceTable;

class Union;

class ResourceUnion;

class ProtocolErrorBasicResult;

class ProtocolErrorCompoundResult;

class ProtocolErrorArrayBasicResult;

class ProtocolErrorArrayCompoundResult;

class ProtocolErrorVectorBasicResult;

class ProtocolErrorVectorCompoundResult;

class ProtocolErrorVectorOptionalResult;

class ProtocolErrorArrayVectorNestedResult;

class ProtocolErrorResourceResult;

struct Struct {
  uint8_t __reserved = {};
};

#ifdef __Fuchsia__

struct ResourceStruct {
  uint8_t __reserved = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

}  // namespace wire
}  // namespace test_typesinprotocols

template <>
class ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>;
template <>
class ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>;

template <>
struct ::fidl::WireTableFrame<::test_typesinprotocols::wire::Table> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;

  friend class ::test_typesinprotocols::wire::Table;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>>;
};

namespace test_typesinprotocols {
namespace wire {

class Table {
 public:
  Table() = default;
  Table(const Table& other) noexcept = default;
  Table& operator=(const Table& other) noexcept = default;
  Table(Table&& other) noexcept = default;
  Table& operator=(Table&& other) noexcept = default;

  ~Table() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>> frame);
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  explicit Table(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit Table(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_typesinprotocols

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_typesinprotocols::wire::Table Build();

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>>&& frame);

 private:
  ::test_typesinprotocols::wire::Table table_;
};

template <>
class ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table> final : public ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::Table>>;

 public:
 private:
  friend class ::test_typesinprotocols::wire::Table;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table> final : public ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::Table, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::Table>>;

 private:
  friend class ::test_typesinprotocols::wire::Table;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_typesinprotocols::wire::Table>* frame);
};
namespace test_typesinprotocols {
namespace wire {

#ifdef __Fuchsia__

}  // namespace wire
}  // namespace test_typesinprotocols

template <>
class ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>;
template <>
class ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>;

template <>
struct ::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;

  friend class ::test_typesinprotocols::wire::ResourceTable;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>>;
};

namespace test_typesinprotocols {
namespace wire {

class ResourceTable {
 public:
  ResourceTable() = default;
  ResourceTable(const ResourceTable& other) noexcept = default;
  ResourceTable& operator=(const ResourceTable& other) noexcept = default;
  ResourceTable(ResourceTable&& other) noexcept = default;
  ResourceTable& operator=(ResourceTable&& other) noexcept = default;

  ~ResourceTable() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;
  void _CloseHandles();

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>> frame);
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  explicit ResourceTable(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit ResourceTable(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_typesinprotocols

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_typesinprotocols::wire::ResourceTable Build();

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>>&& frame);

 private:
  ::test_typesinprotocols::wire::ResourceTable table_;
};

template <>
class ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableBuilder<::test_typesinprotocols::wire::ResourceTable>>;

 public:
 private:
  friend class ::test_typesinprotocols::wire::ResourceTable;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable> final : public ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_typesinprotocols::wire::ResourceTable, ::fidl::WireTableExternalBuilder<::test_typesinprotocols::wire::ResourceTable>>;

 private:
  friend class ::test_typesinprotocols::wire::ResourceTable;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_typesinprotocols::wire::ResourceTable>* frame);
};
namespace test_typesinprotocols {
namespace wire {

#endif  // __Fuchsia__

class Union {
 public:
  Union();

  Union(const Union&) = default;
  Union& operator=(const Union&) = default;
  Union(Union&&) = default;
  Union& operator=(Union&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_typesinprotocols::wire::Union::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static Union WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_typesinprotocols::wire::Union::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::Union::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#ifdef __Fuchsia__

class ResourceUnion {
 public:
  ResourceUnion();

  ~ResourceUnion();
  ResourceUnion(ResourceUnion&& other);
  ResourceUnion& operator=(ResourceUnion&& other);

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  bool IsUnknown() const {
    return Which() == ::test_typesinprotocols::wire::ResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static ResourceUnion WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_typesinprotocols::wire::ResourceUnion::Tag Which() const;
  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };
  void _Move(ResourceUnion&& other);

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ResourceUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#endif  // __Fuchsia__

class ProtocolErrorBasicResult {
 public:
  ProtocolErrorBasicResult();

  ProtocolErrorBasicResult(const ProtocolErrorBasicResult&) = default;
  ProtocolErrorBasicResult& operator=(const ProtocolErrorBasicResult&) = default;
  ProtocolErrorBasicResult(ProtocolErrorBasicResult&&) = default;
  ProtocolErrorBasicResult& operator=(ProtocolErrorBasicResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorBasicResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic> val);

  template <typename... Args>
  static ProtocolErrorBasicResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic>(allocator,
                                                                                 std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::Basic& response();

  const ::test_typesinprotocols::wire::Basic& response() const;

  bool is_err() const;

  static ProtocolErrorBasicResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorBasicResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ProtocolErrorCompoundResult {
 public:
  ProtocolErrorCompoundResult();

  ProtocolErrorCompoundResult(const ProtocolErrorCompoundResult&) = default;
  ProtocolErrorCompoundResult& operator=(const ProtocolErrorCompoundResult&) = default;
  ProtocolErrorCompoundResult(ProtocolErrorCompoundResult&&) = default;
  ProtocolErrorCompoundResult& operator=(ProtocolErrorCompoundResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorCompoundResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound> val);

  template <typename... Args>
  static ProtocolErrorCompoundResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound>(allocator,
                                                                                    std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::Compound& response();

  const ::test_typesinprotocols::wire::Compound& response() const;

  bool is_err() const;

  static ProtocolErrorCompoundResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorCompoundResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ProtocolErrorArrayBasicResult {
 public:
  ProtocolErrorArrayBasicResult();

  ProtocolErrorArrayBasicResult(const ProtocolErrorArrayBasicResult&) = default;
  ProtocolErrorArrayBasicResult& operator=(const ProtocolErrorArrayBasicResult&) = default;
  ProtocolErrorArrayBasicResult(ProtocolErrorArrayBasicResult&&) = default;
  ProtocolErrorArrayBasicResult& operator=(ProtocolErrorArrayBasicResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorArrayBasicResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic> val);

  template <typename... Args>
  static ProtocolErrorArrayBasicResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic>(allocator,
                                                                                      std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::ArrayBasic& response();

  const ::test_typesinprotocols::wire::ArrayBasic& response() const;

  bool is_err() const;

  static ProtocolErrorArrayBasicResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ProtocolErrorArrayCompoundResult {
 public:
  ProtocolErrorArrayCompoundResult();

  ProtocolErrorArrayCompoundResult(const ProtocolErrorArrayCompoundResult&) = default;
  ProtocolErrorArrayCompoundResult& operator=(const ProtocolErrorArrayCompoundResult&) = default;
  ProtocolErrorArrayCompoundResult(ProtocolErrorArrayCompoundResult&&) = default;
  ProtocolErrorArrayCompoundResult& operator=(ProtocolErrorArrayCompoundResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorArrayCompoundResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound> val);

  template <typename... Args>
  static ProtocolErrorArrayCompoundResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound>(allocator,
                                                                                         std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::ArrayCompound& response();

  const ::test_typesinprotocols::wire::ArrayCompound& response() const;

  bool is_err() const;

  static ProtocolErrorArrayCompoundResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ProtocolErrorVectorBasicResult {
 public:
  ProtocolErrorVectorBasicResult();

  ProtocolErrorVectorBasicResult(const ProtocolErrorVectorBasicResult&) = default;
  ProtocolErrorVectorBasicResult& operator=(const ProtocolErrorVectorBasicResult&) = default;
  ProtocolErrorVectorBasicResult(ProtocolErrorVectorBasicResult&&) = default;
  ProtocolErrorVectorBasicResult& operator=(ProtocolErrorVectorBasicResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorVectorBasicResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic> val);

  template <typename... Args>
  static ProtocolErrorVectorBasicResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic>(allocator,
                                                                                       std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::VectorBasic& response();

  const ::test_typesinprotocols::wire::VectorBasic& response() const;

  bool is_err() const;

  static ProtocolErrorVectorBasicResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ProtocolErrorVectorCompoundResult {
 public:
  ProtocolErrorVectorCompoundResult();

  ProtocolErrorVectorCompoundResult(const ProtocolErrorVectorCompoundResult&) = default;
  ProtocolErrorVectorCompoundResult& operator=(const ProtocolErrorVectorCompoundResult&) = default;
  ProtocolErrorVectorCompoundResult(ProtocolErrorVectorCompoundResult&&) = default;
  ProtocolErrorVectorCompoundResult& operator=(ProtocolErrorVectorCompoundResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorVectorCompoundResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound> val);

  template <typename... Args>
  static ProtocolErrorVectorCompoundResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound>(allocator,
                                                                                          std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::VectorCompound& response();

  const ::test_typesinprotocols::wire::VectorCompound& response() const;

  bool is_err() const;

  static ProtocolErrorVectorCompoundResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ProtocolErrorVectorOptionalResult {
 public:
  ProtocolErrorVectorOptionalResult();

  ProtocolErrorVectorOptionalResult(const ProtocolErrorVectorOptionalResult&) = default;
  ProtocolErrorVectorOptionalResult& operator=(const ProtocolErrorVectorOptionalResult&) = default;
  ProtocolErrorVectorOptionalResult(ProtocolErrorVectorOptionalResult&&) = default;
  ProtocolErrorVectorOptionalResult& operator=(ProtocolErrorVectorOptionalResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorVectorOptionalResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional> val);

  template <typename... Args>
  static ProtocolErrorVectorOptionalResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional>(allocator,
                                                                                          std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::VectorOptional& response();

  const ::test_typesinprotocols::wire::VectorOptional& response() const;

  bool is_err() const;

  static ProtocolErrorVectorOptionalResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ProtocolErrorArrayVectorNestedResult {
 public:
  ProtocolErrorArrayVectorNestedResult();

  ProtocolErrorArrayVectorNestedResult(const ProtocolErrorArrayVectorNestedResult&) = default;
  ProtocolErrorArrayVectorNestedResult& operator=(const ProtocolErrorArrayVectorNestedResult&) = default;
  ProtocolErrorArrayVectorNestedResult(ProtocolErrorArrayVectorNestedResult&&) = default;
  ProtocolErrorArrayVectorNestedResult& operator=(ProtocolErrorArrayVectorNestedResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorArrayVectorNestedResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested> val);

  template <typename... Args>
  static ProtocolErrorArrayVectorNestedResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested>(allocator,
                                                                                             std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::ArrayVectorNested& response();

  const ::test_typesinprotocols::wire::ArrayVectorNested& response() const;

  bool is_err() const;

  static ProtocolErrorArrayVectorNestedResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#ifdef __Fuchsia__

class ProtocolErrorResourceResult {
 public:
  ProtocolErrorResourceResult();

  ~ProtocolErrorResourceResult();
  ProtocolErrorResourceResult(ProtocolErrorResourceResult&& other);
  ProtocolErrorResourceResult& operator=(ProtocolErrorResourceResult&& other);

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static ProtocolErrorResourceResult WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource> val);

  template <typename... Args>
  static ProtocolErrorResourceResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource>(allocator,
                                                                                    std::forward<Args>(args)...));
  }

  ::test_typesinprotocols::wire::Resource& response();

  const ::test_typesinprotocols::wire::Resource& response() const;

  bool is_err() const;

  static ProtocolErrorResourceResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Tag Which() const;
  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };
  void _Move(ProtocolErrorResourceResult&& other);

  static void SizeAndOffsetAssertionHelper();
  ::test_typesinprotocols::wire::ProtocolErrorResourceResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

#endif  // __Fuchsia__

struct Basic {
  uint8_t uint8 = {};

  uint16_t uint16 = {};

  uint32_t uint32 = {};

  uint64_t uint64 = {};

  int8_t int8 = {};

  int16_t int16 = {};

  int32_t int32 = {};

  int64_t int64 = {};

  float float32 = {};

  double float64 = {};

  ::fidl::StringView string = {};

  ::fidl::StringView opt_string = {};
};

struct Compound {
  ::test_typesinprotocols::wire::Bits bits = {};

  ::test_typesinprotocols::wire::Enum enum_ = {};

  ::test_typesinprotocols::wire::Struct struct_ = {};

  ::test_typesinprotocols::wire::Table table = {};

  ::test_typesinprotocols::wire::Union union_ = {};

  ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct = {};

  ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union = {};
};

struct ArrayBasic {
  ::fidl::Array<uint8_t, 5> array_uint8 = {};

  ::fidl::Array<uint16_t, 5> array_uint16 = {};

  ::fidl::Array<uint32_t, 5> array_uint32 = {};

  ::fidl::Array<uint64_t, 5> array_uint64 = {};

  ::fidl::Array<int8_t, 5> array_int8 = {};

  ::fidl::Array<int16_t, 5> array_int16 = {};

  ::fidl::Array<int32_t, 5> array_int32 = {};

  ::fidl::Array<int64_t, 5> array_int64 = {};

  ::fidl::Array<float, 5> array_float32 = {};

  ::fidl::Array<double, 5> array_float64 = {};

  ::fidl::Array<::fidl::StringView, 5> array_string = {};

  ::fidl::Array<::fidl::StringView, 5> array_opt_string = {};
};

struct ArrayCompound {
  ::fidl::Array<::test_typesinprotocols::wire::Bits, 5> array_bits = {};

  ::fidl::Array<::test_typesinprotocols::wire::Enum, 5> array_enum = {};

  ::fidl::Array<::test_typesinprotocols::wire::Struct, 5> array_struct = {};

  ::fidl::Array<::test_typesinprotocols::wire::Table, 5> array_table = {};

  ::fidl::Array<::test_typesinprotocols::wire::Union, 5> array_union = {};

  ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5> array_opt_struct = {};

  ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5> array_opt_union = {};
};

struct VectorBasic {
  ::fidl::VectorView<uint8_t> vector_uint8 = {};

  ::fidl::VectorView<uint16_t> vector_uint16 = {};

  ::fidl::VectorView<uint32_t> vector_uint32 = {};

  ::fidl::VectorView<uint64_t> vector_uint64 = {};

  ::fidl::VectorView<int8_t> vector_int8 = {};

  ::fidl::VectorView<int16_t> vector_int16 = {};

  ::fidl::VectorView<int32_t> vector_int32 = {};

  ::fidl::VectorView<int64_t> vector_int64 = {};

  ::fidl::VectorView<float> vector_float32 = {};

  ::fidl::VectorView<double> vector_float64 = {};

  ::fidl::VectorView<::fidl::StringView> vector_string = {};

  ::fidl::VectorView<::fidl::StringView> vector_opt_string = {};
};

struct VectorCompound {
  ::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits = {};

  ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum = {};

  ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct = {};

  ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table = {};

  ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union = {};

  ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct = {};

  ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union = {};
};

struct VectorOptional {
  ::fidl::VectorView<uint8_t> opt_vector_uint8 = {};

  ::fidl::VectorView<::fidl::StringView> opt_vector_string = {};

  ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct = {};

  ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct = {};
};

struct ArrayVectorNested {
  ::fidl::Array<::fidl::Array<uint8_t, 5>, 5> array_array_uint8 = {};

  ::fidl::Array<::fidl::VectorView<uint8_t>, 5> array_vector_uint8 = {};

  ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8 = {};

  ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8 = {};
};

#ifdef __Fuchsia__

struct Resource {
  ::zx::handle handle = {};

  ::zx::vmo vmo = {};

  ::fidl::ClientEnd<::test_typesinprotocols::Protocol> client_end = {};

  ::fidl::ServerEnd<::test_typesinprotocols::Protocol> server_end = {};

  ::test_typesinprotocols::wire::ResourceStruct struct_ = {};

  ::test_typesinprotocols::wire::ResourceTable table = {};

  ::test_typesinprotocols::wire::ResourceUnion union_ = {};

  ::zx::handle opt_handle = {};

  ::zx::vmo opt_vmo = {};

  ::fidl::ClientEnd<::test_typesinprotocols::Protocol> opt_client_end = {};

  ::fidl::ServerEnd<::test_typesinprotocols::Protocol> opt_server_end = {};

  ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct = {};

  ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union = {};

  ::fidl::Array<::zx::handle, 5> array_handle = {};

  ::fidl::Array<::zx::vmo, 5> array_vmo = {};

  ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> array_client_end = {};

  ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> array_server_end = {};

  ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5> array_struct = {};

  ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5> array_table = {};

  ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5> array_union = {};

  ::fidl::VectorView<::zx::handle> vector_handle = {};

  ::fidl::VectorView<::zx::vmo> vector_vmo = {};

  ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end = {};

  ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end = {};

  ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct = {};

  ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table = {};

  ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union = {};

  void _CloseHandles();
};

#endif  // __Fuchsia__

}  // namespace wire
}  // namespace test_typesinprotocols
namespace fidl {

template <bool IsRecursive>
struct internal::WireCodingTraits<::test_typesinprotocols::wire::Bits, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = sizeof(uint32_t);
  static constexpr bool kIsMemcpyCompatible = true;
  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Bits* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <bool IsRecursive>
struct internal::WireCodingTraits<::test_typesinprotocols::wire::Enum, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = sizeof(uint32_t);
  static constexpr bool kIsMemcpyCompatible = true;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Enum* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_typesinprotocols::wire::Struct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Struct> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::Struct> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::Struct> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Struct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::Struct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Struct* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ResourceStruct> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ResourceStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ResourceStruct> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ResourceStruct> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ResourceStruct> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ResourceStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceStruct* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_typesinprotocols::wire::Basic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 80;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Basic> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::Basic> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::Basic> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 80;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<int64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<double, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::StringView, fidl::internal::WireCodingConstraintString<true>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Basic* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_typesinprotocols::wire::Compound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 72;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Compound> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::Compound> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::Compound> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 72;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Bits, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Enum, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Struct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Table, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::Union, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Compound* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ArrayBasic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 384;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ArrayBasic> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ArrayBasic> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ArrayBasic> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 384;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<uint8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<uint16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<uint32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<uint64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<int8_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<int16_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<int32_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<int64_t, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<float, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<double, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::StringView, 5>, fidl::internal::WireCodingConstraintString<true>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayBasic* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ArrayCompound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 328;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 40;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ArrayCompound> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ArrayCompound> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ArrayCompound> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 328;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Bits, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Enum, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Struct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Table, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::Union, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayCompound* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_typesinprotocols::wire::VectorBasic> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 192;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::VectorBasic> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::VectorBasic> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::VectorBasic> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 192;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<int8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<int16_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<int32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<int64_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<float>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<double>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<true>, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorBasic* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_typesinprotocols::wire::VectorCompound> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 112;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::VectorCompound> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::VectorCompound> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::VectorCompound> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 112;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Bits>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Enum>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Table>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Union>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<true>, false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorCompound* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_typesinprotocols::wire::VectorOptional> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 64;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::VectorOptional> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::VectorOptional> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::VectorOptional> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 64;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<uint8_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::StringView>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintString<false>, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::Struct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::VectorOptional* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ArrayVectorNested> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 144;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ArrayVectorNested> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ArrayVectorNested> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::ArrayVectorNested> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 144;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::Array<uint8_t, 5>, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::VectorView<uint8_t>, 5>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::Array<uint8_t, 5>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::VectorView<uint8_t>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, false>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ArrayVectorNested* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::Resource> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::Resource> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 456;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Resource> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::Resource> : public std::true_type {};
template <>
struct IsStruct<::test_typesinprotocols::wire::Resource> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 456;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ResourceStruct, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ResourceTable, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::test_typesinprotocols::wire::ResourceUnion, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::zx::handle, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::zx::handle, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::zx::vmo, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::zx::handle>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_NONE, 0x80000000, false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::zx::vmo>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, false>, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintUnion<false>, false>, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Resource* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_typesinprotocols::wire::Table> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Table> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::Table> : public std::true_type {};
template <>
struct IsTable<::test_typesinprotocols::wire::Table> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Table, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Table* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ResourceTable> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ResourceTable> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ResourceTable> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ResourceTable> : public std::true_type {};
template <>
struct IsTable<::test_typesinprotocols::wire::ResourceTable> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceTable, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceTable* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_typesinprotocols::wire::Union> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::Union> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::Union> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::Union> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::Union* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Union, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ResourceUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ResourceUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ResourceUnion> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ResourceUnion> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ResourceUnion> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ResourceUnion* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ResourceUnion, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#endif  // __Fuchsia__

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorBasicResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorBasicResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorBasicResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorBasicResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 80;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorCompoundResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorCompoundResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorCompoundResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorCompoundResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 368;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#ifdef __Fuchsia__
template <>
struct IsResource<::test_typesinprotocols::wire::ProtocolErrorResourceResult> : public std::true_type {};

template <>
struct TypeTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult> {
  static constexpr uint32_t kMaxNumHandles = 4294967295;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_typesinprotocols::wire::ProtocolErrorResourceResult> : public std::true_type {};
template <>
struct IsWire<::test_typesinprotocols::wire::ProtocolErrorResourceResult> : public std::true_type {};
template <>
struct IsUnion<::test_typesinprotocols::wire::ProtocolErrorResourceResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_typesinprotocols::wire::ProtocolErrorResourceResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#endif  // __Fuchsia__

#pragma clang diagnostic pop

}  // namespace fidl
