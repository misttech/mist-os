// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json
#ifdef __Fuchsia__

#include <fidl/test.typesinprotocols/cpp/wire_messaging.h>

#include <memory>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

  namespace test_typesinprotocols {

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayBasic_Ordinal = 8948968077914418681lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::Basic)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::Basic>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint16) == 2);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint32) == 4);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint64) == 8);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, int8) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, int16) == 18);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, int32) == 20);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, int64) == 24);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, float32) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, float64) == 40);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, string) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, opt_string) == 64);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayBasic_Ordinal = 2331618702752598159lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::Basic)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::Basic>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint16) == 2);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint32) == 4);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, uint64) == 8);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, int8) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, int16) == 18);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, int32) == 20);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, int64) == 24);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, float32) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, float64) == 40);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, string) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::Basic, opt_string) == 64);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, uint8) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, uint16) == 2);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, uint32) == 4);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, uint64) == 8);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, int8) == 16);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, int16) == 18);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, int32) == 20);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, int64) == 24);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, float32) == 32);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, float64) == 40);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, string) == 48);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, opt_string) == 64);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorBasic_Ordinal = 5016634351643393939lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventBasic_Ordinal = 5892309624949902400lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayCompound_Ordinal = 3153289648860022476lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::Compound)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::Compound>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, bits) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, enum_) == 4);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, struct_) == 8);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, table) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, union_) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_struct) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_union) == 56);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayCompound_Ordinal = 8787219719097524529lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::Compound)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::Compound>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, bits) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, enum_) == 4);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, struct_) == 8);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, table) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, union_) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_struct) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::Compound, opt_union) == 56);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, bits) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, enum_) == 4);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, struct_) == 8);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, table) == 16);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, union_) == 32);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, opt_struct) == 48);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, opt_union) == 56);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorCompound_Ordinal = 2990809657626249085lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventCompound_Ordinal = 7024581948727571669lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayArrayBasic_Ordinal = 7125516817014311449lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayArrayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::ArrayBasic)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayBasic>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint16) == 6);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint32) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint64) == 40);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int8) == 80);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int16) == 86);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int32) == 96);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int64) == 120);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float32) == 160);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float64) == 184);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_string) == 224);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_opt_string) == 304);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayArrayBasic_Ordinal = 5309034178175279380lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayArrayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::ArrayBasic)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayBasic>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint16) == 6);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint32) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_uint64) == 40);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int8) == 80);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int16) == 86);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int32) == 96);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_int64) == 120);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float32) == 160);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_float64) == 184);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_string) == 224);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayBasic, array_opt_string) == 304);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_uint8) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_uint16) == 6);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_uint32) == 16);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_uint64) == 40);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_int8) == 80);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_int16) == 86);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_int32) == 96);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_int64) == 120);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_float32) == 160);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_float64) == 184);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_string) == 224);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, array_opt_string) == 304);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorArrayBasic_Ordinal = 1084731895342694265lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorArrayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventArrayBasic_Ordinal = 5888282827283820590lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventArrayBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayArrayCompound_Ordinal = 5064659223443251357lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayArrayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::ArrayCompound)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayCompound>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_bits) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_enum) == 20);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_struct) == 40);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_table) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_union) == 128);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_struct) == 208);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_union) == 248);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayArrayCompound_Ordinal = 849744466051983995lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayArrayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::ArrayCompound)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayCompound>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_bits) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_enum) == 20);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_struct) == 40);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_table) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_union) == 128);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_struct) == 208);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayCompound, array_opt_union) == 248);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_bits) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_enum) == 20);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_struct) == 40);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_table) == 48);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_union) == 128);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_opt_struct) == 208);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, array_opt_union) == 248);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorArrayCompound_Ordinal = 5919277476782807556lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorArrayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventArrayCompound_Ordinal = 2189769767733851157lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventArrayCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayVectorBasic_Ordinal = 5733220720079947351lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayVectorBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::VectorBasic)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorBasic>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint16) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint32) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint64) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int8) == 64);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int16) == 80);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int32) == 96);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int64) == 112);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float32) == 128);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float64) == 144);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_string) == 160);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_opt_string) == 176);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayVectorBasic_Ordinal = 8674156353091415668lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayVectorBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::VectorBasic)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorBasic>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint16) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint32) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_uint64) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int8) == 64);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int16) == 80);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int32) == 96);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_int64) == 112);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float32) == 128);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_float64) == 144);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_string) == 160);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorBasic, vector_opt_string) == 176);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_uint8) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_uint16) == 16);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_uint32) == 32);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_uint64) == 48);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_int8) == 64);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_int16) == 80);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_int32) == 96);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_int64) == 112);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_float32) == 128);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_float64) == 144);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_string) == 160);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, vector_opt_string) == 176);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorVectorBasic_Ordinal = 875941614196965234lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorVectorBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventVectorBasic_Ordinal = 4583890770109526006lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventVectorBasic_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayVectorCompound_Ordinal = 1853985797298830992lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayVectorCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::VectorCompound)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorCompound>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_bits) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_enum) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_struct) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_table) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_union) == 64);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_struct) == 80);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_union) == 96);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayVectorCompound_Ordinal = 3968024057912959924lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayVectorCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::VectorCompound)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorCompound>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_bits) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_enum) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_struct) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_table) == 48);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_union) == 64);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_struct) == 80);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorCompound, vector_opt_union) == 96);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_bits) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_enum) == 16);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_struct) == 32);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_table) == 48);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_union) == 64);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_opt_struct) == 80);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, vector_opt_union) == 96);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorVectorCompound_Ordinal = 8506780203315865989lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorVectorCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventVectorCompound_Ordinal = 6026375226599919603lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventVectorCompound_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayVectorOptional_Ordinal = 1530215841195476271lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayVectorOptional_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::VectorOptional)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorOptional>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_string) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_struct) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_opt_struct) == 48);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayVectorOptional_Ordinal = 1030024737742222323lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayVectorOptional_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::VectorOptional)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::VectorOptional>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_string) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_struct) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::VectorOptional, opt_vector_opt_struct) == 48);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, opt_vector_uint8) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, opt_vector_string) == 16);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, opt_vector_struct) == 32);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, opt_vector_opt_struct) == 48);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorVectorOptional_Ordinal = 6406191217027936606lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorVectorOptional_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventVectorOptional_Ordinal = 1684763340073130077lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventVectorOptional_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayArrayVectorNested_Ordinal = 5912603762133524183lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayArrayVectorNested_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::ArrayVectorNested)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayVectorNested>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_array_uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_vector_uint8) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_array_uint8) == 112);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_vector_uint8) == 128);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayArrayVectorNested_Ordinal = 5351275678438791132lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayArrayVectorNested_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::ArrayVectorNested)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::ArrayVectorNested>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_array_uint8) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, array_vector_uint8) == 32);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_array_uint8) == 112);
          static_assert(offsetof(::test_typesinprotocols::wire::ArrayVectorNested, vector_vector_uint8) == 128);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, array_array_uint8) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, array_vector_uint8) == 32);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, vector_array_uint8) == 112);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, vector_vector_uint8) == 128);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorArrayVectorNested_Ordinal = 9085604921605802151lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorArrayVectorNested_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventArrayVectorNested_Ordinal = 1228201560727880574lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventArrayVectorNested_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_OneWayResource_Ordinal = 6553996787849601058lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_OneWayResource_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::Resource)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::Resource>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, handle) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vmo) == 4);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, client_end) == 8);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, server_end) == 12);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, struct_) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, table) == 24);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, union_) == 40);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_handle) == 56);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_vmo) == 60);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_client_end) == 64);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_server_end) == 68);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_struct) == 72);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_union) == 80);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_handle) == 96);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_vmo) == 116);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_client_end) == 136);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_server_end) == 156);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_struct) == 176);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_table) == 184);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_union) == 264);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_handle) == 344);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_vmo) == 360);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_client_end) == 376);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_server_end) == 392);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_struct) == 408);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_table) == 424);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_union) == 440);

  [[maybe_unused]]
  constexpr uint64_t kProtocol_TwoWayResource_Ordinal = 1802709005492464987lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_TwoWayResource_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>)
        == ::fidl::TypeTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, body) == sizeof(fidl_message_header_t));

    static_assert(sizeof(::test_typesinprotocols::wire::Resource)
        == ::fidl::TypeTraits<::test_typesinprotocols::wire::Resource>::kPrimarySize);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, handle) == 0);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vmo) == 4);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, client_end) == 8);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, server_end) == 12);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, struct_) == 16);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, table) == 24);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, union_) == 40);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_handle) == 56);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_vmo) == 60);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_client_end) == 64);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_server_end) == 68);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_struct) == 72);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, opt_union) == 80);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_handle) == 96);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_vmo) == 116);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_client_end) == 136);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_server_end) == 156);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_struct) == 176);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_table) == 184);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, array_union) == 264);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_handle) == 344);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_vmo) == 360);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_client_end) == 376);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_server_end) == 392);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_struct) == 408);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_table) == 424);
          static_assert(offsetof(::test_typesinprotocols::wire::Resource, vector_union) == 440);
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>>::kPrimarySize);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, handle) == 0);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, vmo) == 4);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, client_end) == 8);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, server_end) == 12);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, struct_) == 16);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, table) == 24);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, union_) == 40);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, opt_handle) == 56);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, opt_vmo) == 60);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, opt_client_end) == 64);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, opt_server_end) == 68);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, opt_struct) == 72);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, opt_union) == 80);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, array_handle) == 96);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, array_vmo) == 116);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, array_client_end) == 136);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, array_server_end) == 156);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, array_struct) == 176);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, array_table) == 184);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, array_union) == 264);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, vector_handle) == 344);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, vector_vmo) == 360);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, vector_client_end) == 376);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, vector_server_end) == 392);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, vector_struct) == 408);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, vector_table) == 424);
          static_assert(offsetof(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, vector_union) == 440);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_ErrorResource_Ordinal = 6568609240497354166lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_ErrorResource_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
      static_assert(sizeof(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>)
          == ::fidl::TypeTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>>::kPrimarySize);
      static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>)
          == ::fidl::TypeTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>>::kPrimarySize);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, body) == sizeof(fidl_message_header_t));

  [[maybe_unused]]
  constexpr uint64_t kProtocol_EventResource_Ordinal = 5745997765922613643lu;

  [[maybe_unused]]
  constexpr ::fidl::MessageDynamicFlags kProtocol_EventResource_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
    static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>)
      == ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>>::kPrimarySize);
    static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, header) == 0);
      static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, body) == sizeof(fidl_message_header_t));}  // namespace test_typesinprotocols

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorBasic>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorCompound>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayArrayBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayArrayCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayVectorBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorBasic>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayVectorCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorCompound>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayVectorOptional>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorOptional>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorOptional>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayResource>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    outgoing.Write(client.handle());
    SetStatus(outgoing);
}

::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayResource>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayResource>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayResource>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayResource>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;
        uint32_t request_byte_capacity = buffer_size;
        uint8_t* request_bytes = buffer;

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        outgoing.Write(client_end.handle());
        SetStatus(outgoing);
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayResource>::WireUnownedResult(
        ::fit::result<::fidl::Error>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayResource>(::fidl::internal::StatusFromResult(decoded)) {}

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayResource>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::OneWayResource>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayResource>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayResource>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayResource>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayResource>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayResource>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayResource>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayResource>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayResource>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::TwoWayResource>(result) {}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource>::WireResult(
    ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client,
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>* request
) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::ChannelTransport> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
    ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> handle_storage;
    ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>(
        outgoing.Call(client.handle(), handle_storage.view(bytes_.view()), fidl::CallOptions{})
    );
    SetStatus(::fidl::internal::StatusFromResult(decoded));
      if (ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
}

::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource>::WireResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorResource>(result) {}

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorResource>::WireUnownedResult(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>* request) {
      constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorResource>();
      ::fit::result<::fidl::Error, ::fidl::BufferSpan> allocation = allocator.TryAllocate(buffer_size);
      if (!allocation.is_ok()) {
        SetStatus(allocation.error_value());
        return;
      }
      uint8_t* buffer = allocation->data;constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
            ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::MessageDirection::kSending>();
        uint8_t* request_bytes = buffer;
        static_assert(buffer_size > request_byte_capacity);
        uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
        uint8_t* response_bytes = &buffer[request_byte_capacity];

      ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>> request_message(
          request_bytes, request_byte_capacity, request);
      auto& outgoing = request_message.GetOutgoingMessage();
        ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>> handle_storage;
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>(
            outgoing.Call(
                client_end.handle(),
                handle_storage.view(fidl::BufferSpan(response_bytes, response_byte_capacity))
            )
        );
        SetStatus(::fidl::internal::StatusFromResult(decoded));
          if (ok()) {
            decoded_ = std::move(decoded.value());
            ExtractValueFromDecoded(decoded_.pointer());
          }
    }
    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorResource>::WireUnownedResult(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>* response)
        : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorResource>(fidl::Status::Ok()), decoded_(response) {
      ExtractValueFromDecoded(decoded_.pointer());
    }

    ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorResource>::WireUnownedResult(
        ::fit::result<::fidl::Error, ::fidl::DecodedValue<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorResource>(::fidl::internal::StatusFromResult(decoded)) {
      if (decoded.is_ok()) {
        decoded_ = std::move(decoded.value());
        ExtractValueFromDecoded(decoded_.pointer());
      }
    }

  ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorResource>::WireUnownedResult(const ::fidl::Status& result) : ::fidl::BaseWireResult<::test_typesinprotocols::Protocol::ErrorResource>(result) {}

  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic> _request_object{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound> _request_object{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic> _request_object{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound> _request_object{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic> _request_object{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound> _request_object{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional> _request_object{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> _request_object{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }
  ::fidl::OneWayStatus fidl::internal::WireWeakOnewayClientImpl<::test_typesinprotocols::Protocol>::OneWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
    FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource> _request_object{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
    ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, ::fidl::internal::ChannelTransport> _request_message(
        ::fidl::internal::AllowUnownedInputRef{}, &_request_object);
    return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayBasic> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayBasic>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorBasic> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorBasic() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorBasic>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayCompound> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayCompound>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorCompound> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorCompound() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorCompound>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayBasic> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayBasic() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayBasic>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayCompound> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayCompound() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayCompound>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorBasic> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorBasic() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorBasic>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorCompound> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorCompound() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorCompound>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorOptional> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorOptional() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorVectorOptional>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayVectorNested() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayResource> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource> _request{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::TwoWayResource>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }

  ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorResource> fidl::internal::WireWeakAsyncClientImpl<::test_typesinprotocols::Protocol>::ErrorResource() {
    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource> _request{  };
    return ::fidl::internal::WireThenable<::test_typesinprotocols::Protocol::ErrorResource>{
        _client_base(), ::fidl::WriteOptions{}, ::fidl::internal::AllowUnownedInputRef{}, &_request};
  }
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayArrayBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayArrayCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayVectorBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayVectorCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayVectorOptional>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::OneWayStatus fidl::internal::WireWeakOnewayBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::OneWayResource>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return ::fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource> _request{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>> _request_message(
      _allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayBasic> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayBasic>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayBasic>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorBasic> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorBasic() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorBasic>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorBasic>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayCompound> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayCompound>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayCompound>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorCompound> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorCompound() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorCompound>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorCompound>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayBasic>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayBasic>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayBasic> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayBasic() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayBasic>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayBasic>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayCompound>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayCompound>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayCompound> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayCompound() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayCompound>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayCompound>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorBasic>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorBasic>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorBasic> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorBasic() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorBasic>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorBasic>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorCompound>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorCompound>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorCompound> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorCompound() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorCompound>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorCompound>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorOptional>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayVectorOptional>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorOptional> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorOptional() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorOptional>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorVectorOptional>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayVectorNested() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayResource> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayResource>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource> _request{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::TwoWayResource>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorResource> fidl::internal::WireWeakAsyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorResource() {
  constexpr uint32_t _buffer_size = ::fidl::AsyncClientMethodBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorResource>();
  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource> _request{  };
  return ::fidl::internal::WireBufferThenable<::test_typesinprotocols::Protocol::ErrorResource>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size, &_request};
}

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorBasic() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorCompound() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayBasic() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayCompound() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorBasic() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorCompound() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorOptional() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayVectorNested() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource> _request{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

  ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource>
  fidl::internal::WireWeakSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorResource() {
    return _client_base()->MakeSyncCallWith(
        [&] (std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
          ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource> _request{  };
          return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource>(::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport->get<::fidl::internal::ChannelTransport>()), &_request);
        });
  }

::fidl::internal::WireEventDispatcher<::test_typesinprotocols::Protocol>::WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_typesinprotocols::Protocol>* event_handler)
: IncomingEventDispatcher(event_handler) {}

  ::fidl::Status fidl::WireSyncEventHandler<::test_typesinprotocols::Protocol>::HandleOneEvent(
      ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol> client_end) {
      ::fidl::internal::IncomingEventsStorage<::test_typesinprotocols::Protocol> event_storage;
      fidl::internal::WireEventDispatcher<::test_typesinprotocols::Protocol> dispatcher{this};
      return HandleOneEventImpl_(client_end.channel(), event_storage.view(), dispatcher);
  }
  ::fidl::Status
  fidl::internal::WireEventDispatcher<::test_typesinprotocols::Protocol>::DispatchEvent(
      ::fidl::IncomingHeaderAndMessage& msg,
      ::fidl::internal::MessageStorageViewBase* storage_view) {
    switch (msg.header()->ordinal) {
      case ::test_typesinprotocols::kProtocol_EventBasic_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventBasic(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_typesinprotocols::kProtocol_EventCompound_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventCompound(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_typesinprotocols::kProtocol_EventArrayBasic_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventArrayBasic(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_typesinprotocols::kProtocol_EventArrayCompound_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventArrayCompound(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_typesinprotocols::kProtocol_EventVectorBasic_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventVectorBasic(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_typesinprotocols::kProtocol_EventVectorCompound_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventVectorCompound(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_typesinprotocols::kProtocol_EventVectorOptional_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventVectorOptional(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_typesinprotocols::kProtocol_EventArrayVectorNested_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventArrayVectorNested(primary);
        }
        return ::fidl::Status::Ok();
      }
      case ::test_typesinprotocols::kProtocol_EventResource_Ordinal:
      {
        ::fit::result decoded = ::fidl::internal::InplaceDecodeTransactionalEvent<::test_typesinprotocols::Protocol::EventResource>(
            std::move(msg));
        if (!decoded.is_ok()) {
          return decoded.error_value();
        }
        if (event_handler()) {
            auto* primary = decoded.value().pointer();
          event_handler()->EventResource(primary);
        }
        return ::fidl::Status::Ok();
      }
      default:
        std::move(msg).CloseHandles();
        return ::fidl::Status::UnknownOrdinal();
    }
  }
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>* event) {}
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>* event) {}
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventArrayBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>* event) {}
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventArrayCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>* event) {}
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventVectorBasic(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>* event) {}
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventVectorCompound(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>* event) {}
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventVectorOptional(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>* event) {}
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventArrayVectorNested(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>* event) {}
void fidl::WireAsyncEventHandler<::test_typesinprotocols::Protocol>::EventResource(::fidl::WireEvent<::test_typesinprotocols::Protocol::EventResource>* event) {}

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<::test_typesinprotocols::Protocol>::entries_[] = {
    { ::test_typesinprotocols::kProtocol_OneWayBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::Basic>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayBasic(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::Basic>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayBasic(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorBasic(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_OneWayCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::Compound>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayCompound(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::Compound>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayCompound(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorCompound(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_OneWayArrayBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::ArrayBasic>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayArrayBasic(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::ArrayBasic>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayArrayBasic(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorArrayBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorArrayBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorArrayBasic(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_OneWayArrayCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::ArrayCompound>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayArrayCompound(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::ArrayCompound>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayArrayCompound(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorArrayCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorArrayCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorArrayCompound(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_OneWayVectorBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::VectorBasic>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayVectorBasic(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::VectorBasic>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayVectorBasic(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorVectorBasic_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorVectorBasic>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorVectorBasic(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_OneWayVectorCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::VectorCompound>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayVectorCompound(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::VectorCompound>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayVectorCompound(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorVectorCompound_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorVectorCompound>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorVectorCompound(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_OneWayVectorOptional_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::VectorOptional>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayVectorOptional>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayVectorOptional(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::VectorOptional>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayVectorOptional(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorVectorOptional_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorVectorOptional>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorVectorOptional(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_OneWayArrayVectorNested_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::ArrayVectorNested>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayArrayVectorNested(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::ArrayVectorNested>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayArrayVectorNested(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorArrayVectorNested_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorArrayVectorNested(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_OneWayResource_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::Resource>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::OneWayResource>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->OneWayResource(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_TwoWayResource_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::StandaloneInplaceDecode<::test_typesinprotocols::wire::Resource>(
            std::move(msg), metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::TwoWayResource>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->TwoWayResource(
            decoded.value().pointer(),
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
    { ::test_typesinprotocols::kProtocol_ErrorResource_Ordinal,
      [](void* interface, ::fidl::EncodedMessage& msg, ::fidl::WireFormatMetadata metadata,
         internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
        ::fit::result decoded = ::fidl::internal::DecodeTransactionalMessageWithoutBody(
            msg, metadata);
        if (unlikely(!decoded.is_ok())) {
          return decoded.error_value();
        }
        ::fidl::internal::WireCompleter<::test_typesinprotocols::Protocol::ErrorResource>::Sync completer(txn);
        reinterpret_cast<::fidl::WireServer<::test_typesinprotocols::Protocol>*>(interface)->ErrorResource(
            completer
        );
        return ::fidl::Status::Ok();
      },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<::test_typesinprotocols::Protocol>::entries_end_ =
    &entries_[27];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<::test_typesinprotocols::Protocol>::TryDispatch(
    ::fidl::WireServer<::test_typesinprotocols::Protocol>* impl, ::fidl::IncomingHeaderAndMessage& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(
    impl, msg, storage_view, txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_typesinprotocols::Protocol>::Dispatch(::fidl::WireServer<::test_typesinprotocols::Protocol>* impl, ::fidl::IncomingHeaderAndMessage&& msg,
    internal::MessageStorageViewBase* storage_view, ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, storage_view, txn, entries_, entries_end_,
  &unknown_method_handler_entry_);
}

void fidl::WireServer<::test_typesinprotocols::Protocol>::dispatch_message(
    ::fidl::IncomingHeaderAndMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) {
  ::fidl::internal::WireServerDispatcher<::test_typesinprotocols::Protocol>::Dispatch(this, std::move(msg), storage_view, txn);
}

fidl::WireServer<::test_typesinprotocols::Protocol>::Handler fidl::WireServer<::test_typesinprotocols::Protocol>::bind_handler(async_dispatcher_t* dispatcher) {
  return [impl=this, dispatcher=dispatcher](::fidl::ServerEnd<::test_typesinprotocols::Protocol> request) {
      (void) ::fidl::BindServer(dispatcher, std::move(request), impl);
  };
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic>::Reply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  return MakeReply(uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic>::MakeReply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic> _response{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic>::Reply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  return MakeReply(uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayBasic>::MakeReply(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic> _response{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayBasic>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Basic*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult ProtocolErrorBasicResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic> _response{ ProtocolErrorBasicResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic>::ReplySuccess(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
    ::test_typesinprotocols::wire::Basic _response = ::test_typesinprotocols::wire::Basic {
  .uint8 = std::move(uint8),
  .uint16 = std::move(uint16),
  .uint32 = std::move(uint32),
  .uint64 = std::move(uint64),
  .int8 = std::move(int8),
  .int16 = std::move(int16),
  .int32 = std::move(int32),
  .int64 = std::move(int64),
  .float32 = std::move(float32),
  .float64 = std::move(float64),
  .string = std::move(string),
  .opt_string = std::move(opt_string),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Basic*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult ProtocolErrorBasicResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic> _response{ ProtocolErrorBasicResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorBasic>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorBasic>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorBasic>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorBasic>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic>::ReplySuccess(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
    ::test_typesinprotocols::wire::Basic _response = ::test_typesinprotocols::wire::Basic {
  .uint8 = std::move(uint8),
  .uint16 = std::move(uint16),
  .uint32 = std::move(uint32),
  .uint64 = std::move(uint64),
  .int8 = std::move(int8),
  .int16 = std::move(int16),
  .int32 = std::move(int32),
  .int64 = std::move(int64),
  .float32 = std::move(float32),
  .float64 = std::move(float64),
  .string = std::move(string),
  .opt_string = std::move(opt_string),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Basic>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorBasic>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorBasicResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound>::Reply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  return MakeReply(bits, enum_, struct_, table, union_, opt_struct, opt_union);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound>::MakeReply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound> _response{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound>::Reply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  return MakeReply(bits, enum_, struct_, table, union_, opt_struct, opt_union);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayCompound>::MakeReply(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound> _response{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayCompound>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Compound*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult ProtocolErrorCompoundResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound> _response{ ProtocolErrorCompoundResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound>::ReplySuccess(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
    ::test_typesinprotocols::wire::Compound _response = ::test_typesinprotocols::wire::Compound {
  .bits = std::move(bits),
  .enum_ = std::move(enum_),
  .struct_ = std::move(struct_),
  .table = std::move(table),
  .union_ = std::move(union_),
  .opt_struct = std::move(opt_struct),
  .opt_union = std::move(opt_union),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Compound*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult ProtocolErrorCompoundResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound> _response{ ProtocolErrorCompoundResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorCompound>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorCompound>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorCompound>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorCompound>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound>::ReplySuccess(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
    ::test_typesinprotocols::wire::Compound _response = ::test_typesinprotocols::wire::Compound {
  .bits = std::move(bits),
  .enum_ = std::move(enum_),
  .struct_ = std::move(struct_),
  .table = std::move(table),
  .union_ = std::move(union_),
  .opt_struct = std::move(opt_struct),
  .opt_union = std::move(opt_union),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Compound>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorCompound>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorCompoundResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::Reply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  return MakeReply(array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::MakeReply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _response{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::Reply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  return MakeReply(array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::MakeReply(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _response{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayBasic*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult ProtocolErrorArrayBasicResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic> _response{ ProtocolErrorArrayBasicResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic>::ReplySuccess(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
    ::test_typesinprotocols::wire::ArrayBasic _response = ::test_typesinprotocols::wire::ArrayBasic {
  .array_uint8 = std::move(array_uint8),
  .array_uint16 = std::move(array_uint16),
  .array_uint32 = std::move(array_uint32),
  .array_uint64 = std::move(array_uint64),
  .array_int8 = std::move(array_int8),
  .array_int16 = std::move(array_int16),
  .array_int32 = std::move(array_int32),
  .array_int64 = std::move(array_int64),
  .array_float32 = std::move(array_float32),
  .array_float64 = std::move(array_float64),
  .array_string = std::move(array_string),
  .array_opt_string = std::move(array_opt_string),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayBasic*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult ProtocolErrorArrayBasicResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic> _response{ ProtocolErrorArrayBasicResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayBasic>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayBasic>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic>::ReplySuccess(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
    ::test_typesinprotocols::wire::ArrayBasic _response = ::test_typesinprotocols::wire::ArrayBasic {
  .array_uint8 = std::move(array_uint8),
  .array_uint16 = std::move(array_uint16),
  .array_uint32 = std::move(array_uint32),
  .array_uint64 = std::move(array_uint64),
  .array_int8 = std::move(array_int8),
  .array_int16 = std::move(array_int16),
  .array_int32 = std::move(array_int32),
  .array_int64 = std::move(array_int64),
  .array_float32 = std::move(array_float32),
  .array_float64 = std::move(array_float64),
  .array_string = std::move(array_string),
  .array_opt_string = std::move(array_opt_string),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayBasic>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayBasic>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::Reply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  return MakeReply(array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::MakeReply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _response{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::Reply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  return MakeReply(array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::MakeReply(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _response{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayCompound*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult ProtocolErrorArrayCompoundResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound> _response{ ProtocolErrorArrayCompoundResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound>::ReplySuccess(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
    ::test_typesinprotocols::wire::ArrayCompound _response = ::test_typesinprotocols::wire::ArrayCompound {
  .array_bits = std::move(array_bits),
  .array_enum = std::move(array_enum),
  .array_struct = std::move(array_struct),
  .array_table = std::move(array_table),
  .array_union = std::move(array_union),
  .array_opt_struct = std::move(array_opt_struct),
  .array_opt_union = std::move(array_opt_union),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayCompound*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult ProtocolErrorArrayCompoundResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound> _response{ ProtocolErrorArrayCompoundResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayCompound>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayCompound>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound>::ReplySuccess(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
    ::test_typesinprotocols::wire::ArrayCompound _response = ::test_typesinprotocols::wire::ArrayCompound {
  .array_bits = std::move(array_bits),
  .array_enum = std::move(array_enum),
  .array_struct = std::move(array_struct),
  .array_table = std::move(array_table),
  .array_union = std::move(array_union),
  .array_opt_struct = std::move(array_opt_struct),
  .array_opt_union = std::move(array_opt_union),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayCompound>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayCompound>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::Reply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  return MakeReply(vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::MakeReply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _response{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::Reply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  return MakeReply(vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::MakeReply(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _response{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorBasic*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult ProtocolErrorVectorBasicResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic> _response{ ProtocolErrorVectorBasicResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic>::ReplySuccess(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
    ::test_typesinprotocols::wire::VectorBasic _response = ::test_typesinprotocols::wire::VectorBasic {
  .vector_uint8 = std::move(vector_uint8),
  .vector_uint16 = std::move(vector_uint16),
  .vector_uint32 = std::move(vector_uint32),
  .vector_uint64 = std::move(vector_uint64),
  .vector_int8 = std::move(vector_int8),
  .vector_int16 = std::move(vector_int16),
  .vector_int32 = std::move(vector_int32),
  .vector_int64 = std::move(vector_int64),
  .vector_float32 = std::move(vector_float32),
  .vector_float64 = std::move(vector_float64),
  .vector_string = std::move(vector_string),
  .vector_opt_string = std::move(vector_opt_string),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorBasic*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult ProtocolErrorVectorBasicResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic> _response{ ProtocolErrorVectorBasicResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorBasic>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorBasic>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic>::ReplySuccess(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
    ::test_typesinprotocols::wire::VectorBasic _response = ::test_typesinprotocols::wire::VectorBasic {
  .vector_uint8 = std::move(vector_uint8),
  .vector_uint16 = std::move(vector_uint16),
  .vector_uint32 = std::move(vector_uint32),
  .vector_uint64 = std::move(vector_uint64),
  .vector_int8 = std::move(vector_int8),
  .vector_int16 = std::move(vector_int16),
  .vector_int32 = std::move(vector_int32),
  .vector_int64 = std::move(vector_int64),
  .vector_float32 = std::move(vector_float32),
  .vector_float64 = std::move(vector_float64),
  .vector_string = std::move(vector_string),
  .vector_opt_string = std::move(vector_opt_string),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorBasic>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorBasic>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::Reply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  return MakeReply(vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::MakeReply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _response{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::Reply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  return MakeReply(vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::MakeReply(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _response{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorCompound*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult ProtocolErrorVectorCompoundResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound> _response{ ProtocolErrorVectorCompoundResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound>::ReplySuccess(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
    ::test_typesinprotocols::wire::VectorCompound _response = ::test_typesinprotocols::wire::VectorCompound {
  .vector_bits = std::move(vector_bits),
  .vector_enum = std::move(vector_enum),
  .vector_struct = std::move(vector_struct),
  .vector_table = std::move(vector_table),
  .vector_union = std::move(vector_union),
  .vector_opt_struct = std::move(vector_opt_struct),
  .vector_opt_union = std::move(vector_opt_union),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorCompound*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult ProtocolErrorVectorCompoundResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound> _response{ ProtocolErrorVectorCompoundResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorCompound>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorCompound>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound>::ReplySuccess(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
    ::test_typesinprotocols::wire::VectorCompound _response = ::test_typesinprotocols::wire::VectorCompound {
  .vector_bits = std::move(vector_bits),
  .vector_enum = std::move(vector_enum),
  .vector_struct = std::move(vector_struct),
  .vector_table = std::move(vector_table),
  .vector_union = std::move(vector_union),
  .vector_opt_struct = std::move(vector_opt_struct),
  .vector_opt_union = std::move(vector_opt_union),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorCompound>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorCompound>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::Reply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  return MakeReply(opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::MakeReply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _response{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::Reply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  return MakeReply(opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::MakeReply(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _response{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayVectorOptional>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorOptional*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult ProtocolErrorVectorOptionalResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional> _response{ ProtocolErrorVectorOptionalResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional>::ReplySuccess(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
    ::test_typesinprotocols::wire::VectorOptional _response = ::test_typesinprotocols::wire::VectorOptional {
  .opt_vector_uint8 = std::move(opt_vector_uint8),
  .opt_vector_string = std::move(opt_vector_string),
  .opt_vector_struct = std::move(opt_vector_struct),
  .opt_vector_opt_struct = std::move(opt_vector_opt_struct),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::VectorOptional*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult ProtocolErrorVectorOptionalResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional> _response{ ProtocolErrorVectorOptionalResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorVectorOptional>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorOptional>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorVectorOptional>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional>::ReplySuccess(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
    ::test_typesinprotocols::wire::VectorOptional _response = ::test_typesinprotocols::wire::VectorOptional {
  .opt_vector_uint8 = std::move(opt_vector_uint8),
  .opt_vector_string = std::move(opt_vector_string),
  .opt_vector_struct = std::move(opt_vector_struct),
  .opt_vector_opt_struct = std::move(opt_vector_opt_struct),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::VectorOptional>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorVectorOptional>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::Reply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  return MakeReply(array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::MakeReply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _response{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::Reply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  return MakeReply(array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::MakeReply(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _response{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayVectorNested*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult ProtocolErrorArrayVectorNestedResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> _response{ ProtocolErrorArrayVectorNestedResult };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::ReplySuccess(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
    ::test_typesinprotocols::wire::ArrayVectorNested _response = ::test_typesinprotocols::wire::ArrayVectorNested {
  .array_array_uint8 = std::move(array_array_uint8),
  .array_vector_uint8 = std::move(array_vector_uint8),
  .vector_array_uint8 = std::move(vector_array_uint8),
  .vector_vector_uint8 = std::move(vector_vector_uint8),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::ArrayVectorNested*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult ProtocolErrorArrayVectorNestedResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> _response{ ProtocolErrorArrayVectorNestedResult };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::ReplySuccess(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
    ::test_typesinprotocols::wire::ArrayVectorNested _response = ::test_typesinprotocols::wire::ArrayVectorNested {
  .array_array_uint8 = std::move(array_array_uint8),
  .array_vector_uint8 = std::move(array_vector_uint8),
  .vector_array_uint8 = std::move(vector_array_uint8),
  .vector_vector_uint8 = std::move(vector_vector_uint8),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::ArrayVectorNested>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayResource>::Reply(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  return MakeReply(std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union);
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::TwoWayResource>::MakeReply(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource> _response{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayResource>::Reply(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  return MakeReply(std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union);
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::TwoWayResource>::MakeReply(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource> _response{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::TwoWayResource>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayResource>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayResource>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayResource>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::TwoWayResource>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Resource*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult ProtocolErrorResourceResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource> _response{ std::move(ProtocolErrorResourceResult) };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource>::ReplySuccess(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
    ::test_typesinprotocols::wire::Resource _response = ::test_typesinprotocols::wire::Resource {
  .handle = std::move(handle),
  .vmo = std::move(vmo),
  .client_end = std::move(client_end),
  .server_end = std::move(server_end),
  .struct_ = std::move(struct_),
  .table = std::move(table),
  .union_ = std::move(union_),
  .opt_handle = std::move(opt_handle),
  .opt_vmo = std::move(opt_vmo),
  .opt_client_end = std::move(opt_client_end),
  .opt_server_end = std::move(opt_server_end),
  .opt_struct = std::move(opt_struct),
  .opt_union = std::move(opt_union),
  .array_handle = std::move(array_handle),
  .array_vmo = std::move(array_vmo),
  .array_client_end = std::move(array_client_end),
  .array_server_end = std::move(array_server_end),
  .array_struct = std::move(array_struct),
  .array_table = std::move(array_table),
  .array_union = std::move(array_union),
  .vector_handle = std::move(vector_handle),
  .vector_vmo = std::move(vector_vmo),
  .vector_client_end = std::move(vector_client_end),
  .vector_server_end = std::move(vector_server_end),
  .vector_struct = std::move(vector_struct),
  .vector_table = std::move(vector_table),
  .vector_union = std::move(vector_union),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult::WithErr(std::move(error)));
  }

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource>::Reply(::fit::result<uint32_t, ::test_typesinprotocols::wire::Resource*> result) {
  if (result.is_ok()) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource>::FromExternal(result.value())));
  }
  return ReplyError(std::move(result.error_value()));
}

void
fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource>::MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult ProtocolErrorResourceResult) {
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource> _response{ std::move(ProtocolErrorResourceResult) };
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::ErrorResource>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure, ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::internal::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorResource>::WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
: CompleterBase(transaction, owned, expects_reply),
  WireCompleterImpl(this) {}
fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorResource>::WireCompleterBase(WireCompleterBase&& other) noexcept
    : CompleterBase(std::move(other)), WireCompleterImpl(this) {}

::fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorResource>& fidl::internal::WireCompleterBase<::test_typesinprotocols::Protocol::ErrorResource>::operator=(WireCompleterBase&& other) noexcept {
  CompleterBase::operator=(std::move(other));
  WireCompleterImpl::_set_core(this);
  return *this;
}
  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource>::ReplySuccess(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
    ::test_typesinprotocols::wire::Resource _response = ::test_typesinprotocols::wire::Resource {
  .handle = std::move(handle),
  .vmo = std::move(vmo),
  .client_end = std::move(client_end),
  .server_end = std::move(server_end),
  .struct_ = std::move(struct_),
  .table = std::move(table),
  .union_ = std::move(union_),
  .opt_handle = std::move(opt_handle),
  .opt_vmo = std::move(opt_vmo),
  .opt_client_end = std::move(opt_client_end),
  .opt_server_end = std::move(opt_server_end),
  .opt_struct = std::move(opt_struct),
  .opt_union = std::move(opt_union),
  .array_handle = std::move(array_handle),
  .array_vmo = std::move(array_vmo),
  .array_client_end = std::move(array_client_end),
  .array_server_end = std::move(array_server_end),
  .array_struct = std::move(array_struct),
  .array_table = std::move(array_table),
  .array_union = std::move(array_union),
  .vector_handle = std::move(vector_handle),
  .vector_vmo = std::move(vector_vmo),
  .vector_client_end = std::move(vector_client_end),
  .vector_server_end = std::move(vector_server_end),
  .vector_struct = std::move(vector_struct),
  .vector_table = std::move(vector_table),
  .vector_union = std::move(vector_union),
};
return MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult::WithResponse(::fidl::ObjectView<::test_typesinprotocols::wire::Resource>::FromExternal(&_response)));
  }

  void
  fidl::internal::WireBufferCompleterImpl<::test_typesinprotocols::Protocol::ErrorResource>::ReplyError(uint32_t error) {
    return MakeReply(::test_typesinprotocols::wire::ProtocolErrorResourceResult::WithErr(std::move(error)));
  }

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayBasic_Ordinal, ::test_typesinprotocols::kProtocol_OneWayBasic_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>::TransactionalRequest(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string)
    : body(::test_typesinprotocols::wire::Basic { uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayBasic_Ordinal, ::test_typesinprotocols::kProtocol_OneWayBasic_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Basic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Basic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayBasic_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>::TransactionalRequest(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string)
    : body(::test_typesinprotocols::wire::Basic { uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayBasic_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Basic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Basic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>::WireResponse(::test_typesinprotocols::wire::Basic base) : ::test_typesinprotocols::wire::Basic(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>::WireResponse(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) : ::test_typesinprotocols::wire::Basic{ .uint8 = std::move(uint8), .uint16 = std::move(uint16), .uint32 = std::move(uint32), .uint64 = std::move(uint64), .int8 = std::move(int8), .int16 = std::move(int16), .int32 = std::move(int32), .int64 = std::move(int64), .float32 = std::move(float32), .float64 = std::move(float64), .string = std::move(string), .opt_string = std::move(opt_string)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>::TransactionalResponse(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>(uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayBasic_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Basic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorBasicResult ProtocolErrorBasicResult) : ::test_typesinprotocols::wire::ProtocolErrorBasicResult(ProtocolErrorBasicResult){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorBasicResult ProtocolErrorBasicResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>(ProtocolErrorBasicResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorBasic_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>::TransactionalEvent(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string)
    : body{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventBasic_Ordinal, ::test_typesinprotocols::kProtocol_EventBasic_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventBasic_Ordinal, ::test_typesinprotocols::kProtocol_EventBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayCompound_Ordinal, ::test_typesinprotocols::kProtocol_OneWayCompound_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>::TransactionalRequest(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union)
    : body(::test_typesinprotocols::wire::Compound { bits, enum_, struct_, table, union_, opt_struct, opt_union } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayCompound_Ordinal, ::test_typesinprotocols::kProtocol_OneWayCompound_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Compound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Compound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayCompound_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>::TransactionalRequest(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union)
    : body(::test_typesinprotocols::wire::Compound { bits, enum_, struct_, table, union_, opt_struct, opt_union } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayCompound_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Compound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Compound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>::WireResponse(::test_typesinprotocols::wire::Compound base) : ::test_typesinprotocols::wire::Compound(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>::WireResponse(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) : ::test_typesinprotocols::wire::Compound{ .bits = std::move(bits), .enum_ = std::move(enum_), .struct_ = std::move(struct_), .table = std::move(table), .union_ = std::move(union_), .opt_struct = std::move(opt_struct), .opt_union = std::move(opt_union)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>::TransactionalResponse(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>(bits, enum_, struct_, table, union_, opt_struct, opt_union)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayCompound_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Compound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorCompoundResult ProtocolErrorCompoundResult) : ::test_typesinprotocols::wire::ProtocolErrorCompoundResult(ProtocolErrorCompoundResult){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorCompoundResult ProtocolErrorCompoundResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>(ProtocolErrorCompoundResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorCompound_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>::TransactionalEvent(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union)
    : body{ bits, enum_, struct_, table, union_, opt_struct, opt_union } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventCompound_Ordinal, ::test_typesinprotocols::kProtocol_EventCompound_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventCompound_Ordinal, ::test_typesinprotocols::kProtocol_EventCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_OneWayArrayBasic_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>::TransactionalRequest(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string)
    : body(::test_typesinprotocols::wire::ArrayBasic { array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_OneWayArrayBasic_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::TransactionalRequest(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string)
    : body(::test_typesinprotocols::wire::ArrayBasic { array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireResponse(::test_typesinprotocols::wire::ArrayBasic base) : ::test_typesinprotocols::wire::ArrayBasic(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::WireResponse(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) : ::test_typesinprotocols::wire::ArrayBasic{ .array_uint8 = std::move(array_uint8), .array_uint16 = std::move(array_uint16), .array_uint32 = std::move(array_uint32), .array_uint64 = std::move(array_uint64), .array_int8 = std::move(array_int8), .array_int16 = std::move(array_int16), .array_int32 = std::move(array_int32), .array_int64 = std::move(array_int64), .array_float32 = std::move(array_float32), .array_float64 = std::move(array_float64), .array_string = std::move(array_string), .array_opt_string = std::move(array_opt_string)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::TransactionalResponse(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult ProtocolErrorArrayBasicResult) : ::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult(ProtocolErrorArrayBasicResult){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult ProtocolErrorArrayBasicResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>(ProtocolErrorArrayBasicResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayBasic_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>::TransactionalEvent(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string)
    : body{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_EventArrayBasic_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventArrayBasic_Ordinal, ::test_typesinprotocols::kProtocol_EventArrayBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_OneWayArrayCompound_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>::TransactionalRequest(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union)
    : body(::test_typesinprotocols::wire::ArrayCompound { array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_OneWayArrayCompound_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::TransactionalRequest(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union)
    : body(::test_typesinprotocols::wire::ArrayCompound { array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireResponse(::test_typesinprotocols::wire::ArrayCompound base) : ::test_typesinprotocols::wire::ArrayCompound(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::WireResponse(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) : ::test_typesinprotocols::wire::ArrayCompound{ .array_bits = std::move(array_bits), .array_enum = std::move(array_enum), .array_struct = std::move(array_struct), .array_table = std::move(array_table), .array_union = std::move(array_union), .array_opt_struct = std::move(array_opt_struct), .array_opt_union = std::move(array_opt_union)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::TransactionalResponse(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult ProtocolErrorArrayCompoundResult) : ::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult(ProtocolErrorArrayCompoundResult){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult ProtocolErrorArrayCompoundResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>(ProtocolErrorArrayCompoundResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayCompound_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>::TransactionalEvent(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union)
    : body{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_EventArrayCompound_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventArrayCompound_Ordinal, ::test_typesinprotocols::kProtocol_EventArrayCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_OneWayVectorBasic_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>::TransactionalRequest(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string)
    : body(::test_typesinprotocols::wire::VectorBasic { vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_OneWayVectorBasic_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::TransactionalRequest(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string)
    : body(::test_typesinprotocols::wire::VectorBasic { vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireResponse(::test_typesinprotocols::wire::VectorBasic base) : ::test_typesinprotocols::wire::VectorBasic(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::WireResponse(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) : ::test_typesinprotocols::wire::VectorBasic{ .vector_uint8 = std::move(vector_uint8), .vector_uint16 = std::move(vector_uint16), .vector_uint32 = std::move(vector_uint32), .vector_uint64 = std::move(vector_uint64), .vector_int8 = std::move(vector_int8), .vector_int16 = std::move(vector_int16), .vector_int32 = std::move(vector_int32), .vector_int64 = std::move(vector_int64), .vector_float32 = std::move(vector_float32), .vector_float64 = std::move(vector_float64), .vector_string = std::move(vector_string), .vector_opt_string = std::move(vector_opt_string)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::TransactionalResponse(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorBasic, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult ProtocolErrorVectorBasicResult) : ::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult(ProtocolErrorVectorBasicResult){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult ProtocolErrorVectorBasicResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>(ProtocolErrorVectorBasicResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorBasic_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorBasicResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>::TransactionalEvent(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string)
    : body{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_EventVectorBasic_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventVectorBasic_Ordinal, ::test_typesinprotocols::kProtocol_EventVectorBasic_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_OneWayVectorCompound_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>::TransactionalRequest(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union)
    : body(::test_typesinprotocols::wire::VectorCompound { vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_OneWayVectorCompound_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::TransactionalRequest(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union)
    : body(::test_typesinprotocols::wire::VectorCompound { vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireResponse(::test_typesinprotocols::wire::VectorCompound base) : ::test_typesinprotocols::wire::VectorCompound(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::WireResponse(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) : ::test_typesinprotocols::wire::VectorCompound{ .vector_bits = std::move(vector_bits), .vector_enum = std::move(vector_enum), .vector_struct = std::move(vector_struct), .vector_table = std::move(vector_table), .vector_union = std::move(vector_union), .vector_opt_struct = std::move(vector_opt_struct), .vector_opt_union = std::move(vector_opt_union)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::TransactionalResponse(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorCompound, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult ProtocolErrorVectorCompoundResult) : ::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult(ProtocolErrorVectorCompoundResult){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult ProtocolErrorVectorCompoundResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>(ProtocolErrorVectorCompoundResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorCompound_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorCompoundResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>::TransactionalEvent(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union)
    : body{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_EventVectorCompound_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventVectorCompound_Ordinal, ::test_typesinprotocols::kProtocol_EventVectorCompound_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_OneWayVectorOptional_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>::TransactionalRequest(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct)
    : body(::test_typesinprotocols::wire::VectorOptional { opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_OneWayVectorOptional_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::TransactionalRequest(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct)
    : body(::test_typesinprotocols::wire::VectorOptional { opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireResponse(::test_typesinprotocols::wire::VectorOptional base) : ::test_typesinprotocols::wire::VectorOptional(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::WireResponse(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) : ::test_typesinprotocols::wire::VectorOptional{ .opt_vector_uint8 = std::move(opt_vector_uint8), .opt_vector_string = std::move(opt_vector_string), .opt_vector_struct = std::move(opt_vector_struct), .opt_vector_opt_struct = std::move(opt_vector_opt_struct)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::TransactionalResponse(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayVectorOptional_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::VectorOptional, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorOptional_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult ProtocolErrorVectorOptionalResult) : ::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult(ProtocolErrorVectorOptionalResult){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult ProtocolErrorVectorOptionalResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>(ProtocolErrorVectorOptionalResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorOptional_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_ErrorVectorOptional_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorVectorOptionalResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>::TransactionalEvent(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct)
    : body{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_EventVectorOptional_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventVectorOptional_Ordinal, ::test_typesinprotocols::kProtocol_EventVectorOptional_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_OneWayArrayVectorNested_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>::TransactionalRequest(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8)
    : body(::test_typesinprotocols::wire::ArrayVectorNested { array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_OneWayArrayVectorNested_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::TransactionalRequest(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8)
    : body(::test_typesinprotocols::wire::ArrayVectorNested { array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_DynamicFlags);
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireResponse(::test_typesinprotocols::wire::ArrayVectorNested base) : ::test_typesinprotocols::wire::ArrayVectorNested(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::WireResponse(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) : ::test_typesinprotocols::wire::ArrayVectorNested{ .array_array_uint8 = std::move(array_array_uint8), .array_vector_uint8 = std::move(array_vector_uint8), .vector_array_uint8 = std::move(vector_array_uint8), .vector_vector_uint8 = std::move(vector_vector_uint8)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::TransactionalResponse(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayArrayVectorNested_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ArrayVectorNested, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayVectorNested_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult ProtocolErrorArrayVectorNestedResult) : ::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult(ProtocolErrorArrayVectorNestedResult){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult ProtocolErrorArrayVectorNestedResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(ProtocolErrorArrayVectorNestedResult)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayVectorNested_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_ErrorArrayVectorNested_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorArrayVectorNestedResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>::TransactionalEvent(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8)
    : body{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_EventArrayVectorNested_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventArrayVectorNested_Ordinal, ::test_typesinprotocols::kProtocol_EventArrayVectorNested_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayResource_Ordinal, ::test_typesinprotocols::kProtocol_OneWayResource_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>::TransactionalRequest(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union)
    : body(::test_typesinprotocols::wire::Resource { std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_OneWayResource_Ordinal, ::test_typesinprotocols::kProtocol_OneWayResource_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Resource, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Resource, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayResource_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayResource_DynamicFlags);
  }

    ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>::TransactionalRequest(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union)
    : body(::test_typesinprotocols::wire::Resource { std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union } ) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayResource_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayResource_DynamicFlags);
    }
    void ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>::_CloseHandles() {
        body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::test_typesinprotocols::wire::Resource, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::test_typesinprotocols::wire::Resource, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>::WireResponse(::test_typesinprotocols::wire::Resource base) : ::test_typesinprotocols::wire::Resource(std::move(base)) {}
    ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>::WireResponse(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) : ::test_typesinprotocols::wire::Resource{ .handle = std::move(handle), .vmo = std::move(vmo), .client_end = std::move(client_end), .server_end = std::move(server_end), .struct_ = std::move(struct_), .table = std::move(table), .union_ = std::move(union_), .opt_handle = std::move(opt_handle), .opt_vmo = std::move(opt_vmo), .opt_client_end = std::move(opt_client_end), .opt_server_end = std::move(opt_server_end), .opt_struct = std::move(opt_struct), .opt_union = std::move(opt_union), .array_handle = std::move(array_handle), .array_vmo = std::move(array_vmo), .array_client_end = std::move(array_client_end), .array_server_end = std::move(array_server_end), .array_struct = std::move(array_struct), .array_table = std::move(array_table), .array_union = std::move(array_union), .vector_handle = std::move(vector_handle), .vector_vmo = std::move(vector_vmo), .vector_client_end = std::move(vector_client_end), .vector_server_end = std::move(vector_server_end), .vector_struct = std::move(vector_struct), .vector_table = std::move(vector_table), .vector_union = std::move(vector_union)}{}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>::TransactionalResponse(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>(std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union)) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayResource_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayResource_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_TwoWayResource_Ordinal, ::test_typesinprotocols::kProtocol_TwoWayResource_DynamicFlags);
  }
    void ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::Resource, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::TwoWayResource>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::TwoWayResource>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>::TransactionalRequest() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorResource_Ordinal, ::test_typesinprotocols::kProtocol_ErrorResource_DynamicFlags);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>::WireResponse(::test_typesinprotocols::wire::ProtocolErrorResourceResult ProtocolErrorResourceResult) : ::test_typesinprotocols::wire::ProtocolErrorResourceResult(std::move(ProtocolErrorResourceResult)){}

    ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>::TransactionalResponse(::test_typesinprotocols::wire::ProtocolErrorResourceResult ProtocolErrorResourceResult)
    : body(::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>(std::move(ProtocolErrorResourceResult))) {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorResource_Ordinal, ::test_typesinprotocols::kProtocol_ErrorResource_DynamicFlags);
    }
  ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>::TransactionalResponse() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_ErrorResource_Ordinal, ::test_typesinprotocols::kProtocol_ErrorResource_DynamicFlags);
  }
    void ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_typesinprotocols::wire::ProtocolErrorResourceResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, false>;

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(internal::WireEncoder* encoder,
      ::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_typesinprotocols::Protocol::ErrorResource>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template
  struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_typesinprotocols::Protocol::ErrorResource>, ::fidl::internal::WireCodingConstraintEmpty, false>;

    ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>::TransactionalEvent(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union)
    : body{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union } {
      ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventResource_Ordinal, ::test_typesinprotocols::kProtocol_EventResource_DynamicFlags);
    }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>::TransactionalEvent() {
    ::fidl::InitTxnHeader(&header, 0, ::test_typesinprotocols::kProtocol_EventResource_Ordinal, ::test_typesinprotocols::kProtocol_EventResource_DynamicFlags);
  }
    void ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>::_CloseHandles() {
      body._CloseHandles();
    }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventResource>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template <bool IsRecursive>
  void ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_typesinprotocols::Protocol::EventResource>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }

  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::WireCodingConstraintEmpty, true>;
  template struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::WireCodingConstraintEmpty, false>;

      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayBasic> _request{ uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorBasic() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorBasic>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorBasic() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorBasic> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayCompound> _request{ bits, enum_, struct_, table, union_, opt_struct, opt_union };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorCompound() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorCompound>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorCompound() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorCompound> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayBasic> _request{ array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayBasic() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayBasic() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayBasic> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayCompound> _request{ array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayCompound() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayCompound() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayCompound> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorBasic> _request{ vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorBasic() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorBasic() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorBasic> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorBasic>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorCompound> _request{ vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorCompound() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorCompound() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorCompound> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorCompound>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayVectorOptional>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayVectorOptional> _request{ opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayVectorOptional>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorOptional() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorVectorOptional() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorVectorOptional> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorVectorOptional>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayArrayVectorNested>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested> _request{ array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayArrayVectorNested>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayVectorNested() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorArrayVectorNested() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorArrayVectorNested> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorArrayVectorNested>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::OneWayStatus
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::OneWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource> _request{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::OneWayResource>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::OneWayStatus
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::OneWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::OneWayResource> _request{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::OneWayResource>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource> _request{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::TwoWayResource>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayResource>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::TwoWayResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::TwoWayResource> _request{ std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::TwoWayResource>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }
      ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource>
      fidl::internal::WireSyncClientImpl<::test_typesinprotocols::Protocol>::ErrorResource() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource> _request{  };
        return ::fidl::WireResult<::test_typesinprotocols::Protocol::ErrorResource>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), &_request);
      }

      ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorResource>
      fidl::internal::WireSyncBufferClientImpl<::test_typesinprotocols::Protocol>::ErrorResource() {
        ::fidl::internal::TransactionalRequest<::test_typesinprotocols::Protocol::ErrorResource> _request{  };
        return ::fidl::WireUnownedResult<::test_typesinprotocols::Protocol::ErrorResource>(
          ::fidl::UnownedClientEnd<::test_typesinprotocols::Protocol>(_transport().get<::fidl::internal::ChannelTransport>()), _allocator(), &_request);
      }

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic> _response{uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic> _response{uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic> _response{uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventBasic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::fidl::StringView string, ::fidl::StringView opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic> _response{uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, string, opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventBasic>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound> _response{bits, enum_, struct_, table, union_, opt_struct, opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound> _response{bits, enum_, struct_, table, union_, opt_struct, opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound> _response{bits, enum_, struct_, table, union_, opt_struct, opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventCompound(::test_typesinprotocols::wire::Bits bits, ::test_typesinprotocols::wire::Enum enum_, const ::test_typesinprotocols::wire::Struct& struct_, ::test_typesinprotocols::wire::Table table, ::test_typesinprotocols::wire::Union union_, ::fidl::ObjectView<::test_typesinprotocols::wire::Struct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::Union> opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound> _response{bits, enum_, struct_, table, union_, opt_struct, opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventCompound>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic> _response{array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventArrayBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic> _response{array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic> _response{array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventArrayBasic(const ::fidl::Array<uint8_t, 5>& array_uint8, const ::fidl::Array<uint16_t, 5>& array_uint16, const ::fidl::Array<uint32_t, 5>& array_uint32, const ::fidl::Array<uint64_t, 5>& array_uint64, const ::fidl::Array<int8_t, 5>& array_int8, const ::fidl::Array<int16_t, 5>& array_int16, const ::fidl::Array<int32_t, 5>& array_int32, const ::fidl::Array<int64_t, 5>& array_int64, const ::fidl::Array<float, 5>& array_float32, const ::fidl::Array<double, 5>& array_float64, const ::fidl::Array<::fidl::StringView, 5>& array_string, const ::fidl::Array<::fidl::StringView, 5>& array_opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventArrayBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic> _response{array_uint8, array_uint16, array_uint32, array_uint64, array_int8, array_int16, array_int32, array_int64, array_float32, array_float64, array_string, array_opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayBasic>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound> _response{array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventArrayCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound> _response{array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound> _response{array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventArrayCompound(const ::fidl::Array<::test_typesinprotocols::wire::Bits, 5>& array_bits, const ::fidl::Array<::test_typesinprotocols::wire::Enum, 5>& array_enum, const ::fidl::Array<::test_typesinprotocols::wire::Struct, 5>& array_struct, const ::fidl::Array<::test_typesinprotocols::wire::Table, 5>& array_table, const ::fidl::Array<::test_typesinprotocols::wire::Union, 5>& array_union, const ::fidl::Array<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>, 5>& array_opt_struct, const ::fidl::Array<::fidl::WireOptional<::test_typesinprotocols::wire::Union>, 5>& array_opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventArrayCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound> _response{array_bits, array_enum, array_struct, array_table, array_union, array_opt_struct, array_opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayCompound>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic> _response{vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventVectorBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic> _response{vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic> _response{vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventVectorBasic(::fidl::VectorView<uint8_t> vector_uint8, ::fidl::VectorView<uint16_t> vector_uint16, ::fidl::VectorView<uint32_t> vector_uint32, ::fidl::VectorView<uint64_t> vector_uint64, ::fidl::VectorView<int8_t> vector_int8, ::fidl::VectorView<int16_t> vector_int16, ::fidl::VectorView<int32_t> vector_int32, ::fidl::VectorView<int64_t> vector_int64, ::fidl::VectorView<float> vector_float32, ::fidl::VectorView<double> vector_float64, ::fidl::VectorView<::fidl::StringView> vector_string, ::fidl::VectorView<::fidl::StringView> vector_opt_string) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventVectorBasic>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic> _response{vector_uint8, vector_uint16, vector_uint32, vector_uint64, vector_int8, vector_int16, vector_int32, vector_int64, vector_float32, vector_float64, vector_string, vector_opt_string };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorBasic>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound> _response{vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventVectorCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound> _response{vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound> _response{vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventVectorCompound(::fidl::VectorView<::test_typesinprotocols::wire::Bits> vector_bits, ::fidl::VectorView<::test_typesinprotocols::wire::Enum> vector_enum, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::Table> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::Union> vector_union, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> vector_opt_struct, ::fidl::VectorView<::fidl::WireOptional<::test_typesinprotocols::wire::Union>> vector_opt_union) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventVectorCompound>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound> _response{vector_bits, vector_enum, vector_struct, vector_table, vector_union, vector_opt_struct, vector_opt_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorCompound>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional> _response{opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventVectorOptional>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional> _response{opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional> _response{opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventVectorOptional(::fidl::VectorView<uint8_t> opt_vector_uint8, ::fidl::VectorView<::fidl::StringView> opt_vector_string, ::fidl::VectorView<::test_typesinprotocols::wire::Struct> opt_vector_struct, ::fidl::VectorView<::fidl::ObjectView<::test_typesinprotocols::wire::Struct>> opt_vector_opt_struct) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventVectorOptional>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional> _response{opt_vector_uint8, opt_vector_string, opt_vector_struct, opt_vector_opt_struct };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventVectorOptional>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested> _response{array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventArrayVectorNested>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested> _response{array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested> _response{array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventArrayVectorNested(const ::fidl::Array<::fidl::Array<uint8_t, 5>, 5>& array_array_uint8, const ::fidl::Array<::fidl::VectorView<uint8_t>, 5>& array_vector_uint8, ::fidl::VectorView<::fidl::Array<uint8_t, 5>> vector_array_uint8, ::fidl::VectorView<::fidl::VectorView<uint8_t>> vector_vector_uint8) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventArrayVectorNested>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested> _response{array_array_uint8, array_vector_uint8, vector_array_uint8, vector_vector_uint8 };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventArrayVectorNested>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

::fidl::OneWayStatus fidl::internal::WireWeakEventSender<::test_typesinprotocols::Protocol>::EventResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource> _response{std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireWeakBufferEventSender<::test_typesinprotocols::Protocol>::EventResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventResource>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource> _response{std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::ChannelTransport> _response_message(
      _allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::OneWayStatus fidl::internal::WireEventSender<::test_typesinprotocols::Protocol>::EventResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource> _response{std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::OwnedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::ChannelTransport> _response_message{
      ::fidl::internal::AllowUnownedInputRef{}, &_response
  };
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

fidl::OneWayStatus fidl::internal::WireBufferEventSender<::test_typesinprotocols::Protocol>::EventResource(::zx::handle&& handle, ::zx::vmo&& vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& server_end, ::test_typesinprotocols::wire::ResourceStruct&& struct_, ::test_typesinprotocols::wire::ResourceTable table, ::test_typesinprotocols::wire::ResourceUnion union_, ::zx::handle&& opt_handle, ::zx::vmo&& opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol>&& opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol>&& opt_server_end, ::fidl::ObjectView<::test_typesinprotocols::wire::ResourceStruct> opt_struct, ::fidl::WireOptional<::test_typesinprotocols::wire::ResourceUnion> opt_union, ::fidl::Array<::zx::handle, 5>&& array_handle, ::fidl::Array<::zx::vmo, 5>&& array_vmo, ::fidl::Array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>&& array_client_end, ::fidl::Array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>&& array_server_end, ::fidl::Array<::test_typesinprotocols::wire::ResourceStruct, 5>&& array_struct, ::fidl::Array<::test_typesinprotocols::wire::ResourceTable, 5>&& array_table, ::fidl::Array<::test_typesinprotocols::wire::ResourceUnion, 5>&& array_union, ::fidl::VectorView<::zx::handle> vector_handle, ::fidl::VectorView<::zx::vmo> vector_vmo, ::fidl::VectorView<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::fidl::VectorView<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceStruct> vector_struct, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceTable> vector_table, ::fidl::VectorView<::test_typesinprotocols::wire::ResourceUnion> vector_union) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<::test_typesinprotocols::Protocol::EventResource>();
  ::fit::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return fidl::OneWayStatus{_allocation.error_value()};
  }

  ::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource> _response{std::move(handle), std::move(vmo), std::move(client_end), std::move(server_end), std::move(struct_), table, std::move(union_), std::move(opt_handle), std::move(opt_vmo), std::move(opt_client_end), std::move(opt_server_end), opt_struct, std::move(opt_union), std::move(array_handle), std::move(array_vmo), std::move(array_client_end), std::move(array_server_end), std::move(array_struct), std::move(array_table), std::move(array_union), vector_handle, vector_vmo, vector_client_end, vector_server_end, vector_struct, vector_table, vector_union };
  ::fidl::internal::UnownedEncodedMessage<::fidl::internal::TransactionalEvent<::test_typesinprotocols::Protocol::EventResource>, ::fidl::internal::ChannelTransport> _response_message(
        _allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::OneWayStatus{::fidl::Status{_message}};
}

#pragma clang diagnostic pop

#endif  // __Fuchsia__

