// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <fidl/test.union/cpp/common_types.h>
#include <fidl/test.union/cpp/markers.h>
#include <lib/fidl/cpp/natural_coding_traits.h>
#include <lib/fidl/cpp/natural_types.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_union {

class Pizza;

class Pasta;

class NullableUnionStruct;

class Empty;

class TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse;

class TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse;

class StructWithNullableUnion;

class UnionSandwich;

class PizzaOrPasta;

class ExplicitPizzaOrPasta;

class FlexiblePizzaOrPasta;

class StrictPizzaOrPasta;

class Union;

class FlexibleUnion;

class StrictUnion;

class FieldCollision;

class ExplicitUnion;

class ReverseOrdinalUnion;

class FlexibleFoo;

class StrictFoo;

class ExplicitFoo;

class ExplicitStrictFoo;

class OlderSimpleUnion;

class NewerSimpleUnion;

class StrictSimpleUnion;

class UnionContainingEmptyStruct;

class StrictBoundedUnion;

class ExplicitFlexibleUnion;

class UnionWithAttributes;

class EmptyFlexibleUnion;

class Pizza {
 private:
  struct Storage_;

 public:
  Pizza(Storage_ storage) noexcept;
  Pizza(::std::vector<::std::string> toppings) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Pizza| only if all of its members are default constructible.
  Pizza() = default;
#pragma clang diagnostic pop

  Pizza(Pizza&&) noexcept = default;
  Pizza& operator=(Pizza&&) noexcept = default;
  Pizza(const Pizza& other) noexcept;
  Pizza& operator=(const Pizza& other) noexcept;

  bool operator==(const Pizza& other) const noexcept;
  bool operator!=(const Pizza& other) const noexcept;

  const ::std::vector<::std::string>&
  toppings() const;

  ::std::vector<::std::string>& toppings();

  // Setter for toppings.
  //

  Pizza& toppings(::std::vector<::std::string> value);

  Pizza(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::vector<::std::string> toppings;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::Pizza, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::Pizza>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::vector<::std::string>, fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<16>>>{
      &Storage_::toppings, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class Pasta {
 private:
  struct Storage_;

 public:
  Pasta(Storage_ storage) noexcept;
  Pasta(::std::string sauce) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Pasta| only if all of its members are default constructible.
  Pasta() = default;
#pragma clang diagnostic pop

  Pasta(Pasta&&) noexcept = default;
  Pasta& operator=(Pasta&&) noexcept = default;
  Pasta(const Pasta& other) noexcept;
  Pasta& operator=(const Pasta& other) noexcept;

  bool operator==(const Pasta& other) const noexcept;
  bool operator!=(const Pasta& other) const noexcept;

  const ::std::string&
  sauce() const;

  ::std::string& sauce();

  // Setter for sauce.
  //

  Pasta& sauce(::std::string value);

  Pasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::std::string sauce;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::Pasta, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::Pasta>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::std::string, fidl::internal::NaturalCodingConstraintString<16>>{
      &Storage_::sauce, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class PizzaOrPasta {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_union::Pizza, ::test_union::Pasta>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  PizzaOrPasta(PizzaOrPasta&& other) noexcept;
  PizzaOrPasta& operator=(PizzaOrPasta&& other) noexcept;
  PizzaOrPasta(const PizzaOrPasta& other) noexcept;
  PizzaOrPasta& operator=(const PizzaOrPasta& other) noexcept;
  bool operator==(const PizzaOrPasta& other) const noexcept;
  bool operator!=(const PizzaOrPasta& other) const noexcept;

  ::test_union::PizzaOrPasta::Tag Which() const;
  static PizzaOrPasta WithPizza(::test_union::Pizza val);
  const ::fidl::internal::UnionMemberView<1, Storage_> pizza() const;
  ::fidl::internal::UnionMemberView<1, Storage_> pizza();

  // Sets the union to hold the pizza member.
  //

  PizzaOrPasta& pizza(::test_union::Pizza value);
  static PizzaOrPasta WithPasta(::test_union::Pasta val);
  const ::fidl::internal::UnionMemberView<2, Storage_> pasta() const;
  ::fidl::internal::UnionMemberView<2, Storage_> pasta();

  // Sets the union to hold the pasta member.
  //

  PizzaOrPasta& pasta(::test_union::Pasta value);

  PizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::PizzaOrPasta>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit PizzaOrPasta(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::PizzaOrPasta::Tag tag);
  static std::optional<::test_union::PizzaOrPasta::Tag> IndexToTag(size_t index);
};

class ExplicitPizzaOrPasta {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_union::Pizza, ::test_union::Pasta>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&& other) noexcept;
  ExplicitPizzaOrPasta& operator=(ExplicitPizzaOrPasta&& other) noexcept;
  ExplicitPizzaOrPasta(const ExplicitPizzaOrPasta& other) noexcept;
  ExplicitPizzaOrPasta& operator=(const ExplicitPizzaOrPasta& other) noexcept;
  bool operator==(const ExplicitPizzaOrPasta& other) const noexcept;
  bool operator!=(const ExplicitPizzaOrPasta& other) const noexcept;

  ::test_union::ExplicitPizzaOrPasta::Tag Which() const;
  static ExplicitPizzaOrPasta WithPizza(::test_union::Pizza val);
  const ::fidl::internal::UnionMemberView<1, Storage_> pizza() const;
  ::fidl::internal::UnionMemberView<1, Storage_> pizza();

  // Sets the union to hold the pizza member.
  //

  ExplicitPizzaOrPasta& pizza(::test_union::Pizza value);
  static ExplicitPizzaOrPasta WithPasta(::test_union::Pasta val);
  const ::fidl::internal::UnionMemberView<2, Storage_> pasta() const;
  ::fidl::internal::UnionMemberView<2, Storage_> pasta();

  // Sets the union to hold the pasta member.
  //

  ExplicitPizzaOrPasta& pasta(::test_union::Pasta value);

  ExplicitPizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitPizzaOrPasta>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ExplicitPizzaOrPasta(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitPizzaOrPasta::Tag tag);
  static std::optional<::test_union::ExplicitPizzaOrPasta::Tag> IndexToTag(size_t index);
};

class FlexiblePizzaOrPasta {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_union::Pizza, ::test_union::Pasta>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&& other) noexcept;
  FlexiblePizzaOrPasta& operator=(FlexiblePizzaOrPasta&& other) noexcept;
  FlexiblePizzaOrPasta(const FlexiblePizzaOrPasta& other) noexcept;
  FlexiblePizzaOrPasta& operator=(const FlexiblePizzaOrPasta& other) noexcept;
  bool operator==(const FlexiblePizzaOrPasta& other) const noexcept;
  bool operator!=(const FlexiblePizzaOrPasta& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::FlexiblePizzaOrPasta::Tag Which() const;
  static FlexiblePizzaOrPasta WithPizza(::test_union::Pizza val);
  const ::fidl::internal::UnionMemberView<1, Storage_> pizza() const;
  ::fidl::internal::UnionMemberView<1, Storage_> pizza();

  // Sets the union to hold the pizza member.
  //

  FlexiblePizzaOrPasta& pizza(::test_union::Pizza value);
  static FlexiblePizzaOrPasta WithPasta(::test_union::Pasta val);
  const ::fidl::internal::UnionMemberView<2, Storage_> pasta() const;
  ::fidl::internal::UnionMemberView<2, Storage_> pasta();

  // Sets the union to hold the pasta member.
  //

  FlexiblePizzaOrPasta& pasta(::test_union::Pasta value);

  FlexiblePizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::FlexiblePizzaOrPasta>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit FlexiblePizzaOrPasta(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::FlexiblePizzaOrPasta::Tag tag);
  static std::optional<::test_union::FlexiblePizzaOrPasta::Tag> IndexToTag(size_t index);
};

class StrictPizzaOrPasta {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_union::Pizza, ::test_union::Pasta>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  StrictPizzaOrPasta(StrictPizzaOrPasta&& other) noexcept;
  StrictPizzaOrPasta& operator=(StrictPizzaOrPasta&& other) noexcept;
  StrictPizzaOrPasta(const StrictPizzaOrPasta& other) noexcept;
  StrictPizzaOrPasta& operator=(const StrictPizzaOrPasta& other) noexcept;
  bool operator==(const StrictPizzaOrPasta& other) const noexcept;
  bool operator!=(const StrictPizzaOrPasta& other) const noexcept;

  ::test_union::StrictPizzaOrPasta::Tag Which() const;
  static StrictPizzaOrPasta WithPizza(::test_union::Pizza val);
  const ::fidl::internal::UnionMemberView<1, Storage_> pizza() const;
  ::fidl::internal::UnionMemberView<1, Storage_> pizza();

  // Sets the union to hold the pizza member.
  //

  StrictPizzaOrPasta& pizza(::test_union::Pizza value);
  static StrictPizzaOrPasta WithPasta(::test_union::Pasta val);
  const ::fidl::internal::UnionMemberView<2, Storage_> pasta() const;
  ::fidl::internal::UnionMemberView<2, Storage_> pasta();

  // Sets the union to hold the pasta member.
  //

  StrictPizzaOrPasta& pasta(::test_union::Pasta value);

  StrictPizzaOrPasta(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictPizzaOrPasta>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit StrictPizzaOrPasta(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictPizzaOrPasta::Tag tag);
  static std::optional<::test_union::StrictPizzaOrPasta::Tag> IndexToTag(size_t index);
};

class Union {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int32_t, ::std::string, ::std::vector<::std::string>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  Union(Union&& other) noexcept;
  Union& operator=(Union&& other) noexcept;
  Union(const Union& other) noexcept;
  Union& operator=(const Union& other) noexcept;
  bool operator==(const Union& other) const noexcept;
  bool operator!=(const Union& other) const noexcept;

  ::test_union::Union::Tag Which() const;
  static Union WithPrimitive(int32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> primitive() const;
  ::fidl::internal::UnionMemberView<1, Storage_> primitive();

  // Sets the union to hold the primitive member.
  //

  Union& primitive(int32_t value);
  static Union WithStringNeedsConstructor(::std::string val);
  const ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor() const;
  ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor();

  // Sets the union to hold the string_needs_constructor member.
  //

  Union& string_needs_constructor(::std::string value);
  static Union WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string> val);
  const ::fidl::internal::UnionMemberView<3, Storage_> vector_string_also_needs_constructor() const;
  ::fidl::internal::UnionMemberView<3, Storage_> vector_string_also_needs_constructor();

  // Sets the union to hold the vector_string_also_needs_constructor member.
  //

  Union& vector_string_also_needs_constructor(::std::vector<::std::string> value);

  Union(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::Union>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>());

  explicit Union(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::Union::Tag tag);
  static std::optional<::test_union::Union::Tag> IndexToTag(size_t index);
};

class FlexibleUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int32_t, ::std::string, ::std::vector<::std::string>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  FlexibleUnion(FlexibleUnion&& other) noexcept;
  FlexibleUnion& operator=(FlexibleUnion&& other) noexcept;
  FlexibleUnion(const FlexibleUnion& other) noexcept;
  FlexibleUnion& operator=(const FlexibleUnion& other) noexcept;
  bool operator==(const FlexibleUnion& other) const noexcept;
  bool operator!=(const FlexibleUnion& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::FlexibleUnion::Tag Which() const;
  static FlexibleUnion WithPrimitive(int32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> primitive() const;
  ::fidl::internal::UnionMemberView<1, Storage_> primitive();

  // Sets the union to hold the primitive member.
  //

  FlexibleUnion& primitive(int32_t value);
  static FlexibleUnion WithStringNeedsConstructor(::std::string val);
  const ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor() const;
  ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor();

  // Sets the union to hold the string_needs_constructor member.
  //

  FlexibleUnion& string_needs_constructor(::std::string value);
  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string> val);
  const ::fidl::internal::UnionMemberView<3, Storage_> vector_string_also_needs_constructor() const;
  ::fidl::internal::UnionMemberView<3, Storage_> vector_string_also_needs_constructor();

  // Sets the union to hold the vector_string_also_needs_constructor member.
  //

  FlexibleUnion& vector_string_also_needs_constructor(::std::vector<::std::string> value);

  FlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::FlexibleUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>());

  explicit FlexibleUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::FlexibleUnion::Tag tag);
  static std::optional<::test_union::FlexibleUnion::Tag> IndexToTag(size_t index);
};

class StrictUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int32_t, ::std::string, ::std::vector<::std::string>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  StrictUnion(StrictUnion&& other) noexcept;
  StrictUnion& operator=(StrictUnion&& other) noexcept;
  StrictUnion(const StrictUnion& other) noexcept;
  StrictUnion& operator=(const StrictUnion& other) noexcept;
  bool operator==(const StrictUnion& other) const noexcept;
  bool operator!=(const StrictUnion& other) const noexcept;

  ::test_union::StrictUnion::Tag Which() const;
  static StrictUnion WithPrimitive(int32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> primitive() const;
  ::fidl::internal::UnionMemberView<1, Storage_> primitive();

  // Sets the union to hold the primitive member.
  //

  StrictUnion& primitive(int32_t value);
  static StrictUnion WithStringNeedsConstructor(::std::string val);
  const ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor() const;
  ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor();

  // Sets the union to hold the string_needs_constructor member.
  //

  StrictUnion& string_needs_constructor(::std::string value);
  static StrictUnion WithVectorStringAlsoNeedsConstructor(::std::vector<::std::string> val);
  const ::fidl::internal::UnionMemberView<3, Storage_> vector_string_also_needs_constructor() const;
  ::fidl::internal::UnionMemberView<3, Storage_> vector_string_also_needs_constructor();

  // Sets the union to hold the vector_string_also_needs_constructor member.
  //

  StrictUnion& vector_string_also_needs_constructor(::std::vector<::std::string> value);

  StrictUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>());

  explicit StrictUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictUnion::Tag tag);
  static std::optional<::test_union::StrictUnion::Tag> IndexToTag(size_t index);
};

class FieldCollision {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  FieldCollision(FieldCollision&& other) noexcept;
  FieldCollision& operator=(FieldCollision&& other) noexcept;
  FieldCollision(const FieldCollision& other) noexcept;
  FieldCollision& operator=(const FieldCollision& other) noexcept;
  bool operator==(const FieldCollision& other) const noexcept;
  bool operator!=(const FieldCollision& other) const noexcept;

  ::test_union::FieldCollision::Tag Which() const;
  static FieldCollision WithFieldCollisionTag(int32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> field_collision_tag() const;
  ::fidl::internal::UnionMemberView<1, Storage_> field_collision_tag();

  // Sets the union to hold the field_collision_tag member.
  //

  FieldCollision& field_collision_tag(int32_t value);

  FieldCollision(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::FieldCollision>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit FieldCollision(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::FieldCollision::Tag tag);
  static std::optional<::test_union::FieldCollision::Tag> IndexToTag(size_t index);
};

class ExplicitUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int32_t, ::std::string>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,               // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  ExplicitUnion(ExplicitUnion&& other) noexcept;
  ExplicitUnion& operator=(ExplicitUnion&& other) noexcept;
  ExplicitUnion(const ExplicitUnion& other) noexcept;
  ExplicitUnion& operator=(const ExplicitUnion& other) noexcept;
  bool operator==(const ExplicitUnion& other) const noexcept;
  bool operator!=(const ExplicitUnion& other) const noexcept;

  ::test_union::ExplicitUnion::Tag Which() const;
  static ExplicitUnion WithPrimitive(int32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> primitive() const;
  ::fidl::internal::UnionMemberView<1, Storage_> primitive();

  // Sets the union to hold the primitive member.
  //

  ExplicitUnion& primitive(int32_t value);
  static ExplicitUnion WithStringNeedsConstructor(::std::string val);
  const ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor() const;
  ::fidl::internal::UnionMemberView<2, Storage_> string_needs_constructor();

  // Sets the union to hold the string_needs_constructor member.
  //

  ExplicitUnion& string_needs_constructor(::std::string value);

  ExplicitUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>());

  explicit ExplicitUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitUnion::Tag tag);
  static std::optional<::test_union::ExplicitUnion::Tag> IndexToTag(size_t index);
};

class ReverseOrdinalUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, uint32_t, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kFirst = 1,   // 0x1
    kSecond = 2,  // 0x2
  };

  ReverseOrdinalUnion(ReverseOrdinalUnion&& other) noexcept;
  ReverseOrdinalUnion& operator=(ReverseOrdinalUnion&& other) noexcept;
  ReverseOrdinalUnion(const ReverseOrdinalUnion& other) noexcept;
  ReverseOrdinalUnion& operator=(const ReverseOrdinalUnion& other) noexcept;
  bool operator==(const ReverseOrdinalUnion& other) const noexcept;
  bool operator!=(const ReverseOrdinalUnion& other) const noexcept;

  ::test_union::ReverseOrdinalUnion::Tag Which() const;
  static ReverseOrdinalUnion WithFirst(uint32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> first() const;
  ::fidl::internal::UnionMemberView<1, Storage_> first();

  // Sets the union to hold the first member.
  //

  ReverseOrdinalUnion& first(uint32_t value);
  static ReverseOrdinalUnion WithSecond(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> second() const;
  ::fidl::internal::UnionMemberView<2, Storage_> second();

  // Sets the union to hold the second member.
  //

  ReverseOrdinalUnion& second(uint32_t value);

  ReverseOrdinalUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::ReverseOrdinalUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ReverseOrdinalUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ReverseOrdinalUnion::Tag tag);
  static std::optional<::test_union::ReverseOrdinalUnion::Tag> IndexToTag(size_t index);
};

class NullableUnionStruct {
 private:
  struct Storage_;

 public:
  NullableUnionStruct(Storage_ storage) noexcept;
  NullableUnionStruct(::fidl::Box<::test_union::Union> the_union) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |NullableUnionStruct| only if all of its members are default constructible.
  NullableUnionStruct() = default;
#pragma clang diagnostic pop

  NullableUnionStruct(NullableUnionStruct&&) noexcept = default;
  NullableUnionStruct& operator=(NullableUnionStruct&&) noexcept = default;
  NullableUnionStruct(const NullableUnionStruct& other) noexcept;
  NullableUnionStruct& operator=(const NullableUnionStruct& other) noexcept;

  bool operator==(const NullableUnionStruct& other) const noexcept;
  bool operator!=(const NullableUnionStruct& other) const noexcept;

  const ::fidl::Box<::test_union::Union>&
  the_union() const;

  ::fidl::Box<::test_union::Union>& the_union();

  // Setter for the_union.
  //

  NullableUnionStruct& the_union(::fidl::Box<::test_union::Union> value);

  NullableUnionStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::fidl::Box<::test_union::Union> the_union;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::NullableUnionStruct, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::NullableUnionStruct>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_union::Union>, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::the_union, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class FlexibleFoo {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::std::string, int32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  FlexibleFoo(FlexibleFoo&& other) noexcept;
  FlexibleFoo& operator=(FlexibleFoo&& other) noexcept;
  FlexibleFoo(const FlexibleFoo& other) noexcept;
  FlexibleFoo& operator=(const FlexibleFoo& other) noexcept;
  bool operator==(const FlexibleFoo& other) const noexcept;
  bool operator!=(const FlexibleFoo& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::FlexibleFoo::Tag Which() const;
  static FlexibleFoo WithS(::std::string val);
  const ::fidl::internal::UnionMemberView<1, Storage_> s() const;
  ::fidl::internal::UnionMemberView<1, Storage_> s();

  // Sets the union to hold the s member.
  //

  FlexibleFoo& s(::std::string value);
  static FlexibleFoo WithI(int32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> i() const;
  ::fidl::internal::UnionMemberView<2, Storage_> i();

  // Sets the union to hold the i member.
  //

  FlexibleFoo& i(int32_t value);

  FlexibleFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::FlexibleFoo>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit FlexibleFoo(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::FlexibleFoo::Tag tag);
  static std::optional<::test_union::FlexibleFoo::Tag> IndexToTag(size_t index);
};

class StrictFoo {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::std::string, int32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  StrictFoo(StrictFoo&& other) noexcept;
  StrictFoo& operator=(StrictFoo&& other) noexcept;
  StrictFoo(const StrictFoo& other) noexcept;
  StrictFoo& operator=(const StrictFoo& other) noexcept;
  bool operator==(const StrictFoo& other) const noexcept;
  bool operator!=(const StrictFoo& other) const noexcept;

  ::test_union::StrictFoo::Tag Which() const;
  static StrictFoo WithS(::std::string val);
  const ::fidl::internal::UnionMemberView<1, Storage_> s() const;
  ::fidl::internal::UnionMemberView<1, Storage_> s();

  // Sets the union to hold the s member.
  //

  StrictFoo& s(::std::string value);
  static StrictFoo WithI(int32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> i() const;
  ::fidl::internal::UnionMemberView<2, Storage_> i();

  // Sets the union to hold the i member.
  //

  StrictFoo& i(int32_t value);

  StrictFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictFoo>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit StrictFoo(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictFoo::Tag tag);
  static std::optional<::test_union::StrictFoo::Tag> IndexToTag(size_t index);
};

class ExplicitFoo {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int32_t, ::std::string>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  ExplicitFoo(ExplicitFoo&& other) noexcept;
  ExplicitFoo& operator=(ExplicitFoo&& other) noexcept;
  ExplicitFoo(const ExplicitFoo& other) noexcept;
  ExplicitFoo& operator=(const ExplicitFoo& other) noexcept;
  bool operator==(const ExplicitFoo& other) const noexcept;
  bool operator!=(const ExplicitFoo& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::ExplicitFoo::Tag Which() const;
  static ExplicitFoo WithI(int32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> i() const;
  ::fidl::internal::UnionMemberView<1, Storage_> i();

  // Sets the union to hold the i member.
  //

  ExplicitFoo& i(int32_t value);
  static ExplicitFoo WithS(::std::string val);
  const ::fidl::internal::UnionMemberView<2, Storage_> s() const;
  ::fidl::internal::UnionMemberView<2, Storage_> s();

  // Sets the union to hold the s member.
  //

  ExplicitFoo& s(::std::string value);

  ExplicitFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitFoo>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>());

  explicit ExplicitFoo(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitFoo::Tag tag);
  static std::optional<::test_union::ExplicitFoo::Tag> IndexToTag(size_t index);
};

class ExplicitStrictFoo {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int32_t, ::std::string>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kI = 2,  // 0x2
    kS = 3,  // 0x3
  };

  ExplicitStrictFoo(ExplicitStrictFoo&& other) noexcept;
  ExplicitStrictFoo& operator=(ExplicitStrictFoo&& other) noexcept;
  ExplicitStrictFoo(const ExplicitStrictFoo& other) noexcept;
  ExplicitStrictFoo& operator=(const ExplicitStrictFoo& other) noexcept;
  bool operator==(const ExplicitStrictFoo& other) const noexcept;
  bool operator!=(const ExplicitStrictFoo& other) const noexcept;

  ::test_union::ExplicitStrictFoo::Tag Which() const;
  static ExplicitStrictFoo WithI(int32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> i() const;
  ::fidl::internal::UnionMemberView<1, Storage_> i();

  // Sets the union to hold the i member.
  //

  ExplicitStrictFoo& i(int32_t value);
  static ExplicitStrictFoo WithS(::std::string val);
  const ::fidl::internal::UnionMemberView<2, Storage_> s() const;
  ::fidl::internal::UnionMemberView<2, Storage_> s();

  // Sets the union to hold the s member.
  //

  ExplicitStrictFoo& s(::std::string value);

  ExplicitStrictFoo(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitStrictFoo>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>());

  explicit ExplicitStrictFoo(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitStrictFoo::Tag tag);
  static std::optional<::test_union::ExplicitStrictFoo::Tag> IndexToTag(size_t index);
};

class OlderSimpleUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int64_t, float>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  OlderSimpleUnion(OlderSimpleUnion&& other) noexcept;
  OlderSimpleUnion& operator=(OlderSimpleUnion&& other) noexcept;
  OlderSimpleUnion(const OlderSimpleUnion& other) noexcept;
  OlderSimpleUnion& operator=(const OlderSimpleUnion& other) noexcept;
  bool operator==(const OlderSimpleUnion& other) const noexcept;
  bool operator!=(const OlderSimpleUnion& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::OlderSimpleUnion::Tag Which() const;
  static OlderSimpleUnion WithI(int64_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> i() const;
  ::fidl::internal::UnionMemberView<1, Storage_> i();

  // Sets the union to hold the i member.
  //

  OlderSimpleUnion& i(int64_t value);
  static OlderSimpleUnion WithF(float val);
  const ::fidl::internal::UnionMemberView<2, Storage_> f() const;
  ::fidl::internal::UnionMemberView<2, Storage_> f();

  // Sets the union to hold the f member.
  //

  OlderSimpleUnion& f(float value);

  OlderSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::OlderSimpleUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit OlderSimpleUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::OlderSimpleUnion::Tag tag);
  static std::optional<::test_union::OlderSimpleUnion::Tag> IndexToTag(size_t index);
};

class NewerSimpleUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int64_t, ::std::string, ::std::vector<::std::string>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  NewerSimpleUnion(NewerSimpleUnion&& other) noexcept;
  NewerSimpleUnion& operator=(NewerSimpleUnion&& other) noexcept;
  NewerSimpleUnion(const NewerSimpleUnion& other) noexcept;
  NewerSimpleUnion& operator=(const NewerSimpleUnion& other) noexcept;
  bool operator==(const NewerSimpleUnion& other) const noexcept;
  bool operator!=(const NewerSimpleUnion& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::NewerSimpleUnion::Tag Which() const;
  static NewerSimpleUnion WithI(int64_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> i() const;
  ::fidl::internal::UnionMemberView<1, Storage_> i();

  // Sets the union to hold the i member.
  //

  NewerSimpleUnion& i(int64_t value);
  static NewerSimpleUnion WithS(::std::string val);
  const ::fidl::internal::UnionMemberView<2, Storage_> s() const;
  ::fidl::internal::UnionMemberView<2, Storage_> s();

  // Sets the union to hold the s member.
  //

  NewerSimpleUnion& s(::std::string value);
  static NewerSimpleUnion WithV(::std::vector<::std::string> val);
  const ::fidl::internal::UnionMemberView<3, Storage_> v() const;
  ::fidl::internal::UnionMemberView<3, Storage_> v();

  // Sets the union to hold the v member.
  //

  NewerSimpleUnion& v(::std::vector<::std::string> value);

  NewerSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::NewerSimpleUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintString<>>>());

  explicit NewerSimpleUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::NewerSimpleUnion::Tag tag);
  static std::optional<::test_union::NewerSimpleUnion::Tag> IndexToTag(size_t index);
};

class StrictSimpleUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int32_t, float, ::std::string>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  StrictSimpleUnion(StrictSimpleUnion&& other) noexcept;
  StrictSimpleUnion& operator=(StrictSimpleUnion&& other) noexcept;
  StrictSimpleUnion(const StrictSimpleUnion& other) noexcept;
  StrictSimpleUnion& operator=(const StrictSimpleUnion& other) noexcept;
  bool operator==(const StrictSimpleUnion& other) const noexcept;
  bool operator!=(const StrictSimpleUnion& other) const noexcept;

  ::test_union::StrictSimpleUnion::Tag Which() const;
  static StrictSimpleUnion WithI(int32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> i() const;
  ::fidl::internal::UnionMemberView<1, Storage_> i();

  // Sets the union to hold the i member.
  //

  StrictSimpleUnion& i(int32_t value);
  static StrictSimpleUnion WithF(float val);
  const ::fidl::internal::UnionMemberView<2, Storage_> f() const;
  ::fidl::internal::UnionMemberView<2, Storage_> f();

  // Sets the union to hold the f member.
  //

  StrictSimpleUnion& f(float value);
  static StrictSimpleUnion WithS(::std::string val);
  const ::fidl::internal::UnionMemberView<3, Storage_> s() const;
  ::fidl::internal::UnionMemberView<3, Storage_> s();

  // Sets the union to hold the s member.
  //

  StrictSimpleUnion& s(::std::string value);

  StrictSimpleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictSimpleUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintString<>>());

  explicit StrictSimpleUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictSimpleUnion::Tag tag);
  static std::optional<::test_union::StrictSimpleUnion::Tag> IndexToTag(size_t index);
};

class Empty {
 private:
  struct Storage_;

 public:
  Empty(Storage_ storage) noexcept;
  Empty(uint8_t __reserved) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |Empty| only if all of its members are default constructible.
  Empty() = default;
#pragma clang diagnostic pop

  Empty(Empty&&) noexcept = default;
  Empty& operator=(Empty&&) noexcept = default;
  Empty(const Empty& other) noexcept;
  Empty& operator=(const Empty& other) noexcept;

  bool operator==(const Empty& other) const noexcept;
  bool operator!=(const Empty& other) const noexcept;

  uint8_t
  __reserved() const;

  uint8_t& __reserved();

  // Setter for __reserved.
  //

  Empty& __reserved(uint8_t value);

  Empty(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    uint8_t __reserved = 0u;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::Empty, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::Empty>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::__reserved, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class UnionContainingEmptyStruct {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_union::Empty>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kEmpty = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  UnionContainingEmptyStruct(UnionContainingEmptyStruct&& other) noexcept;
  UnionContainingEmptyStruct& operator=(UnionContainingEmptyStruct&& other) noexcept;
  UnionContainingEmptyStruct(const UnionContainingEmptyStruct& other) noexcept;
  UnionContainingEmptyStruct& operator=(const UnionContainingEmptyStruct& other) noexcept;
  bool operator==(const UnionContainingEmptyStruct& other) const noexcept;
  bool operator!=(const UnionContainingEmptyStruct& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::UnionContainingEmptyStruct::Tag Which() const;
  static UnionContainingEmptyStruct WithEmpty(::test_union::Empty val);
  const ::fidl::internal::UnionMemberView<1, Storage_> empty() const;
  ::fidl::internal::UnionMemberView<1, Storage_> empty();

  // Sets the union to hold the empty member.
  //

  UnionContainingEmptyStruct& empty(::test_union::Empty value);

  UnionContainingEmptyStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::UnionContainingEmptyStruct>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit UnionContainingEmptyStruct(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::UnionContainingEmptyStruct::Tag tag);
  static std::optional<::test_union::UnionContainingEmptyStruct::Tag> IndexToTag(size_t index);
};

class StrictBoundedUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::std::vector<uint8_t>>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
  };

  StrictBoundedUnion(StrictBoundedUnion&& other) noexcept;
  StrictBoundedUnion& operator=(StrictBoundedUnion&& other) noexcept;
  StrictBoundedUnion(const StrictBoundedUnion& other) noexcept;
  StrictBoundedUnion& operator=(const StrictBoundedUnion& other) noexcept;
  bool operator==(const StrictBoundedUnion& other) const noexcept;
  bool operator!=(const StrictBoundedUnion& other) const noexcept;

  ::test_union::StrictBoundedUnion::Tag Which() const;
  static StrictBoundedUnion WithV(::std::vector<uint8_t> val);
  const ::fidl::internal::UnionMemberView<1, Storage_> v() const;
  ::fidl::internal::UnionMemberView<1, Storage_> v();

  // Sets the union to hold the v member.
  //

  StrictBoundedUnion& v(::std::vector<uint8_t> value);

  StrictBoundedUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictBoundedUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintVector<fidl::internal::NaturalCodingConstraintEmpty, 10>>());

  explicit StrictBoundedUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::StrictBoundedUnion::Tag tag);
  static std::optional<::test_union::StrictBoundedUnion::Tag> IndexToTag(size_t index);
};

class TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
 private:
  struct Storage_;

 public:
  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(Storage_ storage) noexcept;
  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(::test_union::StrictBoundedUnion xu) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse| only if all of its members are default constructible.
  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse() = default;
#pragma clang diagnostic pop

  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse&&) noexcept = default;
  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& operator=(TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse&&) noexcept = default;
  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(const TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& other) noexcept;
  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& operator=(const TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& other) noexcept;

  bool operator==(const TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& other) const noexcept;
  bool operator!=(const TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& other) const noexcept;

  const ::test_union::StrictBoundedUnion&
  xu() const;

  ::test_union::StrictBoundedUnion& xu();

  // Setter for xu.
  //

  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse& xu(::test_union::StrictBoundedUnion value);

  TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::test_union::StrictBoundedUnion xu;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_union::StrictBoundedUnion, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::xu, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
 private:
  struct Storage_;

 public:
  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(Storage_ storage) noexcept;
  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(::test_union::OlderSimpleUnion xu) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse| only if all of its members are default constructible.
  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse() = default;
#pragma clang diagnostic pop

  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse&&) noexcept = default;
  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& operator=(TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse&&) noexcept = default;
  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(const TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& other) noexcept;
  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& operator=(const TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& other) noexcept;

  bool operator==(const TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& other) const noexcept;
  bool operator!=(const TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& other) const noexcept;

  const ::test_union::OlderSimpleUnion&
  xu() const;

  ::test_union::OlderSimpleUnion& xu();

  // Setter for xu.
  //

  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse& xu(::test_union::OlderSimpleUnion value);

  TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::test_union::OlderSimpleUnion xu;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_union::OlderSimpleUnion, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::xu, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class StructWithNullableUnion {
 private:
  struct Storage_;

 public:
  StructWithNullableUnion(Storage_ storage) noexcept;
  StructWithNullableUnion(::fidl::Box<::test_union::OlderSimpleUnion> x1) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |StructWithNullableUnion| only if all of its members are default constructible.
  StructWithNullableUnion() = default;
#pragma clang diagnostic pop

  StructWithNullableUnion(StructWithNullableUnion&&) noexcept = default;
  StructWithNullableUnion& operator=(StructWithNullableUnion&&) noexcept = default;
  StructWithNullableUnion(const StructWithNullableUnion& other) noexcept;
  StructWithNullableUnion& operator=(const StructWithNullableUnion& other) noexcept;

  bool operator==(const StructWithNullableUnion& other) const noexcept;
  bool operator!=(const StructWithNullableUnion& other) const noexcept;

  const ::fidl::Box<::test_union::OlderSimpleUnion>&
  x1() const;

  ::fidl::Box<::test_union::OlderSimpleUnion>& x1();

  // Setter for x1.
  //

  StructWithNullableUnion& x1(::fidl::Box<::test_union::OlderSimpleUnion> value);

  StructWithNullableUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::fidl::Box<::test_union::OlderSimpleUnion> x1;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::StructWithNullableUnion, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::StructWithNullableUnion>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::fidl::Box<::test_union::OlderSimpleUnion>, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::x1, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class ExplicitFlexibleUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int64_t, float>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 4,  // 0x4
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  ExplicitFlexibleUnion(ExplicitFlexibleUnion&& other) noexcept;
  ExplicitFlexibleUnion& operator=(ExplicitFlexibleUnion&& other) noexcept;
  ExplicitFlexibleUnion(const ExplicitFlexibleUnion& other) noexcept;
  ExplicitFlexibleUnion& operator=(const ExplicitFlexibleUnion& other) noexcept;
  bool operator==(const ExplicitFlexibleUnion& other) const noexcept;
  bool operator!=(const ExplicitFlexibleUnion& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::ExplicitFlexibleUnion::Tag Which() const;
  static ExplicitFlexibleUnion WithI(int64_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> i() const;
  ::fidl::internal::UnionMemberView<1, Storage_> i();

  // Sets the union to hold the i member.
  //

  ExplicitFlexibleUnion& i(int64_t value);
  static ExplicitFlexibleUnion WithF(float val);
  const ::fidl::internal::UnionMemberView<2, Storage_> f() const;
  ::fidl::internal::UnionMemberView<2, Storage_> f();

  // Sets the union to hold the f member.
  //

  ExplicitFlexibleUnion& f(float value);

  ExplicitFlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitFlexibleUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit ExplicitFlexibleUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::ExplicitFlexibleUnion::Tag tag);
  static std::optional<::test_union::ExplicitFlexibleUnion::Tag> IndexToTag(size_t index);
};

class UnionSandwich {
 private:
  struct Storage_;

 public:
  UnionSandwich(Storage_ storage) noexcept;
  UnionSandwich(uint32_t a, ::test_union::ExplicitFlexibleUnion u, uint32_t b) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |UnionSandwich| only if all of its members are default constructible.
  UnionSandwich() = default;
#pragma clang diagnostic pop

  UnionSandwich(UnionSandwich&&) noexcept = default;
  UnionSandwich& operator=(UnionSandwich&&) noexcept = default;
  UnionSandwich(const UnionSandwich& other) noexcept;
  UnionSandwich& operator=(const UnionSandwich& other) noexcept;

  bool operator==(const UnionSandwich& other) const noexcept;
  bool operator!=(const UnionSandwich& other) const noexcept;

  uint32_t
  a() const;

  uint32_t& a();

  // Setter for a.
  //

  UnionSandwich& a(uint32_t value);

  const ::test_union::ExplicitFlexibleUnion&
  u() const;

  ::test_union::ExplicitFlexibleUnion& u();

  // Setter for u.
  //

  UnionSandwich& u(::test_union::ExplicitFlexibleUnion value);

  uint32_t
  b() const;

  uint32_t& b();

  // Setter for b.
  //

  UnionSandwich& b(uint32_t value);

  UnionSandwich(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    uint32_t a = {};
    ::test_union::ExplicitFlexibleUnion u;
    uint32_t b = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_union::UnionSandwich, 32>;
  friend struct ::fidl::internal::MemberVisitor<::test_union::UnionSandwich>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, uint32_t, fidl::internal::NaturalCodingConstraintEmpty>{
                                                       &Storage_::a, 0},
                                                   ::fidl::internal::NaturalStructMember<Storage_, ::test_union::ExplicitFlexibleUnion, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::u, 8}, ::fidl::internal::NaturalStructMember<Storage_, uint32_t, fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::b, 24});
  static constexpr auto kPadding = std::make_tuple(::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 0,
                                                       .mask = 0xffffffff00000000,
                                                   },
                                                   ::fidl::internal::NaturalStructPadding<uint64_t>{
                                                       .offset = 24,
                                                       .mask = 0xffffffff00000000,
                                                   });
};

class UnionWithAttributes {
 private:
  using Storage_ =
      std::variant<
          std::monostate, int64_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kX = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  UnionWithAttributes(UnionWithAttributes&& other) noexcept;
  UnionWithAttributes& operator=(UnionWithAttributes&& other) noexcept;
  UnionWithAttributes(const UnionWithAttributes& other) noexcept;
  UnionWithAttributes& operator=(const UnionWithAttributes& other) noexcept;
  bool operator==(const UnionWithAttributes& other) const noexcept;
  bool operator!=(const UnionWithAttributes& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::UnionWithAttributes::Tag Which() const;
  static UnionWithAttributes WithX(int64_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> x() const;
  ::fidl::internal::UnionMemberView<1, Storage_> x();

  // Sets the union to hold the x member.
  //

  UnionWithAttributes& x(int64_t value);

  UnionWithAttributes(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::UnionWithAttributes>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit UnionWithAttributes(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::UnionWithAttributes::Tag tag);
  static std::optional<::test_union::UnionWithAttributes::Tag> IndexToTag(size_t index);
};

class EmptyFlexibleUnion {
 private:
  using Storage_ =
      std::variant<
          std::monostate>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  EmptyFlexibleUnion(EmptyFlexibleUnion&& other) noexcept;
  EmptyFlexibleUnion& operator=(EmptyFlexibleUnion&& other) noexcept;
  EmptyFlexibleUnion(const EmptyFlexibleUnion& other) noexcept;
  EmptyFlexibleUnion& operator=(const EmptyFlexibleUnion& other) noexcept;
  bool operator==(const EmptyFlexibleUnion& other) const noexcept;
  bool operator!=(const EmptyFlexibleUnion& other) const noexcept;
  bool IsUnknown() const;

  ::test_union::EmptyFlexibleUnion::Tag Which() const;

  EmptyFlexibleUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_union::EmptyFlexibleUnion>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>());

  explicit EmptyFlexibleUnion(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_union::EmptyFlexibleUnion::Tag tag);
  static std::optional<::test_union::EmptyFlexibleUnion::Tag> IndexToTag(size_t index);
};

}  // namespace test_union
namespace fidl {

template <>
struct IsFidlType<::test_union::Pizza> : public std::true_type {};

template <>
struct TypeTraits<::test_union::Pizza> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_union::Pizza> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::Pizza, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::Pizza, 16> {};

template <>
struct IsFidlType<::test_union::Pasta> : public std::true_type {};

template <>
struct TypeTraits<::test_union::Pasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_union::Pasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::Pasta, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::Pasta, 16> {};

template <>
struct IsFidlType<::test_union::NullableUnionStruct> : public std::true_type {};

template <>
struct TypeTraits<::test_union::NullableUnionStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_union::NullableUnionStruct> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::NullableUnionStruct, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::NullableUnionStruct, 16> {};

template <>
struct IsFidlType<::test_union::Empty> : public std::true_type {};

template <>
struct TypeTraits<::test_union::Empty> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_union::Empty> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::Empty, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalEmptyStructCodingTraits<::test_union::Empty> {};

template <>
struct IsFidlType<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 32;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse, 16> {};

template <>
struct IsFidlType<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse, 16> {};

template <>
struct IsFidlType<::test_union::StructWithNullableUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::StructWithNullableUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_union::StructWithNullableUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StructWithNullableUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::StructWithNullableUnion, 16> {};

template <>
struct IsFidlType<::test_union::UnionSandwich> : public std::true_type {};

template <>
struct TypeTraits<::test_union::UnionSandwich> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 32;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsStruct<::test_union::UnionSandwich> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::UnionSandwich, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_union::UnionSandwich, 32> {};

template <>
struct IsFidlType<::test_union::PizzaOrPasta> : public std::true_type {};

template <>
struct TypeTraits<::test_union::PizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::PizzaOrPasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::PizzaOrPasta, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::PizzaOrPasta> {};

template <>
struct IsFidlType<::test_union::ExplicitPizzaOrPasta> : public std::true_type {};

template <>
struct TypeTraits<::test_union::ExplicitPizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::ExplicitPizzaOrPasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitPizzaOrPasta, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitPizzaOrPasta> {};

template <>
struct IsFidlType<::test_union::FlexiblePizzaOrPasta> : public std::true_type {};

template <>
struct TypeTraits<::test_union::FlexiblePizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::FlexiblePizzaOrPasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::FlexiblePizzaOrPasta, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::FlexiblePizzaOrPasta> {};

template <>
struct IsFidlType<::test_union::StrictPizzaOrPasta> : public std::true_type {};

template <>
struct TypeTraits<::test_union::StrictPizzaOrPasta> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::StrictPizzaOrPasta> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictPizzaOrPasta, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictPizzaOrPasta> {};

template <>
struct IsFidlType<::test_union::Union> : public std::true_type {};

template <>
struct TypeTraits<::test_union::Union> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::Union> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::Union, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::Union> {};

template <>
struct IsFidlType<::test_union::FlexibleUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::FlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::FlexibleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::FlexibleUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::FlexibleUnion> {};

template <>
struct IsFidlType<::test_union::StrictUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::StrictUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::StrictUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictUnion> {};

template <>
struct IsFidlType<::test_union::FieldCollision> : public std::true_type {};

template <>
struct TypeTraits<::test_union::FieldCollision> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::FieldCollision> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::FieldCollision, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::FieldCollision> {};

template <>
struct IsFidlType<::test_union::ExplicitUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::ExplicitUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::ExplicitUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitUnion> {};

template <>
struct IsFidlType<::test_union::ReverseOrdinalUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::ReverseOrdinalUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::ReverseOrdinalUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ReverseOrdinalUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::ReverseOrdinalUnion> {};

template <>
struct IsFidlType<::test_union::FlexibleFoo> : public std::true_type {};

template <>
struct TypeTraits<::test_union::FlexibleFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::FlexibleFoo> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::FlexibleFoo, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::FlexibleFoo> {};

template <>
struct IsFidlType<::test_union::StrictFoo> : public std::true_type {};

template <>
struct TypeTraits<::test_union::StrictFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::StrictFoo> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictFoo, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictFoo> {};

template <>
struct IsFidlType<::test_union::ExplicitFoo> : public std::true_type {};

template <>
struct TypeTraits<::test_union::ExplicitFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::ExplicitFoo> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitFoo, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitFoo> {};

template <>
struct IsFidlType<::test_union::ExplicitStrictFoo> : public std::true_type {};

template <>
struct TypeTraits<::test_union::ExplicitStrictFoo> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::ExplicitStrictFoo> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitStrictFoo, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitStrictFoo> {};

template <>
struct IsFidlType<::test_union::OlderSimpleUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::OlderSimpleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::OlderSimpleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::OlderSimpleUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::OlderSimpleUnion> {};

template <>
struct IsFidlType<::test_union::NewerSimpleUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::NewerSimpleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::NewerSimpleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::NewerSimpleUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::NewerSimpleUnion> {};

template <>
struct IsFidlType<::test_union::StrictSimpleUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::StrictSimpleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::StrictSimpleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictSimpleUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictSimpleUnion> {};

template <>
struct IsFidlType<::test_union::UnionContainingEmptyStruct> : public std::true_type {};

template <>
struct TypeTraits<::test_union::UnionContainingEmptyStruct> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::UnionContainingEmptyStruct> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::UnionContainingEmptyStruct, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::UnionContainingEmptyStruct> {};

template <>
struct IsFidlType<::test_union::StrictBoundedUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::StrictBoundedUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 32;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::StrictBoundedUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::StrictBoundedUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::StrictBoundedUnion> {};

template <>
struct IsFidlType<::test_union::ExplicitFlexibleUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::ExplicitFlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::ExplicitFlexibleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::ExplicitFlexibleUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::ExplicitFlexibleUnion> {};

template <>
struct IsFidlType<::test_union::UnionWithAttributes> : public std::true_type {};

template <>
struct TypeTraits<::test_union::UnionWithAttributes> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_union::UnionWithAttributes> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::UnionWithAttributes, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::UnionWithAttributes> {};

template <>
struct IsFidlType<::test_union::EmptyFlexibleUnion> : public std::true_type {};

template <>
struct TypeTraits<::test_union::EmptyFlexibleUnion> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsUnion<::test_union::EmptyFlexibleUnion> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_union::EmptyFlexibleUnion, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_union::EmptyFlexibleUnion> {};

#pragma clang diagnostic pop

}  // namespace fidl
