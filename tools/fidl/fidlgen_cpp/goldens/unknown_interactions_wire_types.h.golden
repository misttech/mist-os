// WARNING: This file is machine generated by fidlgen.

  // fidl_experiment = output_index_json

  #pragma once

  #include <cinttypes>

  #include <lib/fidl/cpp/wire/internal/framework_err.h>
  #include <lib/fidl/cpp/wire/array.h>
  #include <lib/fidl/cpp/wire/envelope.h>
  #include <lib/fidl/cpp/wire/message_storage.h>
  #include <lib/fidl/cpp/wire/message.h>
  #include <lib/fidl/cpp/wire/object_view.h>
  #include <lib/fidl/cpp/wire/string_view.h>
  #include <lib/fidl/cpp/wire/traits.h>
  #include <lib/fidl/cpp/wire/wire_types.h>
  #include <lib/stdcompat/optional.h>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
    #include <lib/fidl_driver/cpp/wire_types.h>

#endif  // __Fuchsia__

  #include <fidl/test.unknowninteractions/cpp/markers.h>
  #include <fidl/test.unknowninteractions/cpp/common_types.h>

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

  namespace test_unknowninteractions {

namespace wire {

struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse;

struct UnknownInteractionsProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;

struct UnknownInteractionsProtocolFlexibleTwoWayResponse;

struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;

struct UnknownInteractionsProtocolFlexibleTwoWayErrResponse;

struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;

struct UnknownInteractionsProtocolStrictEventFieldsRequest;

struct UnknownInteractionsProtocolFlexibleEventFieldsRequest;

struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;

struct UnknownInteractionsAjarProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;

struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest;

struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;

struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;

struct UnknownInteractionsClosedProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;

struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest;

struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;

struct UnknownInteractionsDriverProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayResponse;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;

class UnknownInteractionsProtocolStrictTwoWayTableResponse;

class UnknownInteractionsProtocolStrictTwoWayTableErrResponse;

class UnknownInteractionsProtocolFlexibleTwoWayTableResponse;

class UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;

class UnknownInteractionsProtocolStrictEventTableRequest;

class UnknownInteractionsProtocolFlexibleEventTableRequest;

class UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;

class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;

class UnknownInteractionsAjarProtocolStrictEventTableRequest;

class UnknownInteractionsAjarProtocolFlexibleEventTableRequest;

class UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;

class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;

class UnknownInteractionsClosedProtocolStrictEventTableRequest;

class UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;

class UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;

class UnknownInteractionsProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsProtocolStrictTwoWayErrResult;

class UnknownInteractionsProtocolStrictTwoWayFieldsErrResult;

class UnknownInteractionsProtocolStrictTwoWayUnionErrResponse;

class UnknownInteractionsProtocolStrictTwoWayUnionErrResult;

class UnknownInteractionsProtocolStrictTwoWayTableErrResult;

class UnknownInteractionsProtocolFlexibleTwoWayResult;

class UnknownInteractionsProtocolFlexibleTwoWayFieldsResult;

class UnknownInteractionsProtocolFlexibleTwoWayUnionResponse;

class UnknownInteractionsProtocolFlexibleTwoWayUnionResult;

class UnknownInteractionsProtocolFlexibleTwoWayTableResult;

class UnknownInteractionsProtocolFlexibleTwoWayErrResult;

class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult;

class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;

class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult;

class UnknownInteractionsProtocolFlexibleTwoWayTableErrResult;

class UnknownInteractionsProtocolStrictEventUnionRequest;

class UnknownInteractionsProtocolFlexibleEventUnionRequest;

class UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsAjarProtocolStrictTwoWayErrResult;

class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult;

class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;

class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult;

class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult;

class UnknownInteractionsAjarProtocolStrictEventUnionRequest;

class UnknownInteractionsAjarProtocolFlexibleEventUnionRequest;

class UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsClosedProtocolStrictTwoWayErrResult;

class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult;

class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;

class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult;

class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult;

class UnknownInteractionsClosedProtocolStrictEventUnionRequest;

class UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsDriverProtocolStrictTwoWayErrResult;

class UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult;

class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;

class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult;

class UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult;

struct UnknownInteractionsProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsProtocolFlexibleTwoWayResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsProtocolFlexibleTwoWayErrResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsProtocolStrictEventFieldsRequest {

    int32_t some_field = {};
};

struct UnknownInteractionsProtocolFlexibleEventFieldsRequest {

    int32_t some_field = {};
};

struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsAjarProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsAjarProtocolStrictEventFieldsRequest {

    int32_t some_field = {};
};

struct UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest {

    int32_t some_field = {};
};

struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsClosedProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsClosedProtocolStrictEventFieldsRequest {

    int32_t some_field = {};
};

struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsDriverProtocolFlexibleTwoWayResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse {

    int32_t some_field = {};
};

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse {

    int32_t some_field = {};
};

}  // namespace wire
}  // namespace test_unknowninteractions

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsProtocolStrictTwoWayTableResponse(const UnknownInteractionsProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableResponse(UnknownInteractionsProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem);

  UnknownInteractionsProtocolStrictTwoWayTableResponse& clear_some_field();

  explicit UnknownInteractionsProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse(UnknownInteractionsProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem);

  UnknownInteractionsProtocolStrictTwoWayTableErrResponse& clear_some_field();

  explicit UnknownInteractionsProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsProtocolFlexibleTwoWayTableResponse {
public:
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse() = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse(const UnknownInteractionsProtocolFlexibleTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse& operator=(const UnknownInteractionsProtocolFlexibleTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse(UnknownInteractionsProtocolFlexibleTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResponse& operator=(UnknownInteractionsProtocolFlexibleTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolFlexibleTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolFlexibleTwoWayTableResponse& set_some_field(int32_t elem);

  UnknownInteractionsProtocolFlexibleTwoWayTableResponse& clear_some_field();

  explicit UnknownInteractionsProtocolFlexibleTwoWayTableResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolFlexibleTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse {
public:
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse() = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(const UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& operator=(const UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& operator=(UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& set_some_field(int32_t elem);

  UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& clear_some_field();

  explicit UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsProtocolStrictEventTableRequest {
public:
  UnknownInteractionsProtocolStrictEventTableRequest() = default;
  UnknownInteractionsProtocolStrictEventTableRequest(const UnknownInteractionsProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableRequest& operator=(const UnknownInteractionsProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableRequest(UnknownInteractionsProtocolStrictEventTableRequest&& other) noexcept = default;
  UnknownInteractionsProtocolStrictEventTableRequest& operator=(UnknownInteractionsProtocolStrictEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsProtocolStrictEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolStrictEventTableRequest& set_some_field(int32_t elem);

  UnknownInteractionsProtocolStrictEventTableRequest& clear_some_field();

  explicit UnknownInteractionsProtocolStrictEventTableRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsProtocolFlexibleEventTableRequest {
public:
  UnknownInteractionsProtocolFlexibleEventTableRequest() = default;
  UnknownInteractionsProtocolFlexibleEventTableRequest(const UnknownInteractionsProtocolFlexibleEventTableRequest& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableRequest& operator=(const UnknownInteractionsProtocolFlexibleEventTableRequest& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableRequest(UnknownInteractionsProtocolFlexibleEventTableRequest&& other) noexcept = default;
  UnknownInteractionsProtocolFlexibleEventTableRequest& operator=(UnknownInteractionsProtocolFlexibleEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsProtocolFlexibleEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsProtocolFlexibleEventTableRequest& set_some_field(int32_t elem);

  UnknownInteractionsProtocolFlexibleEventTableRequest& clear_some_field();

  explicit UnknownInteractionsProtocolFlexibleEventTableRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsProtocolFlexibleEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsAjarProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(const UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(UnknownInteractionsAjarProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem);

  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse& clear_some_field();

  explicit UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem);

  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& clear_some_field();

  explicit UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsAjarProtocolStrictEventTableRequest {
public:
  UnknownInteractionsAjarProtocolStrictEventTableRequest() = default;
  UnknownInteractionsAjarProtocolStrictEventTableRequest(const UnknownInteractionsAjarProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableRequest& operator=(const UnknownInteractionsAjarProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableRequest(UnknownInteractionsAjarProtocolStrictEventTableRequest&& other) noexcept = default;
  UnknownInteractionsAjarProtocolStrictEventTableRequest& operator=(UnknownInteractionsAjarProtocolStrictEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolStrictEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolStrictEventTableRequest& set_some_field(int32_t elem);

  UnknownInteractionsAjarProtocolStrictEventTableRequest& clear_some_field();

  explicit UnknownInteractionsAjarProtocolStrictEventTableRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsAjarProtocolFlexibleEventTableRequest {
public:
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest() = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest(const UnknownInteractionsAjarProtocolFlexibleEventTableRequest& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& operator=(const UnknownInteractionsAjarProtocolFlexibleEventTableRequest& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest(UnknownInteractionsAjarProtocolFlexibleEventTableRequest&& other) noexcept = default;
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& operator=(UnknownInteractionsAjarProtocolFlexibleEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsAjarProtocolFlexibleEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& set_some_field(int32_t elem);

  UnknownInteractionsAjarProtocolFlexibleEventTableRequest& clear_some_field();

  explicit UnknownInteractionsAjarProtocolFlexibleEventTableRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarProtocolFlexibleEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsClosedProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(const UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(UnknownInteractionsClosedProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem);

  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse& clear_some_field();

  explicit UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem);

  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& clear_some_field();

  explicit UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsClosedProtocolStrictEventTableRequest {
public:
  UnknownInteractionsClosedProtocolStrictEventTableRequest() = default;
  UnknownInteractionsClosedProtocolStrictEventTableRequest(const UnknownInteractionsClosedProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableRequest& operator=(const UnknownInteractionsClosedProtocolStrictEventTableRequest& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableRequest(UnknownInteractionsClosedProtocolStrictEventTableRequest&& other) noexcept = default;
  UnknownInteractionsClosedProtocolStrictEventTableRequest& operator=(UnknownInteractionsClosedProtocolStrictEventTableRequest&& other) noexcept = default;

  ~UnknownInteractionsClosedProtocolStrictEventTableRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedProtocolStrictEventTableRequest& set_some_field(int32_t elem);

  UnknownInteractionsClosedProtocolStrictEventTableRequest& clear_some_field();

  explicit UnknownInteractionsClosedProtocolStrictEventTableRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedProtocolStrictEventTableRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsDriverProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(const UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsDriverProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem);

  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse& clear_some_field();

  explicit UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem);

  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& clear_some_field();

  explicit UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse {
public:
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse() = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& set_some_field(int32_t elem);

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& clear_some_field();

  explicit UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse {
public:
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse() = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& set_some_field(int32_t elem);

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& clear_some_field();

  explicit UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem);

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse& clear_some_field();

  explicit UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem);

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& clear_some_field();

  explicit UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse {
public:
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse() = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& set_some_field(int32_t elem);

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse& clear_some_field();

  explicit UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>* frame);
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>;
template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>;

template <>
struct ::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<int32_t> some_field_;

  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;
};

namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse {
public:
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse() = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse&& other) noexcept = default;

  ~UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>> frame);

  [[ nodiscard ]] int32_t& some_field() const;
  [[ nodiscard ]] bool has_some_field() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
public:
#else // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
private:
#endif // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& set_some_field(int32_t elem);

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& clear_some_field();

  explicit UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>> frame_ptr_;
};}  // namespace wire
}  // namespace test_unknowninteractions

template<typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse Build();
    [[ nodiscard ]] bool has_some_field() const;

    // Clears the some_field field.
    //
    // This method should be used sparingly, such as only during tests, as it has
    // O(number_of_fields) complexity.
    void clear_some_field();

    // Getter for some_field.
    //

    [[ nodiscard ]] int32_t& some_field() const;

    // Setter for some_field.
    //

      BuilderImpl& some_field(int32_t elem);
 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>&& frame);

 private:
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse table_;
};

template<>
class ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;

 public:
 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;

};

template<>
class ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>  {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::WireTableExternalBuilder<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>>;

 private:
  friend class ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>* frame);
};namespace test_unknowninteractions {
namespace wire {

class UnknownInteractionsProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsProtocolStrictTwoWayUnionResponse(const UnknownInteractionsProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionResponse(UnknownInteractionsProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse;

  UnknownInteractionsProtocolStrictTwoWayErrResult();

  UnknownInteractionsProtocolStrictTwoWayErrResult(const UnknownInteractionsProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult(UnknownInteractionsProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsProtocolStrictTwoWayErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult();

  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse();

  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsProtocolStrictTwoWayUnionErrResult();

  UnknownInteractionsProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResult(UnknownInteractionsProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsProtocolStrictTwoWayUnionErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsProtocolStrictTwoWayTableErrResult();

  UnknownInteractionsProtocolStrictTwoWayTableErrResult(const UnknownInteractionsProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResult(UnknownInteractionsProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsProtocolStrictTwoWayTableErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse;

  UnknownInteractionsProtocolFlexibleTwoWayResult();

  UnknownInteractionsProtocolFlexibleTwoWayResult(const UnknownInteractionsProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult(UnknownInteractionsProtocolFlexibleTwoWayResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolFlexibleTwoWayResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse& response() const;

    bool is_framework_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayFieldsResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse;

  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult();

  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult(const UnknownInteractionsProtocolFlexibleTwoWayFieldsResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayFieldsResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult(UnknownInteractionsProtocolFlexibleTwoWayFieldsResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayFieldsResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolFlexibleTwoWayFieldsResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse& response() const;

    bool is_framework_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayFieldsResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayUnionResponse {
  public:

  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse();

  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse(const UnknownInteractionsProtocolFlexibleTwoWayUnionResponse&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& operator=(const UnknownInteractionsProtocolFlexibleTwoWayUnionResponse&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse(UnknownInteractionsProtocolFlexibleTwoWayUnionResponse&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& operator=(UnknownInteractionsProtocolFlexibleTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsProtocolFlexibleTwoWayUnionResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayUnionResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse;

  UnknownInteractionsProtocolFlexibleTwoWayUnionResult();

  UnknownInteractionsProtocolFlexibleTwoWayUnionResult(const UnknownInteractionsProtocolFlexibleTwoWayUnionResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayUnionResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResult(UnknownInteractionsProtocolFlexibleTwoWayUnionResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayUnionResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolFlexibleTwoWayUnionResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> val);

      template <typename... Args>
      static UnknownInteractionsProtocolFlexibleTwoWayUnionResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse& response() const;

    bool is_framework_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayUnionResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayTableResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse;

  UnknownInteractionsProtocolFlexibleTwoWayTableResult();

  UnknownInteractionsProtocolFlexibleTwoWayTableResult(const UnknownInteractionsProtocolFlexibleTwoWayTableResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayTableResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResult(UnknownInteractionsProtocolFlexibleTwoWayTableResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayTableResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolFlexibleTwoWayTableResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> val);

      template <typename... Args>
      static UnknownInteractionsProtocolFlexibleTwoWayTableResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse& response() const;

    bool is_framework_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayTableResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayErrResult();

  UnknownInteractionsProtocolFlexibleTwoWayErrResult(const UnknownInteractionsProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult(UnknownInteractionsProtocolFlexibleTwoWayErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

    bool is_framework_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult();

  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult(const UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult(UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

    bool is_framework_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse {
  public:

  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse();

  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse(const UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& operator=(const UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& operator=(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult();

  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult(const UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

    bool is_framework_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult();

  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult(const UnknownInteractionsProtocolFlexibleTwoWayTableErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayTableErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult(UnknownInteractionsProtocolFlexibleTwoWayTableErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayTableErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsProtocolFlexibleTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsProtocolFlexibleTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayTableErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

    bool is_framework_err() const;

      static UnknownInteractionsProtocolFlexibleTwoWayTableErrResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolStrictEventUnionRequest {
  public:

  UnknownInteractionsProtocolStrictEventUnionRequest();

  UnknownInteractionsProtocolStrictEventUnionRequest(const UnknownInteractionsProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsProtocolStrictEventUnionRequest& operator=(const UnknownInteractionsProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsProtocolStrictEventUnionRequest(UnknownInteractionsProtocolStrictEventUnionRequest&&) = default;
  UnknownInteractionsProtocolStrictEventUnionRequest& operator=(UnknownInteractionsProtocolStrictEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsProtocolStrictEventUnionRequest WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsProtocolFlexibleEventUnionRequest {
  public:

  UnknownInteractionsProtocolFlexibleEventUnionRequest();

  UnknownInteractionsProtocolFlexibleEventUnionRequest(const UnknownInteractionsProtocolFlexibleEventUnionRequest&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionRequest& operator=(const UnknownInteractionsProtocolFlexibleEventUnionRequest&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionRequest(UnknownInteractionsProtocolFlexibleEventUnionRequest&&) = default;
  UnknownInteractionsProtocolFlexibleEventUnionRequest& operator=(UnknownInteractionsProtocolFlexibleEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsProtocolFlexibleEventUnionRequest WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse(const UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayErrResult();

  UnknownInteractionsAjarProtocolStrictTwoWayErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult(UnknownInteractionsAjarProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult();

  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse();

  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult();

  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult();

  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarProtocolStrictEventUnionRequest {
  public:

  UnknownInteractionsAjarProtocolStrictEventUnionRequest();

  UnknownInteractionsAjarProtocolStrictEventUnionRequest(const UnknownInteractionsAjarProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionRequest& operator=(const UnknownInteractionsAjarProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionRequest(UnknownInteractionsAjarProtocolStrictEventUnionRequest&&) = default;
  UnknownInteractionsAjarProtocolStrictEventUnionRequest& operator=(UnknownInteractionsAjarProtocolStrictEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsAjarProtocolStrictEventUnionRequest WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarProtocolFlexibleEventUnionRequest {
  public:

  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest();

  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest(const UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& operator=(const UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest& operator=(UnknownInteractionsAjarProtocolFlexibleEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsAjarProtocolFlexibleEventUnionRequest WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse(const UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayErrResult();

  UnknownInteractionsClosedProtocolStrictTwoWayErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult(UnknownInteractionsClosedProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult();

  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse();

  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult();

  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult();

  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedProtocolStrictEventUnionRequest {
  public:

  UnknownInteractionsClosedProtocolStrictEventUnionRequest();

  UnknownInteractionsClosedProtocolStrictEventUnionRequest(const UnknownInteractionsClosedProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionRequest& operator=(const UnknownInteractionsClosedProtocolStrictEventUnionRequest&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionRequest(UnknownInteractionsClosedProtocolStrictEventUnionRequest&&) = default;
  UnknownInteractionsClosedProtocolStrictEventUnionRequest& operator=(UnknownInteractionsClosedProtocolStrictEventUnionRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsClosedProtocolStrictEventUnionRequest WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse(const UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayErrResult();

  UnknownInteractionsDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult(UnknownInteractionsDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult();

  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse();

  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult();

  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult();

  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayResult();

  UnknownInteractionsDriverProtocolFlexibleTwoWayResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult(UnknownInteractionsDriverProtocolFlexibleTwoWayResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse& response() const;

    bool is_framework_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult();

  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse& response() const;

    bool is_framework_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse {
  public:

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse();

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult();

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> val);

      template <typename... Args>
      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse& response() const;

    bool is_framework_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult();

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> val);

      template <typename... Args>
      static UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse& response() const;

    bool is_framework_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult();

  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

    bool is_framework_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult();

  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

    bool is_framework_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse {
  public:

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse();

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult();

  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

    bool is_framework_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult();

  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

    bool is_framework_err() const;

      static UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult WithFrameworkErr(::fidl::internal::FrameworkErr val);

    ::fidl::internal::FrameworkErr& framework_err();

    const ::fidl::internal::FrameworkErr& framework_err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kFrameworkErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult();

  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult();

  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse();

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult();

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult();

  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse {
  public:

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse();

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult();

  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult();

  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse val);

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse {
  public:

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse();

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSomeField = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

    bool is_some_field() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse WithSomeField(int32_t val);

    int32_t& some_field();

    const int32_t& some_field() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSomeField = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult();

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult();

  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const;

    bool is_response() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> val);

      template <typename... Args>
      static UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
        return WithResponse(::fidl::ObjectView<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse>(allocator,
                                            std::forward<Args>(args)...));
      }

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& response();

    const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse& response() const;

    bool is_err() const;

      static UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult WithErr(int32_t val);

    int32_t& err();

    const int32_t& err() const;

  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

  }  // namespace wire
}  // namespace test_unknowninteractions
namespace fidl {

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventFieldsRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventTableRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};
template <>
struct IsTable<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventUnionRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 3;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsWire<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

  #pragma clang diagnostic pop

  }  // namespace fidl

