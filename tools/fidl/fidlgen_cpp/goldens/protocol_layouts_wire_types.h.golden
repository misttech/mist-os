// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <lib/fidl/cpp/wire/array.h>
#include <lib/fidl/cpp/wire/envelope.h>
#include <lib/fidl/cpp/wire/internal/framework_err.h>
#include <lib/fidl/cpp/wire/message.h>
#include <lib/fidl/cpp/wire/message_storage.h>
#include <lib/fidl/cpp/wire/object_view.h>
#include <lib/fidl/cpp/wire/string_view.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/fidl/cpp/wire/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.protocollayouts.imported/cpp/wire_types.h>
#include <fidl/test.protocollayouts/cpp/common_types.h>
#include <fidl/test.protocollayouts/cpp/markers.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_protocollayouts {

namespace wire {

class LocalTablePayload;

class MainProtocolOneWayAnonRequest;

class MainProtocolTwoWayAnonResponse;

class MainProtocolTwoWayAnonWithErrorRequest;

class LocalUnionPayload;

class MainProtocolTwoWayImportWithErrorResult;

class MainProtocolTwoWayLocalWithErrorResult;

class MainProtocolTwoWayAnonRequest;

class MainProtocolTwoWayAnonWithErrorResponse;

class MainProtocolTwoWayAnonWithErrorResult;

class MainProtocolOnAnonRequest;

}  // namespace wire
}  // namespace test_protocollayouts

template <>
class ::fidl::WireTableBuilder<::test_protocollayouts::wire::LocalTablePayload>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::LocalTablePayload>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayouts::wire::LocalTablePayload> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayouts::wire::LocalTablePayload;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, ::fidl::WireTableBuilder<::test_protocollayouts::wire::LocalTablePayload>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::LocalTablePayload>>;
};

namespace test_protocollayouts {
namespace wire {

class LocalTablePayload {
 public:
  LocalTablePayload() = default;
  LocalTablePayload(const LocalTablePayload& other) noexcept = default;
  LocalTablePayload& operator=(const LocalTablePayload& other) noexcept = default;
  LocalTablePayload(LocalTablePayload&& other) noexcept = default;
  LocalTablePayload& operator=(LocalTablePayload&& other) noexcept = default;

  ~LocalTablePayload() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayouts::wire::LocalTablePayload> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::LocalTablePayload> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::LocalTablePayload>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  LocalTablePayload& set_a(uint16_t elem);

  LocalTablePayload& clear_a();

  explicit LocalTablePayload(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit LocalTablePayload(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::LocalTablePayload>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::LocalTablePayload>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, ::fidl::WireTableBuilder<::test_protocollayouts::wire::LocalTablePayload>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::LocalTablePayload>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::LocalTablePayload>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayouts

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayouts::wire::LocalTablePayload Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::LocalTablePayload>>&& frame);

 private:
  ::test_protocollayouts::wire::LocalTablePayload table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayouts::wire::LocalTablePayload> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, ::fidl::WireTableBuilder<::test_protocollayouts::wire::LocalTablePayload>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, ::fidl::WireTableBuilder<::test_protocollayouts::wire::LocalTablePayload>>;

 public:
 private:
  friend class ::test_protocollayouts::wire::LocalTablePayload;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::LocalTablePayload> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::LocalTablePayload>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::LocalTablePayload, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::LocalTablePayload>>;

 private:
  friend class ::test_protocollayouts::wire::LocalTablePayload;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayouts::wire::LocalTablePayload>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayouts::wire::MainProtocolOneWayAnonRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>;
};

namespace test_protocollayouts {
namespace wire {

class MainProtocolOneWayAnonRequest {
 public:
  MainProtocolOneWayAnonRequest() = default;
  MainProtocolOneWayAnonRequest(const MainProtocolOneWayAnonRequest& other) noexcept = default;
  MainProtocolOneWayAnonRequest& operator=(const MainProtocolOneWayAnonRequest& other) noexcept = default;
  MainProtocolOneWayAnonRequest(MainProtocolOneWayAnonRequest&& other) noexcept = default;
  MainProtocolOneWayAnonRequest& operator=(MainProtocolOneWayAnonRequest&& other) noexcept = default;

  ~MainProtocolOneWayAnonRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  MainProtocolOneWayAnonRequest& set_a(uint16_t elem);

  MainProtocolOneWayAnonRequest& clear_a();

  explicit MainProtocolOneWayAnonRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit MainProtocolOneWayAnonRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayouts

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayouts::wire::MainProtocolOneWayAnonRequest Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>&& frame);

 private:
  ::test_protocollayouts::wire::MainProtocolOneWayAnonRequest table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>;

 public:
 private:
  friend class ::test_protocollayouts::wire::MainProtocolOneWayAnonRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>>;

 private:
  friend class ::test_protocollayouts::wire::MainProtocolOneWayAnonRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>;
};

namespace test_protocollayouts {
namespace wire {

class MainProtocolTwoWayAnonResponse {
 public:
  MainProtocolTwoWayAnonResponse() = default;
  MainProtocolTwoWayAnonResponse(const MainProtocolTwoWayAnonResponse& other) noexcept = default;
  MainProtocolTwoWayAnonResponse& operator=(const MainProtocolTwoWayAnonResponse& other) noexcept = default;
  MainProtocolTwoWayAnonResponse(MainProtocolTwoWayAnonResponse&& other) noexcept = default;
  MainProtocolTwoWayAnonResponse& operator=(MainProtocolTwoWayAnonResponse&& other) noexcept = default;

  ~MainProtocolTwoWayAnonResponse() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  MainProtocolTwoWayAnonResponse& set_a(uint16_t elem);

  MainProtocolTwoWayAnonResponse& clear_a();

  explicit MainProtocolTwoWayAnonResponse(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit MainProtocolTwoWayAnonResponse(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayouts

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>&& frame);

 private:
  ::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>;

 public:
 private:
  friend class ::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>>;

 private:
  friend class ::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse>* frame);
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>;
template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>;

template <>
struct ::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;

  bool HasUnknownData() const;
  uint64_t ComputeMaxOrdinal() const;
  ::fidl::Envelope<uint16_t> a_;

  friend class ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>;
};

namespace test_protocollayouts {
namespace wire {

class MainProtocolTwoWayAnonWithErrorRequest {
 public:
  MainProtocolTwoWayAnonWithErrorRequest() = default;
  MainProtocolTwoWayAnonWithErrorRequest(const MainProtocolTwoWayAnonWithErrorRequest& other) noexcept = default;
  MainProtocolTwoWayAnonWithErrorRequest& operator=(const MainProtocolTwoWayAnonWithErrorRequest& other) noexcept = default;
  MainProtocolTwoWayAnonWithErrorRequest(MainProtocolTwoWayAnonWithErrorRequest&& other) noexcept = default;
  MainProtocolTwoWayAnonWithErrorRequest& operator=(MainProtocolTwoWayAnonWithErrorRequest&& other) noexcept = default;

  ~MainProtocolTwoWayAnonWithErrorRequest() = default;

  // Returns whether no field is set.
  bool IsEmpty() const;

  // Returns whether the table references unknown fields.
  bool HasUnknownData() const;

  // Return a builder that by defaults allocates of an arena.
  static ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> Builder(::fidl::AnyArena& arena);

  // Return a builder that relies on explicitly allocating |fidl::ObjectView|s.
  static ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> ExternalBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>> frame);

  [[nodiscard]] uint16_t& a() const;
  [[nodiscard]] bool has_a() const;
#if defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES) || false
 public:
#else   // !defined(FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES)
 private:
#endif  // FIDL_WIRE_ALLOW_DEPRECATED_MUTABLE_TABLES

  MainProtocolTwoWayAnonWithErrorRequest& set_a(uint16_t elem);

  MainProtocolTwoWayAnonWithErrorRequest& clear_a();

  explicit MainProtocolTwoWayAnonWithErrorRequest(::fidl::AnyArena& allocator);
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or for another table.
  explicit MainProtocolTwoWayAnonWithErrorRequest(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame);

  void Allocate(::fidl::AnyArena& allocator);
  void Init(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame_ptr);

 private:
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>;
  friend ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>;

  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>> frame_ptr_;
};
}  // namespace wire
}  // namespace test_protocollayouts

template <typename BuilderImpl>
class ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, BuilderImpl> {
 protected:
  // |Wrapper_Ignore_Me_| wraps a |fidl::ObjectView<T>| and reduces its
  // priority in overload resolution. When the user writes `{}` as the
  // setter argument, that would default construct the field instead of
  // constructing a NULL object view.
  template <typename U>
  struct Wrapper_Ignore_Me_ {
    Wrapper_Ignore_Me_(U v) : value(v) {}
    U value;
  };

 public:
  // Build and return the table. The builder should not be used after this.
  ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest Build();
  [[nodiscard]] bool has_a() const;

  // Clears the a field.
  //
  // This method should be used sparingly, such as only during tests, as it has
  // O(number_of_fields) complexity.
  void clear_a();

  // Getter for a.
  //

  [[nodiscard]] uint16_t& a() const;

  // Setter for a.
  //

  BuilderImpl& a(uint16_t elem);

 protected:
  WireTableBaseBuilder(::fidl::ObjectView<::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>&& frame);

 private:
  ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest table_;
};

template <>
class ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>;

 public:
 private:
  friend class ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest;
  WireTableBuilder(::fidl::AnyArena& arena);

  [[maybe_unused]] std::reference_wrapper<::fidl::AnyArena> arena_;
};

template <>
class ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> final : public ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>> {
  using Base = ::fidl::internal::WireTableBaseBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::WireTableExternalBuilder<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>>;

 private:
  friend class ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest;
  using Base::Base;
  WireTableExternalBuilder(::fidl::WireTableFrame<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest>* frame);
};
namespace test_protocollayouts {
namespace wire {

class LocalUnionPayload {
 public:
  LocalUnionPayload();

  LocalUnionPayload(const LocalUnionPayload&) = default;
  LocalUnionPayload& operator=(const LocalUnionPayload&) = default;
  LocalUnionPayload(LocalUnionPayload&&) = default;
  LocalUnionPayload& operator=(LocalUnionPayload&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocollayouts::wire::LocalUnionPayload::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static LocalUnionPayload WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayouts::wire::LocalUnionPayload::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayouts::wire::LocalUnionPayload::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayImportWithErrorResult {
 public:
  MainProtocolTwoWayImportWithErrorResult();

  MainProtocolTwoWayImportWithErrorResult(const MainProtocolTwoWayImportWithErrorResult&) = default;
  MainProtocolTwoWayImportWithErrorResult& operator=(const MainProtocolTwoWayImportWithErrorResult&) = default;
  MainProtocolTwoWayImportWithErrorResult(MainProtocolTwoWayImportWithErrorResult&&) = default;
  MainProtocolTwoWayImportWithErrorResult& operator=(MainProtocolTwoWayImportWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static MainProtocolTwoWayImportWithErrorResult WithResponse(::fidl::ObjectView<::test_protocollayouts_imported::wire::ImportUnionPayload> val);

  template <typename... Args>
  static MainProtocolTwoWayImportWithErrorResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocollayouts_imported::wire::ImportUnionPayload>(allocator,
                                                                                                      std::forward<Args>(args)...));
  }

  ::test_protocollayouts_imported::wire::ImportUnionPayload& response();

  const ::test_protocollayouts_imported::wire::ImportUnionPayload& response() const;

  bool is_err() const;

  static MainProtocolTwoWayImportWithErrorResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayLocalWithErrorResult {
 public:
  MainProtocolTwoWayLocalWithErrorResult();

  MainProtocolTwoWayLocalWithErrorResult(const MainProtocolTwoWayLocalWithErrorResult&) = default;
  MainProtocolTwoWayLocalWithErrorResult& operator=(const MainProtocolTwoWayLocalWithErrorResult&) = default;
  MainProtocolTwoWayLocalWithErrorResult(MainProtocolTwoWayLocalWithErrorResult&&) = default;
  MainProtocolTwoWayLocalWithErrorResult& operator=(MainProtocolTwoWayLocalWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static MainProtocolTwoWayLocalWithErrorResult WithResponse(::fidl::ObjectView<::test_protocollayouts::wire::LocalUnionPayload> val);

  template <typename... Args>
  static MainProtocolTwoWayLocalWithErrorResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocollayouts::wire::LocalUnionPayload>(allocator,
                                                                                            std::forward<Args>(args)...));
  }

  ::test_protocollayouts::wire::LocalUnionPayload& response();

  const ::test_protocollayouts::wire::LocalUnionPayload& response() const;

  bool is_err() const;

  static MainProtocolTwoWayLocalWithErrorResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayAnonRequest {
 public:
  MainProtocolTwoWayAnonRequest();

  MainProtocolTwoWayAnonRequest(const MainProtocolTwoWayAnonRequest&) = default;
  MainProtocolTwoWayAnonRequest& operator=(const MainProtocolTwoWayAnonRequest&) = default;
  MainProtocolTwoWayAnonRequest(MainProtocolTwoWayAnonRequest&&) = default;
  MainProtocolTwoWayAnonRequest& operator=(MainProtocolTwoWayAnonRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static MainProtocolTwoWayAnonRequest WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayAnonWithErrorResponse {
 public:
  MainProtocolTwoWayAnonWithErrorResponse();

  MainProtocolTwoWayAnonWithErrorResponse(const MainProtocolTwoWayAnonWithErrorResponse&) = default;
  MainProtocolTwoWayAnonWithErrorResponse& operator=(const MainProtocolTwoWayAnonWithErrorResponse&) = default;
  MainProtocolTwoWayAnonWithErrorResponse(MainProtocolTwoWayAnonWithErrorResponse&&) = default;
  MainProtocolTwoWayAnonWithErrorResponse& operator=(MainProtocolTwoWayAnonWithErrorResponse&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static MainProtocolTwoWayAnonWithErrorResponse WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolTwoWayAnonWithErrorResult {
 public:
  using Response = test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse;

  MainProtocolTwoWayAnonWithErrorResult();

  MainProtocolTwoWayAnonWithErrorResult(const MainProtocolTwoWayAnonWithErrorResult&) = default;
  MainProtocolTwoWayAnonWithErrorResult& operator=(const MainProtocolTwoWayAnonWithErrorResult&) = default;
  MainProtocolTwoWayAnonWithErrorResult(MainProtocolTwoWayAnonWithErrorResult&&) = default;
  MainProtocolTwoWayAnonWithErrorResult& operator=(MainProtocolTwoWayAnonWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const;

  bool is_response() const;

  static MainProtocolTwoWayAnonWithErrorResult WithResponse(::fidl::ObjectView<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse> val);

  template <typename... Args>
  static MainProtocolTwoWayAnonWithErrorResult WithResponse(::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(::fidl::ObjectView<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse>(allocator,
                                                                                                                  std::forward<Args>(args)...));
  }

  ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse& response();

  const ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse& response() const;

  bool is_err() const;

  static MainProtocolTwoWayAnonWithErrorResult WithErr(uint32_t val);

  uint32_t& err();

  const uint32_t& err() const;

  ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class MainProtocolOnAnonRequest {
 public:
  MainProtocolOnAnonRequest();

  MainProtocolOnAnonRequest(const MainProtocolOnAnonRequest&) = default;
  MainProtocolOnAnonRequest& operator=(const MainProtocolOnAnonRequest&) = default;
  MainProtocolOnAnonRequest(MainProtocolOnAnonRequest&&) = default;
  MainProtocolOnAnonRequest& operator=(MainProtocolOnAnonRequest&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kB = 1,  // 0x1
    _do_not_handle_this__write_a_default_case_instead = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };
  constexpr bool IsUnknown() const {
    return Which() == ::test_protocollayouts::wire::MainProtocolOnAnonRequest::Tag::_do_not_handle_this__write_a_default_case_instead;
  }

  bool has_invalid_tag() const;

  bool is_b() const;

  static MainProtocolOnAnonRequest WithB(bool val);

  bool& b();

  const bool& b() const;

  ::test_protocollayouts::wire::MainProtocolOnAnonRequest::Tag Which() const;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kB = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocollayouts::wire::MainProtocolOnAnonRequest::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

}  // namespace wire
}  // namespace test_protocollayouts
namespace fidl {

template <>
struct TypeTraits<::test_protocollayouts::wire::LocalTablePayload> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::LocalTablePayload> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::LocalTablePayload> : public std::true_type {};
template <>
struct IsTable<::test_protocollayouts::wire::LocalTablePayload> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::LocalTablePayload, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::LocalTablePayload* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> : public std::true_type {};
template <>
struct IsTable<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolOneWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolOneWayAnonRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> : public std::true_type {};
template <>
struct IsTable<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolTwoWayAnonResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> : public std::true_type {};
template <>
struct IsTable<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest> : public std::true_type {};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : ::fidl::internal::WireTableCodingTraitsBase<IsRecursive> {
  using Base = ::fidl::internal::WireTableCodingTraitsBase<IsRecursive>;
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

template <>
struct TypeTraits<::test_protocollayouts::wire::LocalUnionPayload> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::LocalUnionPayload> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::LocalUnionPayload> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayouts::wire::LocalUnionPayload> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::LocalUnionPayload, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::LocalUnionPayload* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::LocalUnionPayload, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::LocalUnionPayload, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayImportWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayLocalWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResponse, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 2;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 16;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolTwoWayAnonWithErrorResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

template <>
struct TypeTraits<::test_protocollayouts::wire::MainProtocolOnAnonRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_protocollayouts::wire::MainProtocolOnAnonRequest> : public std::true_type {};
template <>
struct IsWire<::test_protocollayouts::wire::MainProtocolOnAnonRequest> : public std::true_type {};
template <>
struct IsUnion<::test_protocollayouts::wire::MainProtocolOnAnonRequest> : public std::true_type {};

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolOnAnonRequest, Constraint, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr bool kIsMemcpyCompatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_protocollayouts::wire::MainProtocolOnAnonRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth);
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
    : public ::fidl::internal::WireCodingTraits<::test_protocollayouts::wire::MainProtocolOnAnonRequest, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

#pragma clang diagnostic pop

}  // namespace fidl
