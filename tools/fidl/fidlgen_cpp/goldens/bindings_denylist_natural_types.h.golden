// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <fidl/test.bindingsdenylist/cpp/common_types.h>
#include <fidl/test.bindingsdenylist/cpp/markers.h>
#include <lib/fidl/cpp/natural_coding_traits.h>
#include <lib/fidl/cpp/natural_types.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.dependent/cpp/natural_types.h>
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_bindingsdenylist {

class DenyEachBindingOnlyDenyDartRequest;

class DenyEachBindingOnlyDenyDartResponse;

class DenyEachBindingOnlyDenyGoRequest;

class DenyEachBindingOnlyDenyGoResponse;

class DenyEachBindingOnlyDenyPythonRequest;

class DenyEachBindingOnlyDenyPythonResponse;

class DenyEachBindingOnlyDenyRustRequest;

class DenyEachBindingOnlyDenyRustResponse;

class DenyEachBindingOnlyDenySyzkallerRequest;

class DenyEachBindingOnlyDenySyzkallerResponse;

class MemberOnlyAppearsInImportingLibrary;

class OnlyAppearsInImportingLibrary;

class OnlyLlcpp;

class DenyEachBindingOnlyDenyDartResult;

class DenyEachBindingOnlyDenyGoResult;

class DenyEachBindingOnlyDenyPythonResult;

class DenyEachBindingOnlyDenyRustResult;

class DenyEachBindingOnlyDenySyzkallerResult;

constexpr uint32_t kAllBindings = 0u;

class OnlyLlcpp {
 private:
  using Storage_ =
      std::variant<
          std::monostate, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kX = 1,  // 0x1
  };

  OnlyLlcpp(OnlyLlcpp&& other) noexcept;
  OnlyLlcpp& operator=(OnlyLlcpp&& other) noexcept;
  OnlyLlcpp(const OnlyLlcpp& other) noexcept;
  OnlyLlcpp& operator=(const OnlyLlcpp& other) noexcept;
  bool operator==(const OnlyLlcpp& other) const noexcept;
  bool operator!=(const OnlyLlcpp& other) const noexcept;

  ::test_bindingsdenylist::OnlyLlcpp::Tag Which() const;
  static OnlyLlcpp WithX(uint32_t val);
  const ::fidl::internal::UnionMemberView<1, Storage_> x() const;
  ::fidl::internal::UnionMemberView<1, Storage_> x();

  // Sets the union to hold the x member.
  //

  OnlyLlcpp& x(uint32_t value);

  OnlyLlcpp(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::OnlyLlcpp>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit OnlyLlcpp(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_bindingsdenylist::OnlyLlcpp::Tag tag);
  static std::optional<::test_bindingsdenylist::OnlyLlcpp::Tag> IndexToTag(size_t index);
};

class DenyEachBindingOnlyDenyDartRequest {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyDartRequest(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenyDartRequest(bool a) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenyDartRequest| only if all of its members are default constructible.
  DenyEachBindingOnlyDenyDartRequest() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenyDartRequest(DenyEachBindingOnlyDenyDartRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyDartRequest& operator=(DenyEachBindingOnlyDenyDartRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyDartRequest(const DenyEachBindingOnlyDenyDartRequest& other) noexcept;
  DenyEachBindingOnlyDenyDartRequest& operator=(const DenyEachBindingOnlyDenyDartRequest& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenyDartRequest& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyDartRequest& other) const noexcept;

  bool
  a() const;

  bool& a();

  // Setter for a.
  //

  DenyEachBindingOnlyDenyDartRequest& a(bool value);

  DenyEachBindingOnlyDenyDartRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    bool a = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::a, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenyDartResponse {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyDartResponse(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenyDartResponse(int32_t b) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenyDartResponse| only if all of its members are default constructible.
  DenyEachBindingOnlyDenyDartResponse() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenyDartResponse(DenyEachBindingOnlyDenyDartResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyDartResponse& operator=(DenyEachBindingOnlyDenyDartResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyDartResponse(const DenyEachBindingOnlyDenyDartResponse& other) noexcept;
  DenyEachBindingOnlyDenyDartResponse& operator=(const DenyEachBindingOnlyDenyDartResponse& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenyDartResponse& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyDartResponse& other) const noexcept;

  int32_t
  b() const;

  int32_t& b();

  // Setter for b.
  //

  DenyEachBindingOnlyDenyDartResponse& b(int32_t value);

  DenyEachBindingOnlyDenyDartResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    int32_t b = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::b, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenyDartResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  DenyEachBindingOnlyDenyDartResult(DenyEachBindingOnlyDenyDartResult&& other) noexcept;
  DenyEachBindingOnlyDenyDartResult& operator=(DenyEachBindingOnlyDenyDartResult&& other) noexcept;
  DenyEachBindingOnlyDenyDartResult(const DenyEachBindingOnlyDenyDartResult& other) noexcept;
  DenyEachBindingOnlyDenyDartResult& operator=(const DenyEachBindingOnlyDenyDartResult& other) noexcept;
  bool operator==(const DenyEachBindingOnlyDenyDartResult& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyDartResult& other) const noexcept;

  ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult::Tag Which() const;
  static DenyEachBindingOnlyDenyDartResult WithResponse(::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  DenyEachBindingOnlyDenyDartResult& response(::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse value);
  static DenyEachBindingOnlyDenyDartResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  DenyEachBindingOnlyDenyDartResult& err(uint32_t value);

  DenyEachBindingOnlyDenyDartResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit DenyEachBindingOnlyDenyDartResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult::Tag tag);
  static std::optional<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult::Tag> IndexToTag(size_t index);
};

class DenyEachBindingOnlyDenyGoRequest {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyGoRequest(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenyGoRequest(bool a) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenyGoRequest| only if all of its members are default constructible.
  DenyEachBindingOnlyDenyGoRequest() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenyGoRequest(DenyEachBindingOnlyDenyGoRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyGoRequest& operator=(DenyEachBindingOnlyDenyGoRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyGoRequest(const DenyEachBindingOnlyDenyGoRequest& other) noexcept;
  DenyEachBindingOnlyDenyGoRequest& operator=(const DenyEachBindingOnlyDenyGoRequest& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenyGoRequest& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyGoRequest& other) const noexcept;

  bool
  a() const;

  bool& a();

  // Setter for a.
  //

  DenyEachBindingOnlyDenyGoRequest& a(bool value);

  DenyEachBindingOnlyDenyGoRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    bool a = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::a, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenyGoResponse {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyGoResponse(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenyGoResponse(int32_t b) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenyGoResponse| only if all of its members are default constructible.
  DenyEachBindingOnlyDenyGoResponse() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenyGoResponse(DenyEachBindingOnlyDenyGoResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyGoResponse& operator=(DenyEachBindingOnlyDenyGoResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyGoResponse(const DenyEachBindingOnlyDenyGoResponse& other) noexcept;
  DenyEachBindingOnlyDenyGoResponse& operator=(const DenyEachBindingOnlyDenyGoResponse& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenyGoResponse& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyGoResponse& other) const noexcept;

  int32_t
  b() const;

  int32_t& b();

  // Setter for b.
  //

  DenyEachBindingOnlyDenyGoResponse& b(int32_t value);

  DenyEachBindingOnlyDenyGoResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    int32_t b = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::b, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenyGoResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  DenyEachBindingOnlyDenyGoResult(DenyEachBindingOnlyDenyGoResult&& other) noexcept;
  DenyEachBindingOnlyDenyGoResult& operator=(DenyEachBindingOnlyDenyGoResult&& other) noexcept;
  DenyEachBindingOnlyDenyGoResult(const DenyEachBindingOnlyDenyGoResult& other) noexcept;
  DenyEachBindingOnlyDenyGoResult& operator=(const DenyEachBindingOnlyDenyGoResult& other) noexcept;
  bool operator==(const DenyEachBindingOnlyDenyGoResult& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyGoResult& other) const noexcept;

  ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult::Tag Which() const;
  static DenyEachBindingOnlyDenyGoResult WithResponse(::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  DenyEachBindingOnlyDenyGoResult& response(::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse value);
  static DenyEachBindingOnlyDenyGoResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  DenyEachBindingOnlyDenyGoResult& err(uint32_t value);

  DenyEachBindingOnlyDenyGoResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit DenyEachBindingOnlyDenyGoResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult::Tag tag);
  static std::optional<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult::Tag> IndexToTag(size_t index);
};

class DenyEachBindingOnlyDenyPythonRequest {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyPythonRequest(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenyPythonRequest(bool a) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenyPythonRequest| only if all of its members are default constructible.
  DenyEachBindingOnlyDenyPythonRequest() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenyPythonRequest(DenyEachBindingOnlyDenyPythonRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyPythonRequest& operator=(DenyEachBindingOnlyDenyPythonRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyPythonRequest(const DenyEachBindingOnlyDenyPythonRequest& other) noexcept;
  DenyEachBindingOnlyDenyPythonRequest& operator=(const DenyEachBindingOnlyDenyPythonRequest& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenyPythonRequest& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyPythonRequest& other) const noexcept;

  bool
  a() const;

  bool& a();

  // Setter for a.
  //

  DenyEachBindingOnlyDenyPythonRequest& a(bool value);

  DenyEachBindingOnlyDenyPythonRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    bool a = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonRequest, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::a, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenyPythonResponse {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyPythonResponse(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenyPythonResponse(int32_t b) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenyPythonResponse| only if all of its members are default constructible.
  DenyEachBindingOnlyDenyPythonResponse() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenyPythonResponse(DenyEachBindingOnlyDenyPythonResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyPythonResponse& operator=(DenyEachBindingOnlyDenyPythonResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyPythonResponse(const DenyEachBindingOnlyDenyPythonResponse& other) noexcept;
  DenyEachBindingOnlyDenyPythonResponse& operator=(const DenyEachBindingOnlyDenyPythonResponse& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenyPythonResponse& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyPythonResponse& other) const noexcept;

  int32_t
  b() const;

  int32_t& b();

  // Setter for b.
  //

  DenyEachBindingOnlyDenyPythonResponse& b(int32_t value);

  DenyEachBindingOnlyDenyPythonResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    int32_t b = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::b, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenyPythonResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  DenyEachBindingOnlyDenyPythonResult(DenyEachBindingOnlyDenyPythonResult&& other) noexcept;
  DenyEachBindingOnlyDenyPythonResult& operator=(DenyEachBindingOnlyDenyPythonResult&& other) noexcept;
  DenyEachBindingOnlyDenyPythonResult(const DenyEachBindingOnlyDenyPythonResult& other) noexcept;
  DenyEachBindingOnlyDenyPythonResult& operator=(const DenyEachBindingOnlyDenyPythonResult& other) noexcept;
  bool operator==(const DenyEachBindingOnlyDenyPythonResult& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyPythonResult& other) const noexcept;

  ::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult::Tag Which() const;
  static DenyEachBindingOnlyDenyPythonResult WithResponse(::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  DenyEachBindingOnlyDenyPythonResult& response(::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse value);
  static DenyEachBindingOnlyDenyPythonResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  DenyEachBindingOnlyDenyPythonResult& err(uint32_t value);

  DenyEachBindingOnlyDenyPythonResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit DenyEachBindingOnlyDenyPythonResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult::Tag tag);
  static std::optional<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult::Tag> IndexToTag(size_t index);
};

class DenyEachBindingOnlyDenyRustRequest {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyRustRequest(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenyRustRequest(bool a) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenyRustRequest| only if all of its members are default constructible.
  DenyEachBindingOnlyDenyRustRequest() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenyRustRequest(DenyEachBindingOnlyDenyRustRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyRustRequest& operator=(DenyEachBindingOnlyDenyRustRequest&&) noexcept = default;
  DenyEachBindingOnlyDenyRustRequest(const DenyEachBindingOnlyDenyRustRequest& other) noexcept;
  DenyEachBindingOnlyDenyRustRequest& operator=(const DenyEachBindingOnlyDenyRustRequest& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenyRustRequest& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyRustRequest& other) const noexcept;

  bool
  a() const;

  bool& a();

  // Setter for a.
  //

  DenyEachBindingOnlyDenyRustRequest& a(bool value);

  DenyEachBindingOnlyDenyRustRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    bool a = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::a, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenyRustResponse {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenyRustResponse(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenyRustResponse(int32_t b) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenyRustResponse| only if all of its members are default constructible.
  DenyEachBindingOnlyDenyRustResponse() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenyRustResponse(DenyEachBindingOnlyDenyRustResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyRustResponse& operator=(DenyEachBindingOnlyDenyRustResponse&&) noexcept = default;
  DenyEachBindingOnlyDenyRustResponse(const DenyEachBindingOnlyDenyRustResponse& other) noexcept;
  DenyEachBindingOnlyDenyRustResponse& operator=(const DenyEachBindingOnlyDenyRustResponse& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenyRustResponse& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyRustResponse& other) const noexcept;

  int32_t
  b() const;

  int32_t& b();

  // Setter for b.
  //

  DenyEachBindingOnlyDenyRustResponse& b(int32_t value);

  DenyEachBindingOnlyDenyRustResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    int32_t b = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::b, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenyRustResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  DenyEachBindingOnlyDenyRustResult(DenyEachBindingOnlyDenyRustResult&& other) noexcept;
  DenyEachBindingOnlyDenyRustResult& operator=(DenyEachBindingOnlyDenyRustResult&& other) noexcept;
  DenyEachBindingOnlyDenyRustResult(const DenyEachBindingOnlyDenyRustResult& other) noexcept;
  DenyEachBindingOnlyDenyRustResult& operator=(const DenyEachBindingOnlyDenyRustResult& other) noexcept;
  bool operator==(const DenyEachBindingOnlyDenyRustResult& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenyRustResult& other) const noexcept;

  ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult::Tag Which() const;
  static DenyEachBindingOnlyDenyRustResult WithResponse(::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  DenyEachBindingOnlyDenyRustResult& response(::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse value);
  static DenyEachBindingOnlyDenyRustResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  DenyEachBindingOnlyDenyRustResult& err(uint32_t value);

  DenyEachBindingOnlyDenyRustResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit DenyEachBindingOnlyDenyRustResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult::Tag tag);
  static std::optional<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult::Tag> IndexToTag(size_t index);
};

class DenyEachBindingOnlyDenySyzkallerRequest {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenySyzkallerRequest(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenySyzkallerRequest(bool a) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenySyzkallerRequest| only if all of its members are default constructible.
  DenyEachBindingOnlyDenySyzkallerRequest() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenySyzkallerRequest(DenyEachBindingOnlyDenySyzkallerRequest&&) noexcept = default;
  DenyEachBindingOnlyDenySyzkallerRequest& operator=(DenyEachBindingOnlyDenySyzkallerRequest&&) noexcept = default;
  DenyEachBindingOnlyDenySyzkallerRequest(const DenyEachBindingOnlyDenySyzkallerRequest& other) noexcept;
  DenyEachBindingOnlyDenySyzkallerRequest& operator=(const DenyEachBindingOnlyDenySyzkallerRequest& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenySyzkallerRequest& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenySyzkallerRequest& other) const noexcept;

  bool
  a() const;

  bool& a();

  // Setter for a.
  //

  DenyEachBindingOnlyDenySyzkallerRequest& a(bool value);

  DenyEachBindingOnlyDenySyzkallerRequest(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    bool a = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::a, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenySyzkallerResponse {
 private:
  struct Storage_;

 public:
  DenyEachBindingOnlyDenySyzkallerResponse(Storage_ storage) noexcept;
  DenyEachBindingOnlyDenySyzkallerResponse(int32_t b) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |DenyEachBindingOnlyDenySyzkallerResponse| only if all of its members are default constructible.
  DenyEachBindingOnlyDenySyzkallerResponse() = default;
#pragma clang diagnostic pop

  DenyEachBindingOnlyDenySyzkallerResponse(DenyEachBindingOnlyDenySyzkallerResponse&&) noexcept = default;
  DenyEachBindingOnlyDenySyzkallerResponse& operator=(DenyEachBindingOnlyDenySyzkallerResponse&&) noexcept = default;
  DenyEachBindingOnlyDenySyzkallerResponse(const DenyEachBindingOnlyDenySyzkallerResponse& other) noexcept;
  DenyEachBindingOnlyDenySyzkallerResponse& operator=(const DenyEachBindingOnlyDenySyzkallerResponse& other) noexcept;

  bool operator==(const DenyEachBindingOnlyDenySyzkallerResponse& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenySyzkallerResponse& other) const noexcept;

  int32_t
  b() const;

  int32_t& b();

  // Setter for b.
  //

  DenyEachBindingOnlyDenySyzkallerResponse& b(int32_t value);

  DenyEachBindingOnlyDenySyzkallerResponse(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    int32_t b = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse, 4>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, int32_t, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::b, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class DenyEachBindingOnlyDenySyzkallerResult {
 private:
  using Storage_ =
      std::variant<
          std::monostate, ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  DenyEachBindingOnlyDenySyzkallerResult(DenyEachBindingOnlyDenySyzkallerResult&& other) noexcept;
  DenyEachBindingOnlyDenySyzkallerResult& operator=(DenyEachBindingOnlyDenySyzkallerResult&& other) noexcept;
  DenyEachBindingOnlyDenySyzkallerResult(const DenyEachBindingOnlyDenySyzkallerResult& other) noexcept;
  DenyEachBindingOnlyDenySyzkallerResult& operator=(const DenyEachBindingOnlyDenySyzkallerResult& other) noexcept;
  bool operator==(const DenyEachBindingOnlyDenySyzkallerResult& other) const noexcept;
  bool operator!=(const DenyEachBindingOnlyDenySyzkallerResult& other) const noexcept;

  ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult::Tag Which() const;
  static DenyEachBindingOnlyDenySyzkallerResult WithResponse(::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse val);
  const ::fidl::internal::UnionMemberView<1, Storage_> response() const;
  ::fidl::internal::UnionMemberView<1, Storage_> response();

  // Sets the union to hold the response member.
  //

  DenyEachBindingOnlyDenySyzkallerResult& response(::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse value);
  static DenyEachBindingOnlyDenySyzkallerResult WithErr(uint32_t val);
  const ::fidl::internal::UnionMemberView<2, Storage_> err() const;
  ::fidl::internal::UnionMemberView<2, Storage_> err();

  // Sets the union to hold the err member.
  //

  DenyEachBindingOnlyDenySyzkallerResult& err(uint32_t value);

  DenyEachBindingOnlyDenySyzkallerResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalUnionMember<::fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>(), ::fidl::internal::NaturalUnionMember<fidl::internal::NaturalCodingConstraintEmpty>());

  explicit DenyEachBindingOnlyDenySyzkallerResult(std::shared_ptr<Storage_> storage);

  static size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult::Tag tag);
  static std::optional<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult::Tag> IndexToTag(size_t index);
};

class MemberOnlyAppearsInImportingLibrary {
 private:
  struct Storage_;

 public:
  MemberOnlyAppearsInImportingLibrary(Storage_ storage) noexcept;
  MemberOnlyAppearsInImportingLibrary(bool a) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |MemberOnlyAppearsInImportingLibrary| only if all of its members are default constructible.
  MemberOnlyAppearsInImportingLibrary() = default;
#pragma clang diagnostic pop

  MemberOnlyAppearsInImportingLibrary(MemberOnlyAppearsInImportingLibrary&&) noexcept = default;
  MemberOnlyAppearsInImportingLibrary& operator=(MemberOnlyAppearsInImportingLibrary&&) noexcept = default;
  MemberOnlyAppearsInImportingLibrary(const MemberOnlyAppearsInImportingLibrary& other) noexcept;
  MemberOnlyAppearsInImportingLibrary& operator=(const MemberOnlyAppearsInImportingLibrary& other) noexcept;

  bool operator==(const MemberOnlyAppearsInImportingLibrary& other) const noexcept;
  bool operator!=(const MemberOnlyAppearsInImportingLibrary& other) const noexcept;

  bool
  a() const;

  bool& a();

  // Setter for a.
  //

  MemberOnlyAppearsInImportingLibrary& a(bool value);

  MemberOnlyAppearsInImportingLibrary(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    bool a = {};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::a, 0});
  static constexpr auto kPadding = std::make_tuple();
};

class OnlyAppearsInImportingLibrary {
 private:
  struct Storage_;

 public:
  OnlyAppearsInImportingLibrary(Storage_ storage) noexcept;
  OnlyAppearsInImportingLibrary(::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary member_only_appears_in_importing_library) noexcept;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdefaulted-function-deleted"
  // Default constructs a |OnlyAppearsInImportingLibrary| only if all of its members are default constructible.
  OnlyAppearsInImportingLibrary() = default;
#pragma clang diagnostic pop

  OnlyAppearsInImportingLibrary(OnlyAppearsInImportingLibrary&&) noexcept = default;
  OnlyAppearsInImportingLibrary& operator=(OnlyAppearsInImportingLibrary&&) noexcept = default;
  OnlyAppearsInImportingLibrary(const OnlyAppearsInImportingLibrary& other) noexcept;
  OnlyAppearsInImportingLibrary& operator=(const OnlyAppearsInImportingLibrary& other) noexcept;

  bool operator==(const OnlyAppearsInImportingLibrary& other) const noexcept;
  bool operator!=(const OnlyAppearsInImportingLibrary& other) const noexcept;

  const ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary&
  member_only_appears_in_importing_library() const;

  ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary& member_only_appears_in_importing_library();

  // Setter for member_only_appears_in_importing_library.
  //

  OnlyAppearsInImportingLibrary& member_only_appears_in_importing_library(::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary value);

  OnlyAppearsInImportingLibrary(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag);

 private:
  struct Storage_ final {
    ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary member_only_appears_in_importing_library;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::OnlyAppearsInImportingLibrary, 1>;
  friend struct ::fidl::internal::MemberVisitor<::test_bindingsdenylist::OnlyAppearsInImportingLibrary>;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::NaturalStructMember<Storage_, ::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary, fidl::internal::NaturalCodingConstraintEmpty>{
      &Storage_::member_only_appears_in_importing_library, 0});
  static constexpr auto kPadding = std::make_tuple();
};

}  // namespace test_bindingsdenylist
namespace fidl {

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartRequest, 1> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResponse, 4> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoRequest, 1> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResponse, 4> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonRequest> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonRequest, 1> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResponse, 4> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustRequest, 1> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResponse, 4> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerRequest, 1> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResponse, 4> {};

template <>
struct IsFidlType<::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::MemberOnlyAppearsInImportingLibrary, 1> {};

template <>
struct IsFidlType<::test_bindingsdenylist::OnlyAppearsInImportingLibrary> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::OnlyAppearsInImportingLibrary> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsStruct<::test_bindingsdenylist::OnlyAppearsInImportingLibrary> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::OnlyAppearsInImportingLibrary, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalStructCodingTraits<::test_bindingsdenylist::OnlyAppearsInImportingLibrary, 1> {};

template <>
struct IsFidlType<::test_bindingsdenylist::OnlyLlcpp> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::OnlyLlcpp> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_bindingsdenylist::OnlyLlcpp> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::OnlyLlcpp, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::OnlyLlcpp> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyDartResult> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyGoResult> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyPythonResult> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenyRustResult> {};

template <>
struct IsFidlType<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult> : public std::true_type {};

template <>
struct TypeTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsUnion<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult> : public std::true_type {};

template <>
struct internal::NaturalCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult, ::fidl::internal::NaturalCodingConstraintEmpty> final
    : public ::fidl::internal::NaturalUnionCodingTraits<::test_bindingsdenylist::DenyEachBindingOnlyDenySyzkallerResult> {};

#pragma clang diagnostic pop

}  // namespace fidl
