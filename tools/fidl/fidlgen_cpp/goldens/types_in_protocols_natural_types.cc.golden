// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.typesinprotocols/cpp/natural_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

  void fidl::internal::NaturalCodingTraits<::test_typesinprotocols::Bits, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
      fidl::internal::NaturalEncoder* encoder, ::test_typesinprotocols::Bits* value, size_t offset, size_t recursion_depth) {
    *encoder->template GetPtr<::test_typesinprotocols::Bits>(offset) = *value;
  }
  void fidl::internal::NaturalCodingTraits<::test_typesinprotocols::Bits, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
      fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::Bits* value, size_t offset, size_t recursion_depth) {
    *value = *decoder->template GetPtr<::test_typesinprotocols::Bits>(offset);
  }

  void fidl::internal::NaturalCodingTraits<::test_typesinprotocols::Enum, ::fidl::internal::NaturalCodingConstraintEmpty>::Encode(
      fidl::internal::NaturalEncoder* encoder, ::test_typesinprotocols::Enum* value, size_t offset, size_t recursion_depth) {
    *encoder->template GetPtr<::test_typesinprotocols::Enum>(offset) = *value;
  }

  void fidl::internal::NaturalCodingTraits<::test_typesinprotocols::Enum, ::fidl::internal::NaturalCodingConstraintEmpty>::Decode(
      fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::Enum* value, size_t offset, size_t recursion_depth) {
    *value = *decoder->template GetPtr<::test_typesinprotocols::Enum>(offset);
  }

  ::test_typesinprotocols::Struct::Struct(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::Struct::Struct(uint8_t __reserved) noexcept
    : storage_({
      .__reserved = std::move(__reserved)
    }) {}

  ::test_typesinprotocols::Struct::Struct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Struct(Storage_{
      .__reserved =0u,
  }) {}
    ::test_typesinprotocols::Struct::Struct(const ::test_typesinprotocols::Struct& other) noexcept : ::test_typesinprotocols::Struct(other.CloneStorage_()){}

    ::test_typesinprotocols::Struct& test_typesinprotocols::Struct::operator=(const ::test_typesinprotocols::Struct& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::Struct::operator==(const Struct& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Struct, 1>::Equal(this, &other);
    }

    bool test_typesinprotocols::Struct::operator!=(const Struct& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Struct, 1>::Equal(this, &other);
    }

    ::test_typesinprotocols::Struct::Storage_ test_typesinprotocols::Struct::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.__reserved)
      };
    }
      uint8_t
    test_typesinprotocols::Struct::__reserved() const {
      return storage_.__reserved;
    }

    uint8_t& ::test_typesinprotocols::Struct::__reserved() {
      return storage_.__reserved;
    }

    ::test_typesinprotocols::Struct& ::test_typesinprotocols::Struct::__reserved(uint8_t value) {
      storage_.__reserved = std::move(value);
      return *this;
    }

#ifdef __Fuchsia__

  ::test_typesinprotocols::ResourceStruct::ResourceStruct(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::ResourceStruct::ResourceStruct(uint8_t __reserved) noexcept
    : storage_({
      .__reserved = std::move(__reserved)
    }) {}

  ::test_typesinprotocols::ResourceStruct::ResourceStruct(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ResourceStruct(Storage_{
      .__reserved =0u,
  }) {}
      uint8_t
    test_typesinprotocols::ResourceStruct::__reserved() const {
      return storage_.__reserved;
    }

    uint8_t& ::test_typesinprotocols::ResourceStruct::__reserved() {
      return storage_.__reserved;
    }

    ::test_typesinprotocols::ResourceStruct& ::test_typesinprotocols::ResourceStruct::__reserved(uint8_t value) {
      storage_.__reserved = std::move(value);
      return *this;
    }

#endif  // __Fuchsia__

  ::test_typesinprotocols::Basic::Basic(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::Basic::Basic(uint8_t uint8, uint16_t uint16, uint32_t uint32, uint64_t uint64, int8_t int8, int16_t int16, int32_t int32, int64_t int64, float float32, double float64, ::std::string string, ::std::optional<::std::string> opt_string) noexcept
    : storage_({
      .uint8 = std::move(uint8), 
      .uint16 = std::move(uint16), 
      .uint32 = std::move(uint32), 
      .uint64 = std::move(uint64), 
      .int8 = std::move(int8), 
      .int16 = std::move(int16), 
      .int32 = std::move(int32), 
      .int64 = std::move(int64), 
      .float32 = std::move(float32), 
      .float64 = std::move(float64), 
      .string = std::move(string), 
      .opt_string = std::move(opt_string)
    }) {}

  ::test_typesinprotocols::Basic::Basic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Basic(Storage_{
      .uint8 ={},
      .uint16 ={},
      .uint32 ={},
      .uint64 ={},
      .int8 ={},
      .int16 ={},
      .int32 ={},
      .int64 ={},
      .float32 ={},
      .float64 ={},
      .string ={},
      .opt_string ={},
  }) {}
    ::test_typesinprotocols::Basic::Basic(const ::test_typesinprotocols::Basic& other) noexcept : ::test_typesinprotocols::Basic(other.CloneStorage_()){}

    ::test_typesinprotocols::Basic& test_typesinprotocols::Basic::operator=(const ::test_typesinprotocols::Basic& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::Basic::operator==(const Basic& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Basic, 80>::Equal(this, &other);
    }

    bool test_typesinprotocols::Basic::operator!=(const Basic& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Basic, 80>::Equal(this, &other);
    }

    ::test_typesinprotocols::Basic::Storage_ test_typesinprotocols::Basic::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.uint8), 
          ::fidl::internal::NaturalClone(storage_.uint16), 
          ::fidl::internal::NaturalClone(storage_.uint32), 
          ::fidl::internal::NaturalClone(storage_.uint64), 
          ::fidl::internal::NaturalClone(storage_.int8), 
          ::fidl::internal::NaturalClone(storage_.int16), 
          ::fidl::internal::NaturalClone(storage_.int32), 
          ::fidl::internal::NaturalClone(storage_.int64), 
          ::fidl::internal::NaturalClone(storage_.float32), 
          ::fidl::internal::NaturalClone(storage_.float64), 
          ::fidl::internal::NaturalClone(storage_.string), 
          ::fidl::internal::NaturalClone(storage_.opt_string)
      };
    }
      uint8_t
    test_typesinprotocols::Basic::uint8() const {
      return storage_.uint8;
    }

    uint8_t& ::test_typesinprotocols::Basic::uint8() {
      return storage_.uint8;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::uint8(uint8_t value) {
      storage_.uint8 = std::move(value);
      return *this;
    }
      uint16_t
    test_typesinprotocols::Basic::uint16() const {
      return storage_.uint16;
    }

    uint16_t& ::test_typesinprotocols::Basic::uint16() {
      return storage_.uint16;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::uint16(uint16_t value) {
      storage_.uint16 = std::move(value);
      return *this;
    }
      uint32_t
    test_typesinprotocols::Basic::uint32() const {
      return storage_.uint32;
    }

    uint32_t& ::test_typesinprotocols::Basic::uint32() {
      return storage_.uint32;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::uint32(uint32_t value) {
      storage_.uint32 = std::move(value);
      return *this;
    }
      uint64_t
    test_typesinprotocols::Basic::uint64() const {
      return storage_.uint64;
    }

    uint64_t& ::test_typesinprotocols::Basic::uint64() {
      return storage_.uint64;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::uint64(uint64_t value) {
      storage_.uint64 = std::move(value);
      return *this;
    }
      int8_t
    test_typesinprotocols::Basic::int8() const {
      return storage_.int8;
    }

    int8_t& ::test_typesinprotocols::Basic::int8() {
      return storage_.int8;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::int8(int8_t value) {
      storage_.int8 = std::move(value);
      return *this;
    }
      int16_t
    test_typesinprotocols::Basic::int16() const {
      return storage_.int16;
    }

    int16_t& ::test_typesinprotocols::Basic::int16() {
      return storage_.int16;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::int16(int16_t value) {
      storage_.int16 = std::move(value);
      return *this;
    }
      int32_t
    test_typesinprotocols::Basic::int32() const {
      return storage_.int32;
    }

    int32_t& ::test_typesinprotocols::Basic::int32() {
      return storage_.int32;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::int32(int32_t value) {
      storage_.int32 = std::move(value);
      return *this;
    }
      int64_t
    test_typesinprotocols::Basic::int64() const {
      return storage_.int64;
    }

    int64_t& ::test_typesinprotocols::Basic::int64() {
      return storage_.int64;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::int64(int64_t value) {
      storage_.int64 = std::move(value);
      return *this;
    }
      float
    test_typesinprotocols::Basic::float32() const {
      return storage_.float32;
    }

    float& ::test_typesinprotocols::Basic::float32() {
      return storage_.float32;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::float32(float value) {
      storage_.float32 = std::move(value);
      return *this;
    }
      double
    test_typesinprotocols::Basic::float64() const {
      return storage_.float64;
    }

    double& ::test_typesinprotocols::Basic::float64() {
      return storage_.float64;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::float64(double value) {
      storage_.float64 = std::move(value);
      return *this;
    }
      const ::std::string &
    test_typesinprotocols::Basic::string() const {
      return storage_.string;
    }

    ::std::string& ::test_typesinprotocols::Basic::string() {
      return storage_.string;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::string(::std::string value) {
      storage_.string = std::move(value);
      return *this;
    }
      const ::std::optional<::std::string> &
    test_typesinprotocols::Basic::opt_string() const {
      return storage_.opt_string;
    }

    ::std::optional<::std::string>& ::test_typesinprotocols::Basic::opt_string() {
      return storage_.opt_string;
    }

    ::test_typesinprotocols::Basic& ::test_typesinprotocols::Basic::opt_string(::std::optional<::std::string> value) {
      storage_.opt_string = std::move(value);
      return *this;
    }

  ::test_typesinprotocols::Compound::Compound(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::Compound::Compound(::test_typesinprotocols::Bits bits, ::test_typesinprotocols::Enum enum_, ::test_typesinprotocols::Struct struct_, ::test_typesinprotocols::Table table, ::test_typesinprotocols::Union union_, ::fidl::Box<::test_typesinprotocols::Struct> opt_struct, ::fidl::Box<::test_typesinprotocols::Union> opt_union) noexcept
    : storage_({
      .bits = std::move(bits), 
      .enum_ = std::move(enum_), 
      .struct_ = std::move(struct_), 
      .table = std::move(table), 
      .union_ = std::move(union_), 
      .opt_struct = std::move(opt_struct), 
      .opt_union = std::move(opt_union)
    }) {}

  ::test_typesinprotocols::Compound::Compound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Compound(Storage_{
      .bits ={},
      .enum_ ={},
      .struct_ =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .table =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .union_ =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .opt_struct ={},
      .opt_union ={},
  }) {}
    ::test_typesinprotocols::Compound::Compound(const ::test_typesinprotocols::Compound& other) noexcept : ::test_typesinprotocols::Compound(other.CloneStorage_()){}

    ::test_typesinprotocols::Compound& test_typesinprotocols::Compound::operator=(const ::test_typesinprotocols::Compound& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::Compound::operator==(const Compound& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Compound, 72>::Equal(this, &other);
    }

    bool test_typesinprotocols::Compound::operator!=(const Compound& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::Compound, 72>::Equal(this, &other);
    }

    ::test_typesinprotocols::Compound::Storage_ test_typesinprotocols::Compound::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.bits), 
          ::fidl::internal::NaturalClone(storage_.enum_), 
          ::fidl::internal::NaturalClone(storage_.struct_), 
          ::fidl::internal::NaturalClone(storage_.table), 
          ::fidl::internal::NaturalClone(storage_.union_), 
          ::fidl::internal::NaturalClone(storage_.opt_struct), 
          ::fidl::internal::NaturalClone(storage_.opt_union)
      };
    }
      ::test_typesinprotocols::Bits
    test_typesinprotocols::Compound::bits() const {
      return storage_.bits;
    }

    ::test_typesinprotocols::Bits& ::test_typesinprotocols::Compound::bits() {
      return storage_.bits;
    }

    ::test_typesinprotocols::Compound& ::test_typesinprotocols::Compound::bits(::test_typesinprotocols::Bits value) {
      storage_.bits = std::move(value);
      return *this;
    }
      ::test_typesinprotocols::Enum
    test_typesinprotocols::Compound::enum_() const {
      return storage_.enum_;
    }

    ::test_typesinprotocols::Enum& ::test_typesinprotocols::Compound::enum_() {
      return storage_.enum_;
    }

    ::test_typesinprotocols::Compound& ::test_typesinprotocols::Compound::enum_(::test_typesinprotocols::Enum value) {
      storage_.enum_ = std::move(value);
      return *this;
    }
      const ::test_typesinprotocols::Struct &
    test_typesinprotocols::Compound::struct_() const {
      return storage_.struct_;
    }

    ::test_typesinprotocols::Struct& ::test_typesinprotocols::Compound::struct_() {
      return storage_.struct_;
    }

    ::test_typesinprotocols::Compound& ::test_typesinprotocols::Compound::struct_(::test_typesinprotocols::Struct value) {
      storage_.struct_ = std::move(value);
      return *this;
    }
      const ::test_typesinprotocols::Table &
    test_typesinprotocols::Compound::table() const {
      return storage_.table;
    }

    ::test_typesinprotocols::Table& ::test_typesinprotocols::Compound::table() {
      return storage_.table;
    }

    ::test_typesinprotocols::Compound& ::test_typesinprotocols::Compound::table(::test_typesinprotocols::Table value) {
      storage_.table = std::move(value);
      return *this;
    }
      const ::test_typesinprotocols::Union &
    test_typesinprotocols::Compound::union_() const {
      return storage_.union_;
    }

    ::test_typesinprotocols::Union& ::test_typesinprotocols::Compound::union_() {
      return storage_.union_;
    }

    ::test_typesinprotocols::Compound& ::test_typesinprotocols::Compound::union_(::test_typesinprotocols::Union value) {
      storage_.union_ = std::move(value);
      return *this;
    }
      const ::fidl::Box<::test_typesinprotocols::Struct> &
    test_typesinprotocols::Compound::opt_struct() const {
      return storage_.opt_struct;
    }

    ::fidl::Box<::test_typesinprotocols::Struct>& ::test_typesinprotocols::Compound::opt_struct() {
      return storage_.opt_struct;
    }

    ::test_typesinprotocols::Compound& ::test_typesinprotocols::Compound::opt_struct(::fidl::Box<::test_typesinprotocols::Struct> value) {
      storage_.opt_struct = std::move(value);
      return *this;
    }
      const ::fidl::Box<::test_typesinprotocols::Union> &
    test_typesinprotocols::Compound::opt_union() const {
      return storage_.opt_union;
    }

    ::fidl::Box<::test_typesinprotocols::Union>& ::test_typesinprotocols::Compound::opt_union() {
      return storage_.opt_union;
    }

    ::test_typesinprotocols::Compound& ::test_typesinprotocols::Compound::opt_union(::fidl::Box<::test_typesinprotocols::Union> value) {
      storage_.opt_union = std::move(value);
      return *this;
    }

  ::test_typesinprotocols::ArrayBasic::ArrayBasic(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::ArrayBasic::ArrayBasic(::std::array<uint8_t, 5> array_uint8, ::std::array<uint16_t, 5> array_uint16, ::std::array<uint32_t, 5> array_uint32, ::std::array<uint64_t, 5> array_uint64, ::std::array<int8_t, 5> array_int8, ::std::array<int16_t, 5> array_int16, ::std::array<int32_t, 5> array_int32, ::std::array<int64_t, 5> array_int64, ::std::array<float, 5> array_float32, ::std::array<double, 5> array_float64, ::std::array<::std::string, 5> array_string, ::std::array<::std::optional<::std::string>, 5> array_opt_string) noexcept
    : storage_({
      .array_uint8 = std::move(array_uint8), 
      .array_uint16 = std::move(array_uint16), 
      .array_uint32 = std::move(array_uint32), 
      .array_uint64 = std::move(array_uint64), 
      .array_int8 = std::move(array_int8), 
      .array_int16 = std::move(array_int16), 
      .array_int32 = std::move(array_int32), 
      .array_int64 = std::move(array_int64), 
      .array_float32 = std::move(array_float32), 
      .array_float64 = std::move(array_float64), 
      .array_string = std::move(array_string), 
      .array_opt_string = std::move(array_opt_string)
    }) {}

  ::test_typesinprotocols::ArrayBasic::ArrayBasic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ArrayBasic(Storage_{
      .array_uint8 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint8_t, 5>>::Make(),
      .array_uint16 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint16_t, 5>>::Make(),
      .array_uint32 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint32_t, 5>>::Make(),
      .array_uint64 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<uint64_t, 5>>::Make(),
      .array_int8 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<int8_t, 5>>::Make(),
      .array_int16 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<int16_t, 5>>::Make(),
      .array_int32 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<int32_t, 5>>::Make(),
      .array_int64 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<int64_t, 5>>::Make(),
      .array_float32 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<float, 5>>::Make(),
      .array_float64 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<double, 5>>::Make(),
      .array_string =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::std::string, 5>>::Make(),
      .array_opt_string =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::std::optional<::std::string>, 5>>::Make(),
  }) {}
    ::test_typesinprotocols::ArrayBasic::ArrayBasic(const ::test_typesinprotocols::ArrayBasic& other) noexcept : ::test_typesinprotocols::ArrayBasic(other.CloneStorage_()){}

    ::test_typesinprotocols::ArrayBasic& test_typesinprotocols::ArrayBasic::operator=(const ::test_typesinprotocols::ArrayBasic& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::ArrayBasic::operator==(const ArrayBasic& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayBasic, 384>::Equal(this, &other);
    }

    bool test_typesinprotocols::ArrayBasic::operator!=(const ArrayBasic& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayBasic, 384>::Equal(this, &other);
    }

    ::test_typesinprotocols::ArrayBasic::Storage_ test_typesinprotocols::ArrayBasic::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.array_uint8), 
          ::fidl::internal::NaturalClone(storage_.array_uint16), 
          ::fidl::internal::NaturalClone(storage_.array_uint32), 
          ::fidl::internal::NaturalClone(storage_.array_uint64), 
          ::fidl::internal::NaturalClone(storage_.array_int8), 
          ::fidl::internal::NaturalClone(storage_.array_int16), 
          ::fidl::internal::NaturalClone(storage_.array_int32), 
          ::fidl::internal::NaturalClone(storage_.array_int64), 
          ::fidl::internal::NaturalClone(storage_.array_float32), 
          ::fidl::internal::NaturalClone(storage_.array_float64), 
          ::fidl::internal::NaturalClone(storage_.array_string), 
          ::fidl::internal::NaturalClone(storage_.array_opt_string)
      };
    }
      const ::std::array<uint8_t, 5> &
    test_typesinprotocols::ArrayBasic::array_uint8() const {
      return storage_.array_uint8;
    }

    ::std::array<uint8_t, 5>& ::test_typesinprotocols::ArrayBasic::array_uint8() {
      return storage_.array_uint8;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_uint8(::std::array<uint8_t, 5> value) {
      storage_.array_uint8 = std::move(value);
      return *this;
    }
      const ::std::array<uint16_t, 5> &
    test_typesinprotocols::ArrayBasic::array_uint16() const {
      return storage_.array_uint16;
    }

    ::std::array<uint16_t, 5>& ::test_typesinprotocols::ArrayBasic::array_uint16() {
      return storage_.array_uint16;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_uint16(::std::array<uint16_t, 5> value) {
      storage_.array_uint16 = std::move(value);
      return *this;
    }
      const ::std::array<uint32_t, 5> &
    test_typesinprotocols::ArrayBasic::array_uint32() const {
      return storage_.array_uint32;
    }

    ::std::array<uint32_t, 5>& ::test_typesinprotocols::ArrayBasic::array_uint32() {
      return storage_.array_uint32;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_uint32(::std::array<uint32_t, 5> value) {
      storage_.array_uint32 = std::move(value);
      return *this;
    }
      const ::std::array<uint64_t, 5> &
    test_typesinprotocols::ArrayBasic::array_uint64() const {
      return storage_.array_uint64;
    }

    ::std::array<uint64_t, 5>& ::test_typesinprotocols::ArrayBasic::array_uint64() {
      return storage_.array_uint64;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_uint64(::std::array<uint64_t, 5> value) {
      storage_.array_uint64 = std::move(value);
      return *this;
    }
      const ::std::array<int8_t, 5> &
    test_typesinprotocols::ArrayBasic::array_int8() const {
      return storage_.array_int8;
    }

    ::std::array<int8_t, 5>& ::test_typesinprotocols::ArrayBasic::array_int8() {
      return storage_.array_int8;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_int8(::std::array<int8_t, 5> value) {
      storage_.array_int8 = std::move(value);
      return *this;
    }
      const ::std::array<int16_t, 5> &
    test_typesinprotocols::ArrayBasic::array_int16() const {
      return storage_.array_int16;
    }

    ::std::array<int16_t, 5>& ::test_typesinprotocols::ArrayBasic::array_int16() {
      return storage_.array_int16;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_int16(::std::array<int16_t, 5> value) {
      storage_.array_int16 = std::move(value);
      return *this;
    }
      const ::std::array<int32_t, 5> &
    test_typesinprotocols::ArrayBasic::array_int32() const {
      return storage_.array_int32;
    }

    ::std::array<int32_t, 5>& ::test_typesinprotocols::ArrayBasic::array_int32() {
      return storage_.array_int32;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_int32(::std::array<int32_t, 5> value) {
      storage_.array_int32 = std::move(value);
      return *this;
    }
      const ::std::array<int64_t, 5> &
    test_typesinprotocols::ArrayBasic::array_int64() const {
      return storage_.array_int64;
    }

    ::std::array<int64_t, 5>& ::test_typesinprotocols::ArrayBasic::array_int64() {
      return storage_.array_int64;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_int64(::std::array<int64_t, 5> value) {
      storage_.array_int64 = std::move(value);
      return *this;
    }
      const ::std::array<float, 5> &
    test_typesinprotocols::ArrayBasic::array_float32() const {
      return storage_.array_float32;
    }

    ::std::array<float, 5>& ::test_typesinprotocols::ArrayBasic::array_float32() {
      return storage_.array_float32;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_float32(::std::array<float, 5> value) {
      storage_.array_float32 = std::move(value);
      return *this;
    }
      const ::std::array<double, 5> &
    test_typesinprotocols::ArrayBasic::array_float64() const {
      return storage_.array_float64;
    }

    ::std::array<double, 5>& ::test_typesinprotocols::ArrayBasic::array_float64() {
      return storage_.array_float64;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_float64(::std::array<double, 5> value) {
      storage_.array_float64 = std::move(value);
      return *this;
    }
      const ::std::array<::std::string, 5> &
    test_typesinprotocols::ArrayBasic::array_string() const {
      return storage_.array_string;
    }

    ::std::array<::std::string, 5>& ::test_typesinprotocols::ArrayBasic::array_string() {
      return storage_.array_string;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_string(::std::array<::std::string, 5> value) {
      storage_.array_string = std::move(value);
      return *this;
    }
      const ::std::array<::std::optional<::std::string>, 5> &
    test_typesinprotocols::ArrayBasic::array_opt_string() const {
      return storage_.array_opt_string;
    }

    ::std::array<::std::optional<::std::string>, 5>& ::test_typesinprotocols::ArrayBasic::array_opt_string() {
      return storage_.array_opt_string;
    }

    ::test_typesinprotocols::ArrayBasic& ::test_typesinprotocols::ArrayBasic::array_opt_string(::std::array<::std::optional<::std::string>, 5> value) {
      storage_.array_opt_string = std::move(value);
      return *this;
    }

  ::test_typesinprotocols::ArrayCompound::ArrayCompound(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::ArrayCompound::ArrayCompound(::std::array<::test_typesinprotocols::Bits, 5> array_bits, ::std::array<::test_typesinprotocols::Enum, 5> array_enum, ::std::array<::test_typesinprotocols::Struct, 5> array_struct, ::std::array<::test_typesinprotocols::Table, 5> array_table, ::std::array<::test_typesinprotocols::Union, 5> array_union, ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> array_opt_struct, ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> array_opt_union) noexcept
    : storage_({
      .array_bits = std::move(array_bits), 
      .array_enum = std::move(array_enum), 
      .array_struct = std::move(array_struct), 
      .array_table = std::move(array_table), 
      .array_union = std::move(array_union), 
      .array_opt_struct = std::move(array_opt_struct), 
      .array_opt_union = std::move(array_opt_union)
    }) {}

  ::test_typesinprotocols::ArrayCompound::ArrayCompound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ArrayCompound(Storage_{
      .array_bits =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Bits, 5>>::Make(),
      .array_enum =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Enum, 5>>::Make(),
      .array_struct =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Struct, 5>>::Make(),
      .array_table =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Table, 5>>::Make(),
      .array_union =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::Union, 5>>::Make(),
      .array_opt_struct =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5>>::Make(),
      .array_opt_union =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5>>::Make(),
  }) {}
    ::test_typesinprotocols::ArrayCompound::ArrayCompound(const ::test_typesinprotocols::ArrayCompound& other) noexcept : ::test_typesinprotocols::ArrayCompound(other.CloneStorage_()){}

    ::test_typesinprotocols::ArrayCompound& test_typesinprotocols::ArrayCompound::operator=(const ::test_typesinprotocols::ArrayCompound& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::ArrayCompound::operator==(const ArrayCompound& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayCompound, 328>::Equal(this, &other);
    }

    bool test_typesinprotocols::ArrayCompound::operator!=(const ArrayCompound& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayCompound, 328>::Equal(this, &other);
    }

    ::test_typesinprotocols::ArrayCompound::Storage_ test_typesinprotocols::ArrayCompound::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.array_bits), 
          ::fidl::internal::NaturalClone(storage_.array_enum), 
          ::fidl::internal::NaturalClone(storage_.array_struct), 
          ::fidl::internal::NaturalClone(storage_.array_table), 
          ::fidl::internal::NaturalClone(storage_.array_union), 
          ::fidl::internal::NaturalClone(storage_.array_opt_struct), 
          ::fidl::internal::NaturalClone(storage_.array_opt_union)
      };
    }
      const ::std::array<::test_typesinprotocols::Bits, 5> &
    test_typesinprotocols::ArrayCompound::array_bits() const {
      return storage_.array_bits;
    }

    ::std::array<::test_typesinprotocols::Bits, 5>& ::test_typesinprotocols::ArrayCompound::array_bits() {
      return storage_.array_bits;
    }

    ::test_typesinprotocols::ArrayCompound& ::test_typesinprotocols::ArrayCompound::array_bits(::std::array<::test_typesinprotocols::Bits, 5> value) {
      storage_.array_bits = std::move(value);
      return *this;
    }
      const ::std::array<::test_typesinprotocols::Enum, 5> &
    test_typesinprotocols::ArrayCompound::array_enum() const {
      return storage_.array_enum;
    }

    ::std::array<::test_typesinprotocols::Enum, 5>& ::test_typesinprotocols::ArrayCompound::array_enum() {
      return storage_.array_enum;
    }

    ::test_typesinprotocols::ArrayCompound& ::test_typesinprotocols::ArrayCompound::array_enum(::std::array<::test_typesinprotocols::Enum, 5> value) {
      storage_.array_enum = std::move(value);
      return *this;
    }
      const ::std::array<::test_typesinprotocols::Struct, 5> &
    test_typesinprotocols::ArrayCompound::array_struct() const {
      return storage_.array_struct;
    }

    ::std::array<::test_typesinprotocols::Struct, 5>& ::test_typesinprotocols::ArrayCompound::array_struct() {
      return storage_.array_struct;
    }

    ::test_typesinprotocols::ArrayCompound& ::test_typesinprotocols::ArrayCompound::array_struct(::std::array<::test_typesinprotocols::Struct, 5> value) {
      storage_.array_struct = std::move(value);
      return *this;
    }
      const ::std::array<::test_typesinprotocols::Table, 5> &
    test_typesinprotocols::ArrayCompound::array_table() const {
      return storage_.array_table;
    }

    ::std::array<::test_typesinprotocols::Table, 5>& ::test_typesinprotocols::ArrayCompound::array_table() {
      return storage_.array_table;
    }

    ::test_typesinprotocols::ArrayCompound& ::test_typesinprotocols::ArrayCompound::array_table(::std::array<::test_typesinprotocols::Table, 5> value) {
      storage_.array_table = std::move(value);
      return *this;
    }
      const ::std::array<::test_typesinprotocols::Union, 5> &
    test_typesinprotocols::ArrayCompound::array_union() const {
      return storage_.array_union;
    }

    ::std::array<::test_typesinprotocols::Union, 5>& ::test_typesinprotocols::ArrayCompound::array_union() {
      return storage_.array_union;
    }

    ::test_typesinprotocols::ArrayCompound& ::test_typesinprotocols::ArrayCompound::array_union(::std::array<::test_typesinprotocols::Union, 5> value) {
      storage_.array_union = std::move(value);
      return *this;
    }
      const ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> &
    test_typesinprotocols::ArrayCompound::array_opt_struct() const {
      return storage_.array_opt_struct;
    }

    ::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5>& ::test_typesinprotocols::ArrayCompound::array_opt_struct() {
      return storage_.array_opt_struct;
    }

    ::test_typesinprotocols::ArrayCompound& ::test_typesinprotocols::ArrayCompound::array_opt_struct(::std::array<::fidl::Box<::test_typesinprotocols::Struct>, 5> value) {
      storage_.array_opt_struct = std::move(value);
      return *this;
    }
      const ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> &
    test_typesinprotocols::ArrayCompound::array_opt_union() const {
      return storage_.array_opt_union;
    }

    ::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5>& ::test_typesinprotocols::ArrayCompound::array_opt_union() {
      return storage_.array_opt_union;
    }

    ::test_typesinprotocols::ArrayCompound& ::test_typesinprotocols::ArrayCompound::array_opt_union(::std::array<::fidl::Box<::test_typesinprotocols::Union>, 5> value) {
      storage_.array_opt_union = std::move(value);
      return *this;
    }

  ::test_typesinprotocols::VectorBasic::VectorBasic(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::VectorBasic::VectorBasic(::std::vector<uint8_t> vector_uint8, ::std::vector<uint16_t> vector_uint16, ::std::vector<uint32_t> vector_uint32, ::std::vector<uint64_t> vector_uint64, ::std::vector<int8_t> vector_int8, ::std::vector<int16_t> vector_int16, ::std::vector<int32_t> vector_int32, ::std::vector<int64_t> vector_int64, ::std::vector<float> vector_float32, ::std::vector<double> vector_float64, ::std::vector<::std::string> vector_string, ::std::vector<::std::optional<::std::string>> vector_opt_string) noexcept
    : storage_({
      .vector_uint8 = std::move(vector_uint8), 
      .vector_uint16 = std::move(vector_uint16), 
      .vector_uint32 = std::move(vector_uint32), 
      .vector_uint64 = std::move(vector_uint64), 
      .vector_int8 = std::move(vector_int8), 
      .vector_int16 = std::move(vector_int16), 
      .vector_int32 = std::move(vector_int32), 
      .vector_int64 = std::move(vector_int64), 
      .vector_float32 = std::move(vector_float32), 
      .vector_float64 = std::move(vector_float64), 
      .vector_string = std::move(vector_string), 
      .vector_opt_string = std::move(vector_opt_string)
    }) {}

  ::test_typesinprotocols::VectorBasic::VectorBasic(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : VectorBasic(Storage_{
      .vector_uint8 ={},
      .vector_uint16 ={},
      .vector_uint32 ={},
      .vector_uint64 ={},
      .vector_int8 ={},
      .vector_int16 ={},
      .vector_int32 ={},
      .vector_int64 ={},
      .vector_float32 ={},
      .vector_float64 ={},
      .vector_string ={},
      .vector_opt_string ={},
  }) {}
    ::test_typesinprotocols::VectorBasic::VectorBasic(const ::test_typesinprotocols::VectorBasic& other) noexcept : ::test_typesinprotocols::VectorBasic(other.CloneStorage_()){}

    ::test_typesinprotocols::VectorBasic& test_typesinprotocols::VectorBasic::operator=(const ::test_typesinprotocols::VectorBasic& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::VectorBasic::operator==(const VectorBasic& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorBasic, 192>::Equal(this, &other);
    }

    bool test_typesinprotocols::VectorBasic::operator!=(const VectorBasic& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorBasic, 192>::Equal(this, &other);
    }

    ::test_typesinprotocols::VectorBasic::Storage_ test_typesinprotocols::VectorBasic::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.vector_uint8), 
          ::fidl::internal::NaturalClone(storage_.vector_uint16), 
          ::fidl::internal::NaturalClone(storage_.vector_uint32), 
          ::fidl::internal::NaturalClone(storage_.vector_uint64), 
          ::fidl::internal::NaturalClone(storage_.vector_int8), 
          ::fidl::internal::NaturalClone(storage_.vector_int16), 
          ::fidl::internal::NaturalClone(storage_.vector_int32), 
          ::fidl::internal::NaturalClone(storage_.vector_int64), 
          ::fidl::internal::NaturalClone(storage_.vector_float32), 
          ::fidl::internal::NaturalClone(storage_.vector_float64), 
          ::fidl::internal::NaturalClone(storage_.vector_string), 
          ::fidl::internal::NaturalClone(storage_.vector_opt_string)
      };
    }
      const ::std::vector<uint8_t> &
    test_typesinprotocols::VectorBasic::vector_uint8() const {
      return storage_.vector_uint8;
    }

    ::std::vector<uint8_t>& ::test_typesinprotocols::VectorBasic::vector_uint8() {
      return storage_.vector_uint8;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_uint8(::std::vector<uint8_t> value) {
      storage_.vector_uint8 = std::move(value);
      return *this;
    }
      const ::std::vector<uint16_t> &
    test_typesinprotocols::VectorBasic::vector_uint16() const {
      return storage_.vector_uint16;
    }

    ::std::vector<uint16_t>& ::test_typesinprotocols::VectorBasic::vector_uint16() {
      return storage_.vector_uint16;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_uint16(::std::vector<uint16_t> value) {
      storage_.vector_uint16 = std::move(value);
      return *this;
    }
      const ::std::vector<uint32_t> &
    test_typesinprotocols::VectorBasic::vector_uint32() const {
      return storage_.vector_uint32;
    }

    ::std::vector<uint32_t>& ::test_typesinprotocols::VectorBasic::vector_uint32() {
      return storage_.vector_uint32;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_uint32(::std::vector<uint32_t> value) {
      storage_.vector_uint32 = std::move(value);
      return *this;
    }
      const ::std::vector<uint64_t> &
    test_typesinprotocols::VectorBasic::vector_uint64() const {
      return storage_.vector_uint64;
    }

    ::std::vector<uint64_t>& ::test_typesinprotocols::VectorBasic::vector_uint64() {
      return storage_.vector_uint64;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_uint64(::std::vector<uint64_t> value) {
      storage_.vector_uint64 = std::move(value);
      return *this;
    }
      const ::std::vector<int8_t> &
    test_typesinprotocols::VectorBasic::vector_int8() const {
      return storage_.vector_int8;
    }

    ::std::vector<int8_t>& ::test_typesinprotocols::VectorBasic::vector_int8() {
      return storage_.vector_int8;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_int8(::std::vector<int8_t> value) {
      storage_.vector_int8 = std::move(value);
      return *this;
    }
      const ::std::vector<int16_t> &
    test_typesinprotocols::VectorBasic::vector_int16() const {
      return storage_.vector_int16;
    }

    ::std::vector<int16_t>& ::test_typesinprotocols::VectorBasic::vector_int16() {
      return storage_.vector_int16;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_int16(::std::vector<int16_t> value) {
      storage_.vector_int16 = std::move(value);
      return *this;
    }
      const ::std::vector<int32_t> &
    test_typesinprotocols::VectorBasic::vector_int32() const {
      return storage_.vector_int32;
    }

    ::std::vector<int32_t>& ::test_typesinprotocols::VectorBasic::vector_int32() {
      return storage_.vector_int32;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_int32(::std::vector<int32_t> value) {
      storage_.vector_int32 = std::move(value);
      return *this;
    }
      const ::std::vector<int64_t> &
    test_typesinprotocols::VectorBasic::vector_int64() const {
      return storage_.vector_int64;
    }

    ::std::vector<int64_t>& ::test_typesinprotocols::VectorBasic::vector_int64() {
      return storage_.vector_int64;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_int64(::std::vector<int64_t> value) {
      storage_.vector_int64 = std::move(value);
      return *this;
    }
      const ::std::vector<float> &
    test_typesinprotocols::VectorBasic::vector_float32() const {
      return storage_.vector_float32;
    }

    ::std::vector<float>& ::test_typesinprotocols::VectorBasic::vector_float32() {
      return storage_.vector_float32;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_float32(::std::vector<float> value) {
      storage_.vector_float32 = std::move(value);
      return *this;
    }
      const ::std::vector<double> &
    test_typesinprotocols::VectorBasic::vector_float64() const {
      return storage_.vector_float64;
    }

    ::std::vector<double>& ::test_typesinprotocols::VectorBasic::vector_float64() {
      return storage_.vector_float64;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_float64(::std::vector<double> value) {
      storage_.vector_float64 = std::move(value);
      return *this;
    }
      const ::std::vector<::std::string> &
    test_typesinprotocols::VectorBasic::vector_string() const {
      return storage_.vector_string;
    }

    ::std::vector<::std::string>& ::test_typesinprotocols::VectorBasic::vector_string() {
      return storage_.vector_string;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_string(::std::vector<::std::string> value) {
      storage_.vector_string = std::move(value);
      return *this;
    }
      const ::std::vector<::std::optional<::std::string>> &
    test_typesinprotocols::VectorBasic::vector_opt_string() const {
      return storage_.vector_opt_string;
    }

    ::std::vector<::std::optional<::std::string>>& ::test_typesinprotocols::VectorBasic::vector_opt_string() {
      return storage_.vector_opt_string;
    }

    ::test_typesinprotocols::VectorBasic& ::test_typesinprotocols::VectorBasic::vector_opt_string(::std::vector<::std::optional<::std::string>> value) {
      storage_.vector_opt_string = std::move(value);
      return *this;
    }

  ::test_typesinprotocols::VectorCompound::VectorCompound(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::VectorCompound::VectorCompound(::std::vector<::test_typesinprotocols::Bits> vector_bits, ::std::vector<::test_typesinprotocols::Enum> vector_enum, ::std::vector<::test_typesinprotocols::Struct> vector_struct, ::std::vector<::test_typesinprotocols::Table> vector_table, ::std::vector<::test_typesinprotocols::Union> vector_union, ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> vector_opt_struct, ::std::vector<::fidl::Box<::test_typesinprotocols::Union>> vector_opt_union) noexcept
    : storage_({
      .vector_bits = std::move(vector_bits), 
      .vector_enum = std::move(vector_enum), 
      .vector_struct = std::move(vector_struct), 
      .vector_table = std::move(vector_table), 
      .vector_union = std::move(vector_union), 
      .vector_opt_struct = std::move(vector_opt_struct), 
      .vector_opt_union = std::move(vector_opt_union)
    }) {}

  ::test_typesinprotocols::VectorCompound::VectorCompound(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : VectorCompound(Storage_{
      .vector_bits ={},
      .vector_enum ={},
      .vector_struct ={},
      .vector_table ={},
      .vector_union ={},
      .vector_opt_struct ={},
      .vector_opt_union ={},
  }) {}
    ::test_typesinprotocols::VectorCompound::VectorCompound(const ::test_typesinprotocols::VectorCompound& other) noexcept : ::test_typesinprotocols::VectorCompound(other.CloneStorage_()){}

    ::test_typesinprotocols::VectorCompound& test_typesinprotocols::VectorCompound::operator=(const ::test_typesinprotocols::VectorCompound& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::VectorCompound::operator==(const VectorCompound& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorCompound, 112>::Equal(this, &other);
    }

    bool test_typesinprotocols::VectorCompound::operator!=(const VectorCompound& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorCompound, 112>::Equal(this, &other);
    }

    ::test_typesinprotocols::VectorCompound::Storage_ test_typesinprotocols::VectorCompound::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.vector_bits), 
          ::fidl::internal::NaturalClone(storage_.vector_enum), 
          ::fidl::internal::NaturalClone(storage_.vector_struct), 
          ::fidl::internal::NaturalClone(storage_.vector_table), 
          ::fidl::internal::NaturalClone(storage_.vector_union), 
          ::fidl::internal::NaturalClone(storage_.vector_opt_struct), 
          ::fidl::internal::NaturalClone(storage_.vector_opt_union)
      };
    }
      const ::std::vector<::test_typesinprotocols::Bits> &
    test_typesinprotocols::VectorCompound::vector_bits() const {
      return storage_.vector_bits;
    }

    ::std::vector<::test_typesinprotocols::Bits>& ::test_typesinprotocols::VectorCompound::vector_bits() {
      return storage_.vector_bits;
    }

    ::test_typesinprotocols::VectorCompound& ::test_typesinprotocols::VectorCompound::vector_bits(::std::vector<::test_typesinprotocols::Bits> value) {
      storage_.vector_bits = std::move(value);
      return *this;
    }
      const ::std::vector<::test_typesinprotocols::Enum> &
    test_typesinprotocols::VectorCompound::vector_enum() const {
      return storage_.vector_enum;
    }

    ::std::vector<::test_typesinprotocols::Enum>& ::test_typesinprotocols::VectorCompound::vector_enum() {
      return storage_.vector_enum;
    }

    ::test_typesinprotocols::VectorCompound& ::test_typesinprotocols::VectorCompound::vector_enum(::std::vector<::test_typesinprotocols::Enum> value) {
      storage_.vector_enum = std::move(value);
      return *this;
    }
      const ::std::vector<::test_typesinprotocols::Struct> &
    test_typesinprotocols::VectorCompound::vector_struct() const {
      return storage_.vector_struct;
    }

    ::std::vector<::test_typesinprotocols::Struct>& ::test_typesinprotocols::VectorCompound::vector_struct() {
      return storage_.vector_struct;
    }

    ::test_typesinprotocols::VectorCompound& ::test_typesinprotocols::VectorCompound::vector_struct(::std::vector<::test_typesinprotocols::Struct> value) {
      storage_.vector_struct = std::move(value);
      return *this;
    }
      const ::std::vector<::test_typesinprotocols::Table> &
    test_typesinprotocols::VectorCompound::vector_table() const {
      return storage_.vector_table;
    }

    ::std::vector<::test_typesinprotocols::Table>& ::test_typesinprotocols::VectorCompound::vector_table() {
      return storage_.vector_table;
    }

    ::test_typesinprotocols::VectorCompound& ::test_typesinprotocols::VectorCompound::vector_table(::std::vector<::test_typesinprotocols::Table> value) {
      storage_.vector_table = std::move(value);
      return *this;
    }
      const ::std::vector<::test_typesinprotocols::Union> &
    test_typesinprotocols::VectorCompound::vector_union() const {
      return storage_.vector_union;
    }

    ::std::vector<::test_typesinprotocols::Union>& ::test_typesinprotocols::VectorCompound::vector_union() {
      return storage_.vector_union;
    }

    ::test_typesinprotocols::VectorCompound& ::test_typesinprotocols::VectorCompound::vector_union(::std::vector<::test_typesinprotocols::Union> value) {
      storage_.vector_union = std::move(value);
      return *this;
    }
      const ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> &
    test_typesinprotocols::VectorCompound::vector_opt_struct() const {
      return storage_.vector_opt_struct;
    }

    ::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>& ::test_typesinprotocols::VectorCompound::vector_opt_struct() {
      return storage_.vector_opt_struct;
    }

    ::test_typesinprotocols::VectorCompound& ::test_typesinprotocols::VectorCompound::vector_opt_struct(::std::vector<::fidl::Box<::test_typesinprotocols::Struct>> value) {
      storage_.vector_opt_struct = std::move(value);
      return *this;
    }
      const ::std::vector<::fidl::Box<::test_typesinprotocols::Union>> &
    test_typesinprotocols::VectorCompound::vector_opt_union() const {
      return storage_.vector_opt_union;
    }

    ::std::vector<::fidl::Box<::test_typesinprotocols::Union>>& ::test_typesinprotocols::VectorCompound::vector_opt_union() {
      return storage_.vector_opt_union;
    }

    ::test_typesinprotocols::VectorCompound& ::test_typesinprotocols::VectorCompound::vector_opt_union(::std::vector<::fidl::Box<::test_typesinprotocols::Union>> value) {
      storage_.vector_opt_union = std::move(value);
      return *this;
    }

  ::test_typesinprotocols::VectorOptional::VectorOptional(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::VectorOptional::VectorOptional(::std::optional<::std::vector<uint8_t>> opt_vector_uint8, ::std::optional<::std::vector<::std::string>> opt_vector_string, ::std::optional<::std::vector<::test_typesinprotocols::Struct>> opt_vector_struct, ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> opt_vector_opt_struct) noexcept
    : storage_({
      .opt_vector_uint8 = std::move(opt_vector_uint8), 
      .opt_vector_string = std::move(opt_vector_string), 
      .opt_vector_struct = std::move(opt_vector_struct), 
      .opt_vector_opt_struct = std::move(opt_vector_opt_struct)
    }) {}

  ::test_typesinprotocols::VectorOptional::VectorOptional(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : VectorOptional(Storage_{
      .opt_vector_uint8 ={},
      .opt_vector_string ={},
      .opt_vector_struct ={},
      .opt_vector_opt_struct ={},
  }) {}
    ::test_typesinprotocols::VectorOptional::VectorOptional(const ::test_typesinprotocols::VectorOptional& other) noexcept : ::test_typesinprotocols::VectorOptional(other.CloneStorage_()){}

    ::test_typesinprotocols::VectorOptional& test_typesinprotocols::VectorOptional::operator=(const ::test_typesinprotocols::VectorOptional& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::VectorOptional::operator==(const VectorOptional& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorOptional, 64>::Equal(this, &other);
    }

    bool test_typesinprotocols::VectorOptional::operator!=(const VectorOptional& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::VectorOptional, 64>::Equal(this, &other);
    }

    ::test_typesinprotocols::VectorOptional::Storage_ test_typesinprotocols::VectorOptional::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.opt_vector_uint8), 
          ::fidl::internal::NaturalClone(storage_.opt_vector_string), 
          ::fidl::internal::NaturalClone(storage_.opt_vector_struct), 
          ::fidl::internal::NaturalClone(storage_.opt_vector_opt_struct)
      };
    }
      const ::std::optional<::std::vector<uint8_t>> &
    test_typesinprotocols::VectorOptional::opt_vector_uint8() const {
      return storage_.opt_vector_uint8;
    }

    ::std::optional<::std::vector<uint8_t>>& ::test_typesinprotocols::VectorOptional::opt_vector_uint8() {
      return storage_.opt_vector_uint8;
    }

    ::test_typesinprotocols::VectorOptional& ::test_typesinprotocols::VectorOptional::opt_vector_uint8(::std::optional<::std::vector<uint8_t>> value) {
      storage_.opt_vector_uint8 = std::move(value);
      return *this;
    }
      const ::std::optional<::std::vector<::std::string>> &
    test_typesinprotocols::VectorOptional::opt_vector_string() const {
      return storage_.opt_vector_string;
    }

    ::std::optional<::std::vector<::std::string>>& ::test_typesinprotocols::VectorOptional::opt_vector_string() {
      return storage_.opt_vector_string;
    }

    ::test_typesinprotocols::VectorOptional& ::test_typesinprotocols::VectorOptional::opt_vector_string(::std::optional<::std::vector<::std::string>> value) {
      storage_.opt_vector_string = std::move(value);
      return *this;
    }
      const ::std::optional<::std::vector<::test_typesinprotocols::Struct>> &
    test_typesinprotocols::VectorOptional::opt_vector_struct() const {
      return storage_.opt_vector_struct;
    }

    ::std::optional<::std::vector<::test_typesinprotocols::Struct>>& ::test_typesinprotocols::VectorOptional::opt_vector_struct() {
      return storage_.opt_vector_struct;
    }

    ::test_typesinprotocols::VectorOptional& ::test_typesinprotocols::VectorOptional::opt_vector_struct(::std::optional<::std::vector<::test_typesinprotocols::Struct>> value) {
      storage_.opt_vector_struct = std::move(value);
      return *this;
    }
      const ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> &
    test_typesinprotocols::VectorOptional::opt_vector_opt_struct() const {
      return storage_.opt_vector_opt_struct;
    }

    ::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>>& ::test_typesinprotocols::VectorOptional::opt_vector_opt_struct() {
      return storage_.opt_vector_opt_struct;
    }

    ::test_typesinprotocols::VectorOptional& ::test_typesinprotocols::VectorOptional::opt_vector_opt_struct(::std::optional<::std::vector<::fidl::Box<::test_typesinprotocols::Struct>>> value) {
      storage_.opt_vector_opt_struct = std::move(value);
      return *this;
    }

  ::test_typesinprotocols::ArrayVectorNested::ArrayVectorNested(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::ArrayVectorNested::ArrayVectorNested(::std::array<::std::array<uint8_t, 5>, 5> array_array_uint8, ::std::array<::std::vector<uint8_t>, 5> array_vector_uint8, ::std::vector<::std::array<uint8_t, 5>> vector_array_uint8, ::std::vector<::std::vector<uint8_t>> vector_vector_uint8) noexcept
    : storage_({
      .array_array_uint8 = std::move(array_array_uint8), 
      .array_vector_uint8 = std::move(array_vector_uint8), 
      .vector_array_uint8 = std::move(vector_array_uint8), 
      .vector_vector_uint8 = std::move(vector_vector_uint8)
    }) {}

  ::test_typesinprotocols::ArrayVectorNested::ArrayVectorNested(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ArrayVectorNested(Storage_{
      .array_array_uint8 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::std::array<uint8_t, 5>, 5>>::Make(),
      .array_vector_uint8 =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::std::vector<uint8_t>, 5>>::Make(),
      .vector_array_uint8 ={},
      .vector_vector_uint8 ={},
  }) {}
    ::test_typesinprotocols::ArrayVectorNested::ArrayVectorNested(const ::test_typesinprotocols::ArrayVectorNested& other) noexcept : ::test_typesinprotocols::ArrayVectorNested(other.CloneStorage_()){}

    ::test_typesinprotocols::ArrayVectorNested& test_typesinprotocols::ArrayVectorNested::operator=(const ::test_typesinprotocols::ArrayVectorNested& other) noexcept {
      storage_ = other.CloneStorage_();
      return *this;
    }

    bool test_typesinprotocols::ArrayVectorNested::operator==(const ArrayVectorNested& other) const noexcept {
      return ::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayVectorNested, 144>::Equal(this, &other);
    }

    bool test_typesinprotocols::ArrayVectorNested::operator!=(const ArrayVectorNested& other) const noexcept {
      return !::fidl::internal::NaturalStructCodingTraits<::test_typesinprotocols::ArrayVectorNested, 144>::Equal(this, &other);
    }

    ::test_typesinprotocols::ArrayVectorNested::Storage_ test_typesinprotocols::ArrayVectorNested::CloneStorage_() const {
      return Storage_{
          ::fidl::internal::NaturalClone(storage_.array_array_uint8), 
          ::fidl::internal::NaturalClone(storage_.array_vector_uint8), 
          ::fidl::internal::NaturalClone(storage_.vector_array_uint8), 
          ::fidl::internal::NaturalClone(storage_.vector_vector_uint8)
      };
    }
      const ::std::array<::std::array<uint8_t, 5>, 5> &
    test_typesinprotocols::ArrayVectorNested::array_array_uint8() const {
      return storage_.array_array_uint8;
    }

    ::std::array<::std::array<uint8_t, 5>, 5>& ::test_typesinprotocols::ArrayVectorNested::array_array_uint8() {
      return storage_.array_array_uint8;
    }

    ::test_typesinprotocols::ArrayVectorNested& ::test_typesinprotocols::ArrayVectorNested::array_array_uint8(::std::array<::std::array<uint8_t, 5>, 5> value) {
      storage_.array_array_uint8 = std::move(value);
      return *this;
    }
      const ::std::array<::std::vector<uint8_t>, 5> &
    test_typesinprotocols::ArrayVectorNested::array_vector_uint8() const {
      return storage_.array_vector_uint8;
    }

    ::std::array<::std::vector<uint8_t>, 5>& ::test_typesinprotocols::ArrayVectorNested::array_vector_uint8() {
      return storage_.array_vector_uint8;
    }

    ::test_typesinprotocols::ArrayVectorNested& ::test_typesinprotocols::ArrayVectorNested::array_vector_uint8(::std::array<::std::vector<uint8_t>, 5> value) {
      storage_.array_vector_uint8 = std::move(value);
      return *this;
    }
      const ::std::vector<::std::array<uint8_t, 5>> &
    test_typesinprotocols::ArrayVectorNested::vector_array_uint8() const {
      return storage_.vector_array_uint8;
    }

    ::std::vector<::std::array<uint8_t, 5>>& ::test_typesinprotocols::ArrayVectorNested::vector_array_uint8() {
      return storage_.vector_array_uint8;
    }

    ::test_typesinprotocols::ArrayVectorNested& ::test_typesinprotocols::ArrayVectorNested::vector_array_uint8(::std::vector<::std::array<uint8_t, 5>> value) {
      storage_.vector_array_uint8 = std::move(value);
      return *this;
    }
      const ::std::vector<::std::vector<uint8_t>> &
    test_typesinprotocols::ArrayVectorNested::vector_vector_uint8() const {
      return storage_.vector_vector_uint8;
    }

    ::std::vector<::std::vector<uint8_t>>& ::test_typesinprotocols::ArrayVectorNested::vector_vector_uint8() {
      return storage_.vector_vector_uint8;
    }

    ::test_typesinprotocols::ArrayVectorNested& ::test_typesinprotocols::ArrayVectorNested::vector_vector_uint8(::std::vector<::std::vector<uint8_t>> value) {
      storage_.vector_vector_uint8 = std::move(value);
      return *this;
    }

#ifdef __Fuchsia__

  ::test_typesinprotocols::Resource::Resource(Storage_ storage) noexcept : storage_(std::move(storage)) {}
    ::test_typesinprotocols::Resource::Resource(::zx::handle handle, ::zx::vmo vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol> client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol> server_end, ::test_typesinprotocols::ResourceStruct struct_, ::test_typesinprotocols::ResourceTable table, ::test_typesinprotocols::ResourceUnion union_, ::zx::handle opt_handle, ::zx::vmo opt_vmo, ::fidl::ClientEnd<::test_typesinprotocols::Protocol> opt_client_end, ::fidl::ServerEnd<::test_typesinprotocols::Protocol> opt_server_end, ::fidl::Box<::test_typesinprotocols::ResourceStruct> opt_struct, ::fidl::Box<::test_typesinprotocols::ResourceUnion> opt_union, ::std::array<::zx::handle, 5> array_handle, ::std::array<::zx::vmo, 5> array_vmo, ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> array_client_end, ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> array_server_end, ::std::array<::test_typesinprotocols::ResourceStruct, 5> array_struct, ::std::array<::test_typesinprotocols::ResourceTable, 5> array_table, ::std::array<::test_typesinprotocols::ResourceUnion, 5> array_union, ::std::vector<::zx::handle> vector_handle, ::std::vector<::zx::vmo> vector_vmo, ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> vector_client_end, ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> vector_server_end, ::std::vector<::test_typesinprotocols::ResourceStruct> vector_struct, ::std::vector<::test_typesinprotocols::ResourceTable> vector_table, ::std::vector<::test_typesinprotocols::ResourceUnion> vector_union) noexcept
    : storage_({
      .handle = std::move(handle), 
      .vmo = std::move(vmo), 
      .client_end = std::move(client_end), 
      .server_end = std::move(server_end), 
      .struct_ = std::move(struct_), 
      .table = std::move(table), 
      .union_ = std::move(union_), 
      .opt_handle = std::move(opt_handle), 
      .opt_vmo = std::move(opt_vmo), 
      .opt_client_end = std::move(opt_client_end), 
      .opt_server_end = std::move(opt_server_end), 
      .opt_struct = std::move(opt_struct), 
      .opt_union = std::move(opt_union), 
      .array_handle = std::move(array_handle), 
      .array_vmo = std::move(array_vmo), 
      .array_client_end = std::move(array_client_end), 
      .array_server_end = std::move(array_server_end), 
      .array_struct = std::move(array_struct), 
      .array_table = std::move(array_table), 
      .array_union = std::move(array_union), 
      .vector_handle = std::move(vector_handle), 
      .vector_vmo = std::move(vector_vmo), 
      .vector_client_end = std::move(vector_client_end), 
      .vector_server_end = std::move(vector_server_end), 
      .vector_struct = std::move(vector_struct), 
      .vector_table = std::move(vector_table), 
      .vector_union = std::move(vector_union)
    }) {}

  ::test_typesinprotocols::Resource::Resource(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Resource(Storage_{
      .handle ={},
      .vmo ={},
      .client_end ={},
      .server_end ={},
      .struct_ =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .table =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .union_ =::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{},
      .opt_handle ={},
      .opt_vmo ={},
      .opt_client_end ={},
      .opt_server_end ={},
      .opt_struct ={},
      .opt_union ={},
      .array_handle =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::zx::handle, 5>>::Make(),
      .array_vmo =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::zx::vmo, 5>>::Make(),
      .array_client_end =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>>::Make(),
      .array_server_end =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>>::Make(),
      .array_struct =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::ResourceStruct, 5>>::Make(),
      .array_table =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::ResourceTable, 5>>::Make(),
      .array_union =::fidl::internal::DefaultConstructPossiblyInvalidObject<::std::array<::test_typesinprotocols::ResourceUnion, 5>>::Make(),
      .vector_handle ={},
      .vector_vmo ={},
      .vector_client_end ={},
      .vector_server_end ={},
      .vector_struct ={},
      .vector_table ={},
      .vector_union ={},
  }) {}
      const ::zx::handle &
    test_typesinprotocols::Resource::handle() const {
      return storage_.handle;
    }

    ::zx::handle& ::test_typesinprotocols::Resource::handle() {
      return storage_.handle;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::handle(::zx::handle value) {
      storage_.handle = std::move(value);
      return *this;
    }
      const ::zx::vmo &
    test_typesinprotocols::Resource::vmo() const {
      return storage_.vmo;
    }

    ::zx::vmo& ::test_typesinprotocols::Resource::vmo() {
      return storage_.vmo;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::vmo(::zx::vmo value) {
      storage_.vmo = std::move(value);
      return *this;
    }
      const ::fidl::ClientEnd<::test_typesinprotocols::Protocol> &
    test_typesinprotocols::Resource::client_end() const {
      return storage_.client_end;
    }

    ::fidl::ClientEnd<::test_typesinprotocols::Protocol>& ::test_typesinprotocols::Resource::client_end() {
      return storage_.client_end;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::client_end(::fidl::ClientEnd<::test_typesinprotocols::Protocol> value) {
      storage_.client_end = std::move(value);
      return *this;
    }
      const ::fidl::ServerEnd<::test_typesinprotocols::Protocol> &
    test_typesinprotocols::Resource::server_end() const {
      return storage_.server_end;
    }

    ::fidl::ServerEnd<::test_typesinprotocols::Protocol>& ::test_typesinprotocols::Resource::server_end() {
      return storage_.server_end;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::server_end(::fidl::ServerEnd<::test_typesinprotocols::Protocol> value) {
      storage_.server_end = std::move(value);
      return *this;
    }
      const ::test_typesinprotocols::ResourceStruct &
    test_typesinprotocols::Resource::struct_() const {
      return storage_.struct_;
    }

    ::test_typesinprotocols::ResourceStruct& ::test_typesinprotocols::Resource::struct_() {
      return storage_.struct_;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::struct_(::test_typesinprotocols::ResourceStruct value) {
      storage_.struct_ = std::move(value);
      return *this;
    }
      const ::test_typesinprotocols::ResourceTable &
    test_typesinprotocols::Resource::table() const {
      return storage_.table;
    }

    ::test_typesinprotocols::ResourceTable& ::test_typesinprotocols::Resource::table() {
      return storage_.table;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::table(::test_typesinprotocols::ResourceTable value) {
      storage_.table = std::move(value);
      return *this;
    }
      const ::test_typesinprotocols::ResourceUnion &
    test_typesinprotocols::Resource::union_() const {
      return storage_.union_;
    }

    ::test_typesinprotocols::ResourceUnion& ::test_typesinprotocols::Resource::union_() {
      return storage_.union_;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::union_(::test_typesinprotocols::ResourceUnion value) {
      storage_.union_ = std::move(value);
      return *this;
    }
      const ::zx::handle &
    test_typesinprotocols::Resource::opt_handle() const {
      return storage_.opt_handle;
    }

    ::zx::handle& ::test_typesinprotocols::Resource::opt_handle() {
      return storage_.opt_handle;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::opt_handle(::zx::handle value) {
      storage_.opt_handle = std::move(value);
      return *this;
    }
      const ::zx::vmo &
    test_typesinprotocols::Resource::opt_vmo() const {
      return storage_.opt_vmo;
    }

    ::zx::vmo& ::test_typesinprotocols::Resource::opt_vmo() {
      return storage_.opt_vmo;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::opt_vmo(::zx::vmo value) {
      storage_.opt_vmo = std::move(value);
      return *this;
    }
      const ::fidl::ClientEnd<::test_typesinprotocols::Protocol> &
    test_typesinprotocols::Resource::opt_client_end() const {
      return storage_.opt_client_end;
    }

    ::fidl::ClientEnd<::test_typesinprotocols::Protocol>& ::test_typesinprotocols::Resource::opt_client_end() {
      return storage_.opt_client_end;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::opt_client_end(::fidl::ClientEnd<::test_typesinprotocols::Protocol> value) {
      storage_.opt_client_end = std::move(value);
      return *this;
    }
      const ::fidl::ServerEnd<::test_typesinprotocols::Protocol> &
    test_typesinprotocols::Resource::opt_server_end() const {
      return storage_.opt_server_end;
    }

    ::fidl::ServerEnd<::test_typesinprotocols::Protocol>& ::test_typesinprotocols::Resource::opt_server_end() {
      return storage_.opt_server_end;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::opt_server_end(::fidl::ServerEnd<::test_typesinprotocols::Protocol> value) {
      storage_.opt_server_end = std::move(value);
      return *this;
    }
      const ::fidl::Box<::test_typesinprotocols::ResourceStruct> &
    test_typesinprotocols::Resource::opt_struct() const {
      return storage_.opt_struct;
    }

    ::fidl::Box<::test_typesinprotocols::ResourceStruct>& ::test_typesinprotocols::Resource::opt_struct() {
      return storage_.opt_struct;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::opt_struct(::fidl::Box<::test_typesinprotocols::ResourceStruct> value) {
      storage_.opt_struct = std::move(value);
      return *this;
    }
      const ::fidl::Box<::test_typesinprotocols::ResourceUnion> &
    test_typesinprotocols::Resource::opt_union() const {
      return storage_.opt_union;
    }

    ::fidl::Box<::test_typesinprotocols::ResourceUnion>& ::test_typesinprotocols::Resource::opt_union() {
      return storage_.opt_union;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::opt_union(::fidl::Box<::test_typesinprotocols::ResourceUnion> value) {
      storage_.opt_union = std::move(value);
      return *this;
    }
      const ::std::array<::zx::handle, 5> &
    test_typesinprotocols::Resource::array_handle() const {
      return storage_.array_handle;
    }

    ::std::array<::zx::handle, 5>& ::test_typesinprotocols::Resource::array_handle() {
      return storage_.array_handle;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::array_handle(::std::array<::zx::handle, 5> value) {
      storage_.array_handle = std::move(value);
      return *this;
    }
      const ::std::array<::zx::vmo, 5> &
    test_typesinprotocols::Resource::array_vmo() const {
      return storage_.array_vmo;
    }

    ::std::array<::zx::vmo, 5>& ::test_typesinprotocols::Resource::array_vmo() {
      return storage_.array_vmo;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::array_vmo(::std::array<::zx::vmo, 5> value) {
      storage_.array_vmo = std::move(value);
      return *this;
    }
      const ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> &
    test_typesinprotocols::Resource::array_client_end() const {
      return storage_.array_client_end;
    }

    ::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5>& ::test_typesinprotocols::Resource::array_client_end() {
      return storage_.array_client_end;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::array_client_end(::std::array<::fidl::ClientEnd<::test_typesinprotocols::Protocol>, 5> value) {
      storage_.array_client_end = std::move(value);
      return *this;
    }
      const ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> &
    test_typesinprotocols::Resource::array_server_end() const {
      return storage_.array_server_end;
    }

    ::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5>& ::test_typesinprotocols::Resource::array_server_end() {
      return storage_.array_server_end;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::array_server_end(::std::array<::fidl::ServerEnd<::test_typesinprotocols::Protocol>, 5> value) {
      storage_.array_server_end = std::move(value);
      return *this;
    }
      const ::std::array<::test_typesinprotocols::ResourceStruct, 5> &
    test_typesinprotocols::Resource::array_struct() const {
      return storage_.array_struct;
    }

    ::std::array<::test_typesinprotocols::ResourceStruct, 5>& ::test_typesinprotocols::Resource::array_struct() {
      return storage_.array_struct;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::array_struct(::std::array<::test_typesinprotocols::ResourceStruct, 5> value) {
      storage_.array_struct = std::move(value);
      return *this;
    }
      const ::std::array<::test_typesinprotocols::ResourceTable, 5> &
    test_typesinprotocols::Resource::array_table() const {
      return storage_.array_table;
    }

    ::std::array<::test_typesinprotocols::ResourceTable, 5>& ::test_typesinprotocols::Resource::array_table() {
      return storage_.array_table;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::array_table(::std::array<::test_typesinprotocols::ResourceTable, 5> value) {
      storage_.array_table = std::move(value);
      return *this;
    }
      const ::std::array<::test_typesinprotocols::ResourceUnion, 5> &
    test_typesinprotocols::Resource::array_union() const {
      return storage_.array_union;
    }

    ::std::array<::test_typesinprotocols::ResourceUnion, 5>& ::test_typesinprotocols::Resource::array_union() {
      return storage_.array_union;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::array_union(::std::array<::test_typesinprotocols::ResourceUnion, 5> value) {
      storage_.array_union = std::move(value);
      return *this;
    }
      const ::std::vector<::zx::handle> &
    test_typesinprotocols::Resource::vector_handle() const {
      return storage_.vector_handle;
    }

    ::std::vector<::zx::handle>& ::test_typesinprotocols::Resource::vector_handle() {
      return storage_.vector_handle;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::vector_handle(::std::vector<::zx::handle> value) {
      storage_.vector_handle = std::move(value);
      return *this;
    }
      const ::std::vector<::zx::vmo> &
    test_typesinprotocols::Resource::vector_vmo() const {
      return storage_.vector_vmo;
    }

    ::std::vector<::zx::vmo>& ::test_typesinprotocols::Resource::vector_vmo() {
      return storage_.vector_vmo;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::vector_vmo(::std::vector<::zx::vmo> value) {
      storage_.vector_vmo = std::move(value);
      return *this;
    }
      const ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> &
    test_typesinprotocols::Resource::vector_client_end() const {
      return storage_.vector_client_end;
    }

    ::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>>& ::test_typesinprotocols::Resource::vector_client_end() {
      return storage_.vector_client_end;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::vector_client_end(::std::vector<::fidl::ClientEnd<::test_typesinprotocols::Protocol>> value) {
      storage_.vector_client_end = std::move(value);
      return *this;
    }
      const ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> &
    test_typesinprotocols::Resource::vector_server_end() const {
      return storage_.vector_server_end;
    }

    ::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>>& ::test_typesinprotocols::Resource::vector_server_end() {
      return storage_.vector_server_end;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::vector_server_end(::std::vector<::fidl::ServerEnd<::test_typesinprotocols::Protocol>> value) {
      storage_.vector_server_end = std::move(value);
      return *this;
    }
      const ::std::vector<::test_typesinprotocols::ResourceStruct> &
    test_typesinprotocols::Resource::vector_struct() const {
      return storage_.vector_struct;
    }

    ::std::vector<::test_typesinprotocols::ResourceStruct>& ::test_typesinprotocols::Resource::vector_struct() {
      return storage_.vector_struct;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::vector_struct(::std::vector<::test_typesinprotocols::ResourceStruct> value) {
      storage_.vector_struct = std::move(value);
      return *this;
    }
      const ::std::vector<::test_typesinprotocols::ResourceTable> &
    test_typesinprotocols::Resource::vector_table() const {
      return storage_.vector_table;
    }

    ::std::vector<::test_typesinprotocols::ResourceTable>& ::test_typesinprotocols::Resource::vector_table() {
      return storage_.vector_table;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::vector_table(::std::vector<::test_typesinprotocols::ResourceTable> value) {
      storage_.vector_table = std::move(value);
      return *this;
    }
      const ::std::vector<::test_typesinprotocols::ResourceUnion> &
    test_typesinprotocols::Resource::vector_union() const {
      return storage_.vector_union;
    }

    ::std::vector<::test_typesinprotocols::ResourceUnion>& ::test_typesinprotocols::Resource::vector_union() {
      return storage_.vector_union;
    }

    ::test_typesinprotocols::Resource& ::test_typesinprotocols::Resource::vector_union(::std::vector<::test_typesinprotocols::ResourceUnion> value) {
      storage_.vector_union = std::move(value);
      return *this;
    }

#endif  // __Fuchsia__

::test_typesinprotocols::Table::Table(::test_typesinprotocols::Table::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_typesinprotocols::Table::Table(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : Table(Storage_{}) {}

  ::test_typesinprotocols::Table::Table(const ::test_typesinprotocols::Table& other) noexcept : Table(other.CloneStorage_()){}

  ::test_typesinprotocols::Table& ::test_typesinprotocols::Table::operator=(const ::test_typesinprotocols::Table& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool test_typesinprotocols::Table::operator==(const Table& other) const noexcept {
    return ::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::Table>::Equal(this, &other);
  }
  bool test_typesinprotocols::Table::operator!=(const Table& other) const noexcept {
    return !::fidl::internal::NaturalTableCodingTraits<::test_typesinprotocols::Table>::Equal(this, &other);
  }

  ::test_typesinprotocols::Table::Storage_ test_typesinprotocols::Table::CloneStorage_() const {
    return Storage_{
    };
  }

bool test_typesinprotocols::Table::IsEmpty() const {
    return true;
}

#ifdef __Fuchsia__

::test_typesinprotocols::ResourceTable::ResourceTable(::test_typesinprotocols::ResourceTable::Storage_ storage) noexcept : storage_(std::move(storage)) {}

::test_typesinprotocols::ResourceTable::ResourceTable(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag) : ResourceTable(Storage_{}) {}

bool test_typesinprotocols::ResourceTable::IsEmpty() const {
    return true;
}

#endif  // __Fuchsia__

::test_typesinprotocols::Union::Union(Union&& other) noexcept : Union(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::Union& ::test_typesinprotocols::Union::operator=(Union&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::Union::Union(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::Union::Union(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::Union::Tag test_typesinprotocols::Union::Which() const {
  return Union::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::Union::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::Union::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::Union::Tag::kB: return 1;
    default: {
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::Union::Tag> test_typesinprotocols::Union::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::Union::Tag::kB;
      default: return ::test_typesinprotocols::Union::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

  ::test_typesinprotocols::Union::Union(const Union& other) noexcept : Union(other.CloneStorage_()){}

  ::test_typesinprotocols::Union& test_typesinprotocols::Union::operator=(const Union& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::Union::operator==(const Union& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::Union::operator!=(const Union& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::Union::Storage_> test_typesinprotocols::Union::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  bool test_typesinprotocols::Union::IsUnknown() const {
    return Which() == ::test_typesinprotocols::Union::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
  ::test_typesinprotocols::Union test_typesinprotocols::Union::WithB(bool val) {
    return Union(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::Union::Storage_> test_typesinprotocols::Union::b() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::Union::Storage_> test_typesinprotocols::Union::b() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::Union& test_typesinprotocols::Union::b(bool value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }

#ifdef __Fuchsia__

::test_typesinprotocols::ResourceUnion::ResourceUnion(ResourceUnion&& other) noexcept : ResourceUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ResourceUnion& ::test_typesinprotocols::ResourceUnion::operator=(ResourceUnion&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ResourceUnion::ResourceUnion(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ResourceUnion::ResourceUnion(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ResourceUnion::Tag test_typesinprotocols::ResourceUnion::Which() const {
  return ResourceUnion::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ResourceUnion::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ResourceUnion::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ResourceUnion::Tag::kB: return 1;
    default: {
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ResourceUnion::Tag> test_typesinprotocols::ResourceUnion::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ResourceUnion::Tag::kB;
      default: return ::test_typesinprotocols::ResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
}

  bool test_typesinprotocols::ResourceUnion::IsUnknown() const {
    return Which() == ::test_typesinprotocols::ResourceUnion::Tag::_do_not_handle_this__write_a_default_case_instead;
  }
  ::test_typesinprotocols::ResourceUnion test_typesinprotocols::ResourceUnion::WithB(bool val) {
    return ResourceUnion(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ResourceUnion::Storage_> test_typesinprotocols::ResourceUnion::b() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ResourceUnion::Storage_> test_typesinprotocols::ResourceUnion::b() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ResourceUnion& test_typesinprotocols::ResourceUnion::b(bool value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }

#endif  // __Fuchsia__

::test_typesinprotocols::ProtocolErrorBasicResult::ProtocolErrorBasicResult(ProtocolErrorBasicResult&& other) noexcept : ProtocolErrorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorBasicResult& ::test_typesinprotocols::ProtocolErrorBasicResult::operator=(ProtocolErrorBasicResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorBasicResult::ProtocolErrorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorBasicResult::ProtocolErrorBasicResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorBasicResult::Tag test_typesinprotocols::ProtocolErrorBasicResult::Which() const {
  return ProtocolErrorBasicResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorBasicResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorBasicResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorBasicResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorBasicResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorBasicResult::Tag> test_typesinprotocols::ProtocolErrorBasicResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorBasicResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorBasicResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorBasicResult::ProtocolErrorBasicResult(const ProtocolErrorBasicResult& other) noexcept : ProtocolErrorBasicResult(other.CloneStorage_()){}

  ::test_typesinprotocols::ProtocolErrorBasicResult& test_typesinprotocols::ProtocolErrorBasicResult::operator=(const ProtocolErrorBasicResult& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::ProtocolErrorBasicResult::operator==(const ProtocolErrorBasicResult& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::ProtocolErrorBasicResult::operator!=(const ProtocolErrorBasicResult& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::ProtocolErrorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorBasicResult::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
        case 2:
          return std::make_shared<Storage_>(
            std::in_place_index<2>,
            ::fidl::internal::NaturalClone(std::get<2>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  ::test_typesinprotocols::ProtocolErrorBasicResult test_typesinprotocols::ProtocolErrorBasicResult::WithResponse(::test_typesinprotocols::Basic val) {
    return ProtocolErrorBasicResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorBasicResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorBasicResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorBasicResult& test_typesinprotocols::ProtocolErrorBasicResult::response(::test_typesinprotocols::Basic value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorBasicResult test_typesinprotocols::ProtocolErrorBasicResult::WithErr(uint32_t val) {
    return ProtocolErrorBasicResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorBasicResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorBasicResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorBasicResult& test_typesinprotocols::ProtocolErrorBasicResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

::test_typesinprotocols::ProtocolErrorCompoundResult::ProtocolErrorCompoundResult(ProtocolErrorCompoundResult&& other) noexcept : ProtocolErrorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorCompoundResult& ::test_typesinprotocols::ProtocolErrorCompoundResult::operator=(ProtocolErrorCompoundResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorCompoundResult::ProtocolErrorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorCompoundResult::ProtocolErrorCompoundResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorCompoundResult::Tag test_typesinprotocols::ProtocolErrorCompoundResult::Which() const {
  return ProtocolErrorCompoundResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorCompoundResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorCompoundResult::Tag> test_typesinprotocols::ProtocolErrorCompoundResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorCompoundResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorCompoundResult::ProtocolErrorCompoundResult(const ProtocolErrorCompoundResult& other) noexcept : ProtocolErrorCompoundResult(other.CloneStorage_()){}

  ::test_typesinprotocols::ProtocolErrorCompoundResult& test_typesinprotocols::ProtocolErrorCompoundResult::operator=(const ProtocolErrorCompoundResult& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::ProtocolErrorCompoundResult::operator==(const ProtocolErrorCompoundResult& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::ProtocolErrorCompoundResult::operator!=(const ProtocolErrorCompoundResult& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::ProtocolErrorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorCompoundResult::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
        case 2:
          return std::make_shared<Storage_>(
            std::in_place_index<2>,
            ::fidl::internal::NaturalClone(std::get<2>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  ::test_typesinprotocols::ProtocolErrorCompoundResult test_typesinprotocols::ProtocolErrorCompoundResult::WithResponse(::test_typesinprotocols::Compound val) {
    return ProtocolErrorCompoundResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorCompoundResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorCompoundResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorCompoundResult& test_typesinprotocols::ProtocolErrorCompoundResult::response(::test_typesinprotocols::Compound value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorCompoundResult test_typesinprotocols::ProtocolErrorCompoundResult::WithErr(uint32_t val) {
    return ProtocolErrorCompoundResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorCompoundResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorCompoundResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorCompoundResult& test_typesinprotocols::ProtocolErrorCompoundResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

::test_typesinprotocols::ProtocolErrorArrayBasicResult::ProtocolErrorArrayBasicResult(ProtocolErrorArrayBasicResult&& other) noexcept : ProtocolErrorArrayBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorArrayBasicResult& ::test_typesinprotocols::ProtocolErrorArrayBasicResult::operator=(ProtocolErrorArrayBasicResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorArrayBasicResult::ProtocolErrorArrayBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorArrayBasicResult::ProtocolErrorArrayBasicResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag test_typesinprotocols::ProtocolErrorArrayBasicResult::Which() const {
  return ProtocolErrorArrayBasicResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorArrayBasicResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag> test_typesinprotocols::ProtocolErrorArrayBasicResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorArrayBasicResult::ProtocolErrorArrayBasicResult(const ProtocolErrorArrayBasicResult& other) noexcept : ProtocolErrorArrayBasicResult(other.CloneStorage_()){}

  ::test_typesinprotocols::ProtocolErrorArrayBasicResult& test_typesinprotocols::ProtocolErrorArrayBasicResult::operator=(const ProtocolErrorArrayBasicResult& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::ProtocolErrorArrayBasicResult::operator==(const ProtocolErrorArrayBasicResult& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::ProtocolErrorArrayBasicResult::operator!=(const ProtocolErrorArrayBasicResult& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::ProtocolErrorArrayBasicResult::Storage_> test_typesinprotocols::ProtocolErrorArrayBasicResult::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
        case 2:
          return std::make_shared<Storage_>(
            std::in_place_index<2>,
            ::fidl::internal::NaturalClone(std::get<2>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  ::test_typesinprotocols::ProtocolErrorArrayBasicResult test_typesinprotocols::ProtocolErrorArrayBasicResult::WithResponse(::test_typesinprotocols::ArrayBasic val) {
    return ProtocolErrorArrayBasicResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Storage_> test_typesinprotocols::ProtocolErrorArrayBasicResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Storage_> test_typesinprotocols::ProtocolErrorArrayBasicResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorArrayBasicResult& test_typesinprotocols::ProtocolErrorArrayBasicResult::response(::test_typesinprotocols::ArrayBasic value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorArrayBasicResult test_typesinprotocols::ProtocolErrorArrayBasicResult::WithErr(uint32_t val) {
    return ProtocolErrorArrayBasicResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Storage_> test_typesinprotocols::ProtocolErrorArrayBasicResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorArrayBasicResult::Storage_> test_typesinprotocols::ProtocolErrorArrayBasicResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorArrayBasicResult& test_typesinprotocols::ProtocolErrorArrayBasicResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

::test_typesinprotocols::ProtocolErrorArrayCompoundResult::ProtocolErrorArrayCompoundResult(ProtocolErrorArrayCompoundResult&& other) noexcept : ProtocolErrorArrayCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorArrayCompoundResult& ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::operator=(ProtocolErrorArrayCompoundResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorArrayCompoundResult::ProtocolErrorArrayCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorArrayCompoundResult::ProtocolErrorArrayCompoundResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag test_typesinprotocols::ProtocolErrorArrayCompoundResult::Which() const {
  return ProtocolErrorArrayCompoundResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorArrayCompoundResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag> test_typesinprotocols::ProtocolErrorArrayCompoundResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::ProtocolErrorArrayCompoundResult(const ProtocolErrorArrayCompoundResult& other) noexcept : ProtocolErrorArrayCompoundResult(other.CloneStorage_()){}

  ::test_typesinprotocols::ProtocolErrorArrayCompoundResult& test_typesinprotocols::ProtocolErrorArrayCompoundResult::operator=(const ProtocolErrorArrayCompoundResult& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::ProtocolErrorArrayCompoundResult::operator==(const ProtocolErrorArrayCompoundResult& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::ProtocolErrorArrayCompoundResult::operator!=(const ProtocolErrorArrayCompoundResult& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorArrayCompoundResult::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
        case 2:
          return std::make_shared<Storage_>(
            std::in_place_index<2>,
            ::fidl::internal::NaturalClone(std::get<2>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  ::test_typesinprotocols::ProtocolErrorArrayCompoundResult test_typesinprotocols::ProtocolErrorArrayCompoundResult::WithResponse(::test_typesinprotocols::ArrayCompound val) {
    return ProtocolErrorArrayCompoundResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorArrayCompoundResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorArrayCompoundResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorArrayCompoundResult& test_typesinprotocols::ProtocolErrorArrayCompoundResult::response(::test_typesinprotocols::ArrayCompound value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorArrayCompoundResult test_typesinprotocols::ProtocolErrorArrayCompoundResult::WithErr(uint32_t val) {
    return ProtocolErrorArrayCompoundResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorArrayCompoundResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorArrayCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorArrayCompoundResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorArrayCompoundResult& test_typesinprotocols::ProtocolErrorArrayCompoundResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

::test_typesinprotocols::ProtocolErrorVectorBasicResult::ProtocolErrorVectorBasicResult(ProtocolErrorVectorBasicResult&& other) noexcept : ProtocolErrorVectorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorVectorBasicResult& ::test_typesinprotocols::ProtocolErrorVectorBasicResult::operator=(ProtocolErrorVectorBasicResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorVectorBasicResult::ProtocolErrorVectorBasicResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorVectorBasicResult::ProtocolErrorVectorBasicResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag test_typesinprotocols::ProtocolErrorVectorBasicResult::Which() const {
  return ProtocolErrorVectorBasicResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorVectorBasicResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag> test_typesinprotocols::ProtocolErrorVectorBasicResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorVectorBasicResult::ProtocolErrorVectorBasicResult(const ProtocolErrorVectorBasicResult& other) noexcept : ProtocolErrorVectorBasicResult(other.CloneStorage_()){}

  ::test_typesinprotocols::ProtocolErrorVectorBasicResult& test_typesinprotocols::ProtocolErrorVectorBasicResult::operator=(const ProtocolErrorVectorBasicResult& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::ProtocolErrorVectorBasicResult::operator==(const ProtocolErrorVectorBasicResult& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::ProtocolErrorVectorBasicResult::operator!=(const ProtocolErrorVectorBasicResult& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::ProtocolErrorVectorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorVectorBasicResult::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
        case 2:
          return std::make_shared<Storage_>(
            std::in_place_index<2>,
            ::fidl::internal::NaturalClone(std::get<2>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  ::test_typesinprotocols::ProtocolErrorVectorBasicResult test_typesinprotocols::ProtocolErrorVectorBasicResult::WithResponse(::test_typesinprotocols::VectorBasic val) {
    return ProtocolErrorVectorBasicResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorVectorBasicResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorVectorBasicResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorVectorBasicResult& test_typesinprotocols::ProtocolErrorVectorBasicResult::response(::test_typesinprotocols::VectorBasic value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorVectorBasicResult test_typesinprotocols::ProtocolErrorVectorBasicResult::WithErr(uint32_t val) {
    return ProtocolErrorVectorBasicResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorVectorBasicResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorVectorBasicResult::Storage_> test_typesinprotocols::ProtocolErrorVectorBasicResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorVectorBasicResult& test_typesinprotocols::ProtocolErrorVectorBasicResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

::test_typesinprotocols::ProtocolErrorVectorCompoundResult::ProtocolErrorVectorCompoundResult(ProtocolErrorVectorCompoundResult&& other) noexcept : ProtocolErrorVectorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorVectorCompoundResult& ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::operator=(ProtocolErrorVectorCompoundResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorVectorCompoundResult::ProtocolErrorVectorCompoundResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorVectorCompoundResult::ProtocolErrorVectorCompoundResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag test_typesinprotocols::ProtocolErrorVectorCompoundResult::Which() const {
  return ProtocolErrorVectorCompoundResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorVectorCompoundResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag> test_typesinprotocols::ProtocolErrorVectorCompoundResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::ProtocolErrorVectorCompoundResult(const ProtocolErrorVectorCompoundResult& other) noexcept : ProtocolErrorVectorCompoundResult(other.CloneStorage_()){}

  ::test_typesinprotocols::ProtocolErrorVectorCompoundResult& test_typesinprotocols::ProtocolErrorVectorCompoundResult::operator=(const ProtocolErrorVectorCompoundResult& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::ProtocolErrorVectorCompoundResult::operator==(const ProtocolErrorVectorCompoundResult& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::ProtocolErrorVectorCompoundResult::operator!=(const ProtocolErrorVectorCompoundResult& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorVectorCompoundResult::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
        case 2:
          return std::make_shared<Storage_>(
            std::in_place_index<2>,
            ::fidl::internal::NaturalClone(std::get<2>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  ::test_typesinprotocols::ProtocolErrorVectorCompoundResult test_typesinprotocols::ProtocolErrorVectorCompoundResult::WithResponse(::test_typesinprotocols::VectorCompound val) {
    return ProtocolErrorVectorCompoundResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorVectorCompoundResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorVectorCompoundResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorVectorCompoundResult& test_typesinprotocols::ProtocolErrorVectorCompoundResult::response(::test_typesinprotocols::VectorCompound value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorVectorCompoundResult test_typesinprotocols::ProtocolErrorVectorCompoundResult::WithErr(uint32_t val) {
    return ProtocolErrorVectorCompoundResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorVectorCompoundResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorVectorCompoundResult::Storage_> test_typesinprotocols::ProtocolErrorVectorCompoundResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorVectorCompoundResult& test_typesinprotocols::ProtocolErrorVectorCompoundResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

::test_typesinprotocols::ProtocolErrorVectorOptionalResult::ProtocolErrorVectorOptionalResult(ProtocolErrorVectorOptionalResult&& other) noexcept : ProtocolErrorVectorOptionalResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorVectorOptionalResult& ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::operator=(ProtocolErrorVectorOptionalResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorVectorOptionalResult::ProtocolErrorVectorOptionalResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorVectorOptionalResult::ProtocolErrorVectorOptionalResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag test_typesinprotocols::ProtocolErrorVectorOptionalResult::Which() const {
  return ProtocolErrorVectorOptionalResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorVectorOptionalResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag> test_typesinprotocols::ProtocolErrorVectorOptionalResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::ProtocolErrorVectorOptionalResult(const ProtocolErrorVectorOptionalResult& other) noexcept : ProtocolErrorVectorOptionalResult(other.CloneStorage_()){}

  ::test_typesinprotocols::ProtocolErrorVectorOptionalResult& test_typesinprotocols::ProtocolErrorVectorOptionalResult::operator=(const ProtocolErrorVectorOptionalResult& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::ProtocolErrorVectorOptionalResult::operator==(const ProtocolErrorVectorOptionalResult& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::ProtocolErrorVectorOptionalResult::operator!=(const ProtocolErrorVectorOptionalResult& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Storage_> test_typesinprotocols::ProtocolErrorVectorOptionalResult::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
        case 2:
          return std::make_shared<Storage_>(
            std::in_place_index<2>,
            ::fidl::internal::NaturalClone(std::get<2>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  ::test_typesinprotocols::ProtocolErrorVectorOptionalResult test_typesinprotocols::ProtocolErrorVectorOptionalResult::WithResponse(::test_typesinprotocols::VectorOptional val) {
    return ProtocolErrorVectorOptionalResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Storage_> test_typesinprotocols::ProtocolErrorVectorOptionalResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Storage_> test_typesinprotocols::ProtocolErrorVectorOptionalResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorVectorOptionalResult& test_typesinprotocols::ProtocolErrorVectorOptionalResult::response(::test_typesinprotocols::VectorOptional value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorVectorOptionalResult test_typesinprotocols::ProtocolErrorVectorOptionalResult::WithErr(uint32_t val) {
    return ProtocolErrorVectorOptionalResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Storage_> test_typesinprotocols::ProtocolErrorVectorOptionalResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorVectorOptionalResult::Storage_> test_typesinprotocols::ProtocolErrorVectorOptionalResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorVectorOptionalResult& test_typesinprotocols::ProtocolErrorVectorOptionalResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::ProtocolErrorArrayVectorNestedResult(ProtocolErrorArrayVectorNestedResult&& other) noexcept : ProtocolErrorArrayVectorNestedResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult& ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::operator=(ProtocolErrorArrayVectorNestedResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::ProtocolErrorArrayVectorNestedResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::ProtocolErrorArrayVectorNestedResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Which() const {
  return ProtocolErrorArrayVectorNestedResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag> test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::ProtocolErrorArrayVectorNestedResult(const ProtocolErrorArrayVectorNestedResult& other) noexcept : ProtocolErrorArrayVectorNestedResult(other.CloneStorage_()){}

  ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult& test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::operator=(const ProtocolErrorArrayVectorNestedResult& other) noexcept {
    if (this != &other) {
      storage_ = other.CloneStorage_();
    }
    return *this;
  }

  bool test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::operator==(const ProtocolErrorArrayVectorNestedResult& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::operator!=(const ProtocolErrorArrayVectorNestedResult& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  std::shared_ptr<::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Storage_> test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::CloneStorage_() const {
    const Storage_& storage = *storage_;
    switch (storage_->index()) {
        case 1:
          return std::make_shared<Storage_>(
            std::in_place_index<1>,
            ::fidl::internal::NaturalClone(std::get<1>(storage)));
        case 2:
          return std::make_shared<Storage_>(
            std::in_place_index<2>,
            ::fidl::internal::NaturalClone(std::get<2>(storage)));
      default:
        return std::make_shared<Storage_>();
    }
  }
  ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::WithResponse(::test_typesinprotocols::ArrayVectorNested val) {
    return ProtocolErrorArrayVectorNestedResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Storage_> test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Storage_> test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult& test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::response(::test_typesinprotocols::ArrayVectorNested value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::WithErr(uint32_t val) {
    return ProtocolErrorArrayVectorNestedResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Storage_> test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::Storage_> test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorArrayVectorNestedResult& test_typesinprotocols::ProtocolErrorArrayVectorNestedResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

#ifdef __Fuchsia__

::test_typesinprotocols::ProtocolErrorResourceResult::ProtocolErrorResourceResult(ProtocolErrorResourceResult&& other) noexcept : ProtocolErrorResourceResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag{}) {
  *storage_ = std::move(*other.storage_);
}

::test_typesinprotocols::ProtocolErrorResourceResult& ::test_typesinprotocols::ProtocolErrorResourceResult::operator=(ProtocolErrorResourceResult&& other) noexcept {
  if (this != &other) {
    *storage_ = std::move(*other.storage_);
  }
  return *this;
}

::test_typesinprotocols::ProtocolErrorResourceResult::ProtocolErrorResourceResult(::fidl::internal::DefaultConstructPossiblyInvalidObjectTag)
: storage_(std::make_shared<Storage_>()) {}

::test_typesinprotocols::ProtocolErrorResourceResult::ProtocolErrorResourceResult(std::shared_ptr<Storage_> storage) : storage_(std::move(storage)) {}

::test_typesinprotocols::ProtocolErrorResourceResult::Tag test_typesinprotocols::ProtocolErrorResourceResult::Which() const {
  return ProtocolErrorResourceResult::IndexToTag(storage_->index()).value();
}

size_t test_typesinprotocols::ProtocolErrorResourceResult::TagToIndex(::fidl::internal::NaturalDecoder* decoder, ::test_typesinprotocols::ProtocolErrorResourceResult::Tag tag) {
  switch (tag) {
      case ::test_typesinprotocols::ProtocolErrorResourceResult::Tag::kResponse: return 1;
      case ::test_typesinprotocols::ProtocolErrorResourceResult::Tag::kErr: return 2;
    default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
      return 0;
    }
  }
}

std::optional<::test_typesinprotocols::ProtocolErrorResourceResult::Tag> test_typesinprotocols::ProtocolErrorResourceResult::IndexToTag(size_t index) {
  switch (index) {
      case 1: return ::test_typesinprotocols::ProtocolErrorResourceResult::Tag::kResponse;
      case 2: return ::test_typesinprotocols::ProtocolErrorResourceResult::Tag::kErr;
      default: return std::nullopt;
  }
}

  ::test_typesinprotocols::ProtocolErrorResourceResult test_typesinprotocols::ProtocolErrorResourceResult::WithResponse(::test_typesinprotocols::Resource val) {
    return ProtocolErrorResourceResult(std::make_shared<Storage_>(
      std::in_place_index_t<1>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorResourceResult::Storage_> test_typesinprotocols::ProtocolErrorResourceResult::response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<1, ::test_typesinprotocols::ProtocolErrorResourceResult::Storage_> test_typesinprotocols::ProtocolErrorResourceResult::response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorResourceResult& test_typesinprotocols::ProtocolErrorResourceResult::response(::test_typesinprotocols::Resource value) {
    storage_->emplace<1>(std::move(value));
    return *this;
  }
  ::test_typesinprotocols::ProtocolErrorResourceResult test_typesinprotocols::ProtocolErrorResourceResult::WithErr(uint32_t val) {
    return ProtocolErrorResourceResult(std::make_shared<Storage_>(
      std::in_place_index_t<2>{},
      std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorResourceResult::Storage_> test_typesinprotocols::ProtocolErrorResourceResult::err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::fidl::internal::UnionMemberView<2, ::test_typesinprotocols::ProtocolErrorResourceResult::Storage_> test_typesinprotocols::ProtocolErrorResourceResult::err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

  ::test_typesinprotocols::ProtocolErrorResourceResult& test_typesinprotocols::ProtocolErrorResourceResult::err(uint32_t value) {
    storage_->emplace<2>(std::move(value));
    return *this;
  }

#endif  // __Fuchsia__

#pragma clang diagnostic pop

