// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#include <fidl/test.nullable/cpp/wire_types.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableString, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::StructWithNullableString* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::StructWithNullableString));
  } else {
    internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Encode(encoder, &value->val, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableString, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::StringView, fidl::internal::WireCodingConstraintString<true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableString, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableString, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::StructWithNullableString>);
static_assert(offsetof(::test_nullable::wire::StructWithNullableString, val) == 0);
static_assert(sizeof(::test_nullable::wire::StructWithNullableString) == ::fidl::TypeTraits<::test_nullable::wire::StructWithNullableString>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableVector, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::StructWithNullableVector* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::StructWithNullableVector));
  } else {
    internal::WireCodingTraits<::fidl::VectorView<int32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Encode(encoder, &value->val, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableVector, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::VectorView<int32_t>, fidl::internal::WireCodingConstraintVector<fidl::internal::WireCodingConstraintEmpty, true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableVector, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableVector, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::StructWithNullableVector>);
static_assert(offsetof(::test_nullable::wire::StructWithNullableVector, val) == 0);
static_assert(sizeof(::test_nullable::wire::StructWithNullableVector) == ::fidl::TypeTraits<::test_nullable::wire::StructWithNullableVector>::kPrimarySize);

#ifdef __Fuchsia__
void ::test_nullable::wire::StructWithNullableHandle::_CloseHandles() {
  val.reset();
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableHandle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::StructWithNullableHandle* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::StructWithNullableHandle));
  } else {
    internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>, IsRecursive>::Encode(encoder, &value->val, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableHandle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::zx::vmo, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x80000000, true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableHandle, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableHandle, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::StructWithNullableHandle>);
static_assert(offsetof(::test_nullable::wire::StructWithNullableHandle, val) == 0);
static_assert(sizeof(::test_nullable::wire::StructWithNullableHandle) == ::fidl::TypeTraits<::test_nullable::wire::StructWithNullableHandle>::kPrimarySize);

#endif  // __Fuchsia__

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleProtocolAddRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::SimpleProtocolAddRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::SimpleProtocolAddRequest));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleProtocolAddRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 4, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleProtocolAddRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleProtocolAddRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::SimpleProtocolAddRequest>);
static_assert(offsetof(::test_nullable::wire::SimpleProtocolAddRequest, a) == 0);
static_assert(offsetof(::test_nullable::wire::SimpleProtocolAddRequest, b) == 4);
static_assert(sizeof(::test_nullable::wire::SimpleProtocolAddRequest) == ::fidl::TypeTraits<::test_nullable::wire::SimpleProtocolAddRequest>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleProtocolAddResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::SimpleProtocolAddResponse* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::SimpleProtocolAddResponse));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->sum, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleProtocolAddResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleProtocolAddResponse, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleProtocolAddResponse, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::SimpleProtocolAddResponse>);
static_assert(offsetof(::test_nullable::wire::SimpleProtocolAddResponse, sum) == 0);
static_assert(sizeof(::test_nullable::wire::SimpleProtocolAddResponse) == ::fidl::TypeTraits<::test_nullable::wire::SimpleProtocolAddResponse>::kPrimarySize);

#ifdef __Fuchsia__
void ::test_nullable::wire::StructWithNullableProtocol::_CloseHandles() {
  val.reset();
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableProtocol, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::StructWithNullableProtocol* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::StructWithNullableProtocol));
  } else {
    internal::WireCodingTraits<::fidl::ClientEnd<::test_nullable::SimpleProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->val, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableProtocol, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::ClientEnd<::test_nullable::SimpleProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableProtocol, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableProtocol, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::StructWithNullableProtocol>);
static_assert(offsetof(::test_nullable::wire::StructWithNullableProtocol, val) == 0);
static_assert(sizeof(::test_nullable::wire::StructWithNullableProtocol) == ::fidl::TypeTraits<::test_nullable::wire::StructWithNullableProtocol>::kPrimarySize);

void ::test_nullable::wire::StructWithNullableRequest::_CloseHandles() {
  val.reset();
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::StructWithNullableRequest* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::StructWithNullableRequest));
  } else {
    internal::WireCodingTraits<::fidl::ServerEnd<::test_nullable::SimpleProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Encode(encoder, &value->val, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::ServerEnd<::test_nullable::SimpleProtocol>, fidl::internal::WireCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableRequest, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableRequest, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::StructWithNullableRequest>);
static_assert(offsetof(::test_nullable::wire::StructWithNullableRequest, val) == 0);
static_assert(sizeof(::test_nullable::wire::StructWithNullableRequest) == ::fidl::TypeTraits<::test_nullable::wire::StructWithNullableRequest>::kPrimarySize);

#endif  // __Fuchsia__

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::Int32Wrapper, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::Int32Wrapper* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::Int32Wrapper));
  } else {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->val, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::Int32Wrapper, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::Int32Wrapper, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::Int32Wrapper, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::Int32Wrapper>);
static_assert(offsetof(::test_nullable::wire::Int32Wrapper, val) == 0);
static_assert(sizeof(::test_nullable::wire::Int32Wrapper) == ::fidl::TypeTraits<::test_nullable::wire::Int32Wrapper>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::StructWithNullableStruct* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::StructWithNullableStruct));
  } else {
    internal::WireCodingTraits<::fidl::ObjectView<::test_nullable::wire::Int32Wrapper>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->val, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableStruct, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::ObjectView<::test_nullable::wire::Int32Wrapper>, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableStruct, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableStruct, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::StructWithNullableStruct>);
static_assert(offsetof(::test_nullable::wire::StructWithNullableStruct, val) == 0);
static_assert(sizeof(::test_nullable::wire::StructWithNullableStruct) == ::fidl::TypeTraits<::test_nullable::wire::StructWithNullableStruct>::kPrimarySize);

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::StructWithNullableUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (kIsMemcpyCompatible) {
    memcpy(position.As<void>(), value, sizeof(::test_nullable::wire::StructWithNullableUnion));
  } else {
    internal::WireCodingTraits<::fidl::WireOptional<::test_nullable::wire::SimpleUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Encode(encoder, &value->val, position + 0, recursion_depth);
  }
}

template <bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  if constexpr (!Base::are_members_memcpy_compatible) {
    internal::WireCodingTraits<::fidl::WireOptional<::test_nullable::wire::SimpleUnion>, fidl::internal::WireCodingConstraintUnion<true>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
  }
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::StructWithNullableUnion, ::fidl::internal::WireCodingConstraintEmpty, false>;

static_assert(std::is_standard_layout_v<::test_nullable::wire::StructWithNullableUnion>);
static_assert(offsetof(::test_nullable::wire::StructWithNullableUnion, val) == 0);
static_assert(sizeof(::test_nullable::wire::StructWithNullableUnion) == ::fidl::TypeTraits<::test_nullable::wire::StructWithNullableUnion>::kPrimarySize);

::test_nullable::wire::SimpleUnion::SimpleUnion() : ordinal_(::test_nullable::wire::SimpleUnion::Ordinal::Invalid), envelope_{} {}
::test_nullable::wire::SimpleUnion::Tag test_nullable::wire::SimpleUnion::Which() const {
  ZX_ASSERT(!has_invalid_tag());
  return static_cast<::test_nullable::wire::SimpleUnion::Tag>(ordinal_);
}

void ::test_nullable::wire::SimpleUnion::SizeAndOffsetAssertionHelper() {
  static_assert(sizeof(SimpleUnion) == sizeof(fidl_union_t));
  static_assert(offsetof(SimpleUnion, ordinal_) == offsetof(fidl_union_t, tag));
  static_assert(offsetof(SimpleUnion, envelope_) == offsetof(fidl_union_t, envelope));
}

bool test_nullable::wire::SimpleUnion::has_invalid_tag() const { return ordinal_ == ::test_nullable::wire::SimpleUnion::Ordinal::Invalid; }

bool test_nullable::wire::SimpleUnion::is_a() const { return ordinal_ == ::test_nullable::wire::SimpleUnion::Ordinal::kA; }
::test_nullable::wire::SimpleUnion test_nullable::wire::SimpleUnion::WithA(int32_t val) {
  SimpleUnion result;
  result.ordinal_ = ::test_nullable::wire::SimpleUnion::Ordinal::kA;
  result.envelope_.As<int32_t>().set_data(std::move(val));
  return result;
}

int32_t& test_nullable::wire::SimpleUnion::a() {
  ZX_ASSERT(ordinal_ == ::test_nullable::wire::SimpleUnion::Ordinal::kA);
  return envelope_.As<int32_t>().get_data();
}
const int32_t& test_nullable::wire::SimpleUnion::a() const {
  ZX_ASSERT(ordinal_ == ::test_nullable::wire::SimpleUnion::Ordinal::kA);
  return envelope_.As<int32_t>().get_data();
}

bool test_nullable::wire::SimpleUnion::is_b() const { return ordinal_ == ::test_nullable::wire::SimpleUnion::Ordinal::kB; }
::test_nullable::wire::SimpleUnion test_nullable::wire::SimpleUnion::WithB(float val) {
  SimpleUnion result;
  result.ordinal_ = ::test_nullable::wire::SimpleUnion::Ordinal::kB;
  result.envelope_.As<float>().set_data(std::move(val));
  return result;
}

float& test_nullable::wire::SimpleUnion::b() {
  ZX_ASSERT(ordinal_ == ::test_nullable::wire::SimpleUnion::Ordinal::kB);
  return envelope_.As<float>().get_data();
}
const float& test_nullable::wire::SimpleUnion::b() const {
  ZX_ASSERT(ordinal_ == ::test_nullable::wire::SimpleUnion::Ordinal::kB);
  return envelope_.As<float>().get_data();
}

static_assert(std::is_standard_layout_v<::test_nullable::wire::SimpleUnion>);

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleUnion, Constraint, IsRecursive>::Encode(
    ::fidl::internal::WireEncoder* encoder, ::test_nullable::wire::SimpleUnion* value, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  fidl_union_t* u = reinterpret_cast<fidl_union_t*>(value);

  if (unlikely(u->tag == 0)) {
    if constexpr (Constraint::is_optional) {
      *position.As<fidl_union_t>() = {};
      return;
    }
    encoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  *position.As<fidl_xunion_tag_t>() = u->tag;

  size_t encode_inline_size;
  switch (u->tag) {
    case 1:  // ::test_nullable::wire::SimpleUnion::Tag::kA
      encode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case 2:  // ::test_nullable::wire::SimpleUnion::Tag::kB
      encode_inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      encode_inline_size = 0;
      break;
  }
  ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
  switch (u->tag) {
    case 1:  // ::test_nullable::wire::SimpleUnion::Tag::kA
      encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case 2:  // ::test_nullable::wire::SimpleUnion::Tag::kB
      encode_fn = ::fidl::internal::MakeEncodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      encode_fn = nullptr;
      break;
  }
  WireEncodeEnvelope(encode_inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template <typename Constraint, bool IsRecursive>
void fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleUnion, Constraint, IsRecursive>::Decode(
    ::fidl::internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, ::fidl::internal::RecursionDepth<IsRecursive> recursion_depth) {
  ::test_nullable::wire::SimpleUnion::Tag tag = *position.As<::test_nullable::wire::SimpleUnion::Tag>();
  if (unlikely(static_cast<uint64_t>(tag) == 0)) {
    if constexpr (!Constraint::is_optional) {
      decoder->SetError(::fidl::internal::kCodingErrorInvalidUnionTag);
      return;
    }
    if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
      decoder->SetError(::fidl::internal::kCodingErrorZeroTagButNonZeroEnvelope);
    }
    return;
  }

  ::fidl::internal::RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
  if (!inner_depth.IsValid()) {
    return;
  }

  size_t decode_inline_size;
  switch (tag) {
    case ::test_nullable::wire::SimpleUnion::Tag::kA:
      decode_inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    case ::test_nullable::wire::SimpleUnion::Tag::kB:
      decode_inline_size = ::fidl::internal::WireCodingTraits<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::kInlineSize;
      break;
    default:
      decode_inline_size = 0;
      break;
  }
  DecodeFn<IsRecursive> decode_fn;
  switch (tag) {
    case ::test_nullable::wire::SimpleUnion::Tag::kA:
      decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    case ::test_nullable::wire::SimpleUnion::Tag::kB:
      decode_fn = ::fidl::internal::MakeDecodeFn<float, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
      break;
    default:
      decode_fn = nullptr;
      break;
  }
  ::fidl::internal::WireDecodeStrictEnvelope(decode_inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
}

template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleUnion, ::fidl::internal::WireCodingConstraintUnion<false>, false>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, true>;
template struct ::fidl::internal::WireCodingTraits<::test_nullable::wire::SimpleUnion, ::fidl::internal::WireCodingConstraintUnion<true>, false>;

#pragma clang diagnostic pop
