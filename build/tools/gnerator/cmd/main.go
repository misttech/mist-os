// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"go.fuchsia.dev/fuchsia/build/tools/gnerator"
	"go.starlark.net/starlark"
	"go.starlark.net/syntax"
)

var (
	bazelInputPath = flag.String("bazel_input_path", "", "Path to read the BUILD.bazel file from.")
	gnOutputPath   = flag.String("gn_output_path", "", "Path to output the converted GN targest to.")
)

// bazelBuiltins contains all known Bazel builtin functions. The starlark parser
// fail when it encounters any names not found in this dictionary, or not loaded
// in through a explicit load call.
var bazelBuiltins = starlark.StringDict{
	"select":  nil,
	"package": nil,
}

// commonFileHeader is the header to add to the top of every BUILD.gn file
// converted from a BUILD.bazel file.
const (
	gneratorComment = `#
#  ________  _________  ________  ________
# |\   ____\|\___   ___\\   __  \|\   __  \
# \ \  \___|\|___ \  \_\ \  \|\  \ \  \|\  \
#  \ \_____  \   \ \  \ \ \  \\\  \ \   ____\
#   \|____|\  \   \ \  \ \ \  \\\  \ \  \___|
#     ____\_\  \   \ \__\ \ \_______\ \__\
#    |\_________\   \|__|  \|_______|\|__|
#    \|_________|
#
#
# AUTO-GENERATED - DO NOT EDIT
#
# The targets below are auto-generated based on the targets defined in the
# BUILD.bazel file from the same directory. If you made changes to targets in
# Bazel, instead of editing this file manually, run:
#
#   > fx gnerate
#
# Please do NOT edit this file directly. Instead, edit the BUILD.bazel file and
# rerun gnerate.

import("//build/tools/gnerator/bazel_migration.gni")
`

	sentinelComment = "## GNERATOR SENTINEL - DO NOT EDIT BELOW THIS LINE ##"
)

func main() {
	flag.Parse()

	if *bazelInputPath == "" {
		log.Fatal("--bazel_input_path is required, see --help")
	}

	if *gnOutputPath == "" {
		log.Fatal("--gn_output_path is required, see --help")
	}

	opts := new(syntax.FileOptions)
	bazelIn, _, err := starlark.SourceProgramOptions(opts, *bazelInputPath, nil, bazelBuiltins.Has)
	if err != nil {
		log.Fatalf("Parsing input Bazel file %s: %v", *bazelInputPath, err)
	}

	var finalLines []string

	for _, stmt := range bazelIn.Stmts {
		lines, err := gnerator.StmtToGN(stmt)
		if err != nil {
			log.Fatalf("Failed to convert top-level statement in Bazel to GN: %v", err)
		}
		finalLines = append(finalLines, lines...)
	}

	// Open the GN build file with readonly first, to read the GN targets that
	// need to be preserved.
	gnOut, err := os.Open(*gnOutputPath)
	if err != nil {
		log.Fatalf("Failed to open %s for reading: %v", *gnOutputPath, err)
	}
	toPreserve, err := gnTargetsToPreserve(gnOut)
	if err != nil {
		log.Fatalf("Failed to read GN targets to preserve: %v", err)
	}
	finalContent := toPreserve + "\n" + sentinelComment + "\n" + gneratorComment + "\n" + strings.Join(finalLines, "\n")

	// Open the GN file again for write.
	gnOut, err = os.OpenFile(*gnOutputPath, os.O_WRONLY|os.O_TRUNC, 0)
	if err != nil {
		log.Fatalf("Failed to open %s for writing: %v", *gnOutputPath, err)
	}
	if _, err := io.WriteString(gnOut, finalContent); err != nil {
		log.Fatalf("Failed to write final GN build file: %v", err)
	}
}

func gnTargetsToPreserve(r io.Reader) (string, error) {
	s := bufio.NewScanner(r)
	ret := strings.Builder{}
	for s.Scan() {
		line := s.Text()
		if strings.TrimSpace(line) == sentinelComment {
			break
		}
		if _, err := ret.WriteString(line + "\n"); err != nil {
			return "", fmt.Errorf("writing existing line to string buffer: %v", err)
		}
	}
	return ret.String(), nil
}
