// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_STORAGE_LIB_BLOCK_SERVER_BLOCK_SERVER_C_H_
#define SRC_STORAGE_LIB_BLOCK_SERVER_BLOCK_SERVER_C_H_

// NOTE: This file is autogenerated by cbindgen.  Don't modify this manually.  To regenerate
// this file:
//
// Add `--cargo-toml-gen` to your `fx set`. Then:
//
// fx build //build/rust:cargo_toml_gen //src/storage/lib/block_server
// fx gen-cargo //src/storage/lib/block_server
// cargo install cbindgen
// rustup default nightly
// cbindgen --output block_server_c.h
// fx format-code

#include <zircon/types.h>

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <new>
#include <ostream>

#include "lib/zx/vmo.h"

namespace block_server::internal {

struct BlockServer;

class WriteOptions {
 public:
  bool is_force_access() const { return (options_ & 1) != 0; }

 private:
  uint32_t options_;
};

}  // namespace block_server::internal

namespace block_server {
namespace internal {

constexpr static const uintptr_t MAX_REQUESTS = 64;

struct Session;

struct PartitionInfo {
  uint64_t start_block;
  uint64_t block_count;
  uint32_t block_size;
  uint8_t type_guid[16];
  uint8_t instance_guid[16];
  const char *name;
  uint64_t flags;
};

using RequestId = uint64_t;

struct Operation {
  enum class Tag {
    Read,
    Write,
    Flush,
    Trim,
    /// This will never be seen by the C interface.
    CloseVmo,
  };

  struct Read_Body {
    uint64_t device_block_offset;
    uint32_t block_count;
    uint32_t _unused;
    uint64_t vmo_offset;
  };

  struct Write_Body {
    uint64_t device_block_offset;
    uint32_t block_count;
    WriteOptions options;
    uint64_t vmo_offset;
  };

  struct Trim_Body {
    uint64_t device_block_offset;
    uint32_t block_count;
  };

  Tag tag;
  union {
    Read_Body read;
    Write_Body write;
    Trim_Body trim;
  };
};

struct Request {
  RequestId request_id;
  Operation operation;
  uint64_t trace_flow_id;
  zx::unowned<zx::vmo> vmo;
};

struct Callbacks {
  void *context;
  void (*start_thread)(void *context, const void *arg);
  void (*on_new_session)(void *context, const Session *session);
  void (*on_requests)(void *context, const Session *session, Request *requests,
                      uintptr_t request_count);
  void (*log)(void *context, const char *message, uintptr_t message_len);
};

using ShutdownCallback = void (*)(void *);

extern "C" {

/// # Safety
///
/// All callbacks in `callbacks` must be safe.
BlockServer *block_server_new(const PartitionInfo *partition_info, Callbacks callbacks);

/// # Safety
///
/// `arg` must be the value passed to the `start_thread` callback.
void block_server_thread(const void *arg);

/// Called to delete the thread.  This *must* always be called, regardless of whether starting the
/// thread is successful or not.
///
/// # Safety
///
/// `arg` must be the value passed to the `start_thread` callback.
void block_server_thread_delete(const void *arg);

/// # Safety
///
/// `block_server` must be valid.
void block_server_delete(BlockServer *block_server);

/// # Safety
///
/// `block_server` must be valid.
void block_server_delete_async(BlockServer *block_server, ShutdownCallback callback, void *arg);

/// Serves the Volume protocol for this server.  `handle` is consumed.
///
/// # Safety
///
/// `block_server` and `handle` must be valid.
void block_server_serve(const BlockServer *block_server, zx_handle_t handle);

/// # Safety
///
/// `session` must be valid.
void block_server_session_run(const Session *session);

/// # Safety
///
/// `session` must be valid.
void block_server_session_release(const Session *session);

/// # Safety
///
/// `session` must be valid.
void block_server_send_reply(const Session *session, RequestId request_id, uint64_t trace_flow_id,
                             zx_status_t status);

}  // extern "C"

}  // namespace internal
}  // namespace block_server

#endif  // SRC_STORAGE_LIB_BLOCK_SERVER_BLOCK_SERVER_C_H_
