// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use anyhow::{anyhow, Context as _};
use async_utils::hanging_get::client::HangingGetStream;
use fidl::endpoints::Proxy as _;
use fidl_fuchsia_net_ext::{self as fnet_ext, IntoExt};
use fuchsia_component::client::connect_to_protocol;
use fuchsia_component::server::{ServiceFs, ServiceFsDir};
use futures_util::{StreamExt as _, TryStreamExt as _};
use net_types::ip::{Ip, Ipv4, Ipv6};
use net_types::SpecifiedAddr;
use tracing::{error, info};
use {
    fidl_fuchsia_hardware_network as fhardware_network, fidl_fuchsia_net as fnet,
    fidl_fuchsia_net_interfaces as fnet_interfaces,
    fidl_fuchsia_net_interfaces_admin as fnet_interfaces_admin,
    fidl_fuchsia_net_interfaces_ext as fnet_interfaces_ext,
    fidl_fuchsia_net_routes_ext as fnet_routes_ext, fidl_fuchsia_netemul as fnetemul,
};

#[fuchsia_async::run_singlethreaded]
async fn main() {
    diagnostics_log::initialize(diagnostics_log::PublishOptions::default()).expect("init logging");
    info!("started");

    let mut fs = ServiceFs::new_local();
    let _: &mut ServiceFsDir<'_, _> =
        fs.dir("svc").add_fidl_service(|s: fnetemul::ConfigurableNetstackRequestStream| s);
    let _: &mut ServiceFs<_> = fs.take_and_serve_directory_handle().expect("take startup handle");
    fs.fuse()
        .flatten_unordered(None)
        .and_then(handle_request)
        .for_each_concurrent(None, |r| async {
            r.unwrap_or_else(|e| error!("failed to handle configurable netstack request: {:?}", e))
        })
        .await;
    unreachable!("service fs ended unexpectedly")
}

async fn handle_request(request: fnetemul::ConfigurableNetstackRequest) -> Result<(), fidl::Error> {
    match request {
        fnetemul::ConfigurableNetstackRequest::ConfigureInterface { payload, responder } => {
            let result = match configure_interface(payload).await {
                Ok(()) => Ok(()),
                Err(e) => {
                    error!("error configuring interface: {:?}", e);
                    Err(e.into())
                }
            };
            responder.send(result)
        }
    }
}

#[derive(thiserror::Error, Debug)]
enum InterfaceConfigError {
    #[error("name not provided")]
    NameNotProvided,
    #[error("device connection not provided")]
    DeviceConnectionNotProvided,
    #[error("error communicating with the netstack or network-tun: {0:?}")]
    Fidl(#[from] fidl::Error),
    #[error("error from netstack: {0:?}")]
    Netstack(#[from] NetstackError),
    #[error("internal error: {0:?}")]
    Internal(#[from] anyhow::Error),
}

#[derive(thiserror::Error, Debug)]
enum NetstackError {
    #[error("the interface control channel was closed: {0:?}")]
    InterfaceControl(
        fnet_interfaces_ext::admin::TerminalError<fnet_interfaces_admin::InterfaceRemovedReason>,
    ),
    #[error("failed to enable interface: {0:?}")]
    EnableInterface(fnet_interfaces_admin::ControlEnableError),
    #[error("failed to remove address {addr:?} from interface: {error:?}")]
    RemoveAddress { error: fnet_interfaces_admin::ControlRemoveAddressError, addr: fnet::Subnet },
    #[error("failed to set interface configuration: {0:?}")]
    SetConfiguration(fnet_interfaces_admin::ControlSetConfigurationError),
    #[error("error waiting for address assignment: {0:?}")]
    WaitForAddressAssignment(fnet_interfaces_ext::admin::AddressStateProviderError),
}

impl Into<fnetemul::ConfigurationError> for InterfaceConfigError {
    fn into(self) -> fnetemul::ConfigurationError {
        match self {
            InterfaceConfigError::NameNotProvided
            | InterfaceConfigError::DeviceConnectionNotProvided => {
                fnetemul::ConfigurationError::InvalidArguments
            }
            // TODO(https://fxbug.dev/42177777, https://fxbug.dev/42177895): map invalid arguments
            // errors from the netstack to `ConfigurationError.INVALID_ARGUMENTS` rather
            // than `ConfigurationError.REJECTED_BY_NETSTACK`.
            InterfaceConfigError::Netstack(_) => fnetemul::ConfigurationError::RejectedByNetstack,
            InterfaceConfigError::Fidl(_) | InterfaceConfigError::Internal(_) => {
                fnetemul::ConfigurationError::Internal
            }
        }
    }
}

// The default metric used in netemul endpoint configurations.
const DEFAULT_METRIC: u32 = 100;

async fn configure_interface(
    fnetemul::InterfaceOptions {
        name,
        device,
        without_autogenerated_addresses,
        static_ips,
        gateway,
        enable_ipv4_forwarding,
        enable_ipv6_forwarding,
        ipv4_multicast_neighbor_solicitations,
        ipv6_multicast_neighbor_solicitations,
        __source_breaking,
    }: fnetemul::InterfaceOptions,
) -> Result<(), InterfaceConfigError> {
    let name = name.ok_or(InterfaceConfigError::NameNotProvided)?;
    let device_instance = device.ok_or(InterfaceConfigError::DeviceConnectionNotProvided)?;

    info!("installing and configuring interface '{}'", name);

    let (control, server_end) =
        fnet_interfaces_ext::admin::Control::create_endpoints().context("create endpoints")?;
    let nicid = {
        let device = {
            let (proxy, server_end) =
                fidl::endpoints::create_proxy::<fhardware_network::DeviceMarker>();
            device_instance.into_proxy().get_device(server_end)?;
            proxy
        };
        let mut port_events = {
            let (proxy, server_end) =
                fidl::endpoints::create_proxy::<fhardware_network::PortWatcherMarker>();
            device.get_port_watcher(server_end)?;
            HangingGetStream::new(proxy, fhardware_network::PortWatcherProxy::watch)
        };
        let port_id = loop {
            let port_event = port_events.next().await.context("get port event")??;
            match port_event {
                fhardware_network::DevicePortEvent::Existing(port_id)
                | fhardware_network::DevicePortEvent::Added(port_id) => {
                    break port_id;
                }
                fhardware_network::DevicePortEvent::Idle(fhardware_network::Empty {}) => {
                    info!(
                        "failed to observe port on network device for interface '{}', \
                            waiting...",
                        name
                    );
                }
                fhardware_network::DevicePortEvent::Removed(port_id) => {
                    return Err(anyhow!(
                        "unexpected removal of device port {:?} for interface '{}'",
                        port_id,
                        name,
                    )
                    .into());
                }
            }
        };
        let device_control = {
            let (proxy, server_end) =
                fidl::endpoints::create_proxy::<fnet_interfaces_admin::DeviceControlMarker>();
            let device = fidl::endpoints::ClientEnd::new(
                device.into_channel().expect("extract channel from proxy").into_zx_channel(),
            );
            let installer = connect_to_protocol::<fnet_interfaces_admin::InstallerMarker>()
                .context("connect to protocol")?;
            installer.install_device(device, server_end)?;
            proxy
        };
        device_control.create_interface(
            &port_id,
            server_end,
            &fnet_interfaces_admin::Options {
                name: Some(name.clone()),
                metric: Some(DEFAULT_METRIC),
                ..Default::default()
            },
        )?;

        // Ensure the interface won't be removed when we drop the control handles.
        device_control.detach()?;
        control.detach().map_err(NetstackError::InterfaceControl)?;

        control.get_id().await.map_err(NetstackError::InterfaceControl)?
    };

    let _enabled: bool = control
        .enable()
        .await
        .map_err(NetstackError::InterfaceControl)?
        .map_err(NetstackError::EnableInterface)?;

    info!("interface '{}': installed with nicid {}", name, nicid);

    let interface_state =
        connect_to_protocol::<fnet_interfaces::StateMarker>().context("connect to protocol")?;
    fnet_interfaces_ext::wait_interface_with_id(
        fnet_interfaces_ext::event_stream_from_state::<fnet_interfaces_ext::DefaultInterest>(
            &interface_state,
            fnet_interfaces_ext::IncludedAddresses::OnlyAssigned,
        )
        .context("get interface state watcher events")?,
        &mut fnet_interfaces_ext::InterfaceState::<(), _>::Unknown(nicid),
        |properties_and_state| properties_and_state.properties.online.then(|| ()),
    )
    .await
    .context("wait for interface online")?;

    info!("interface '{}': online", name);

    // TODO(https://fxbug.dev/42154294): preempt address autogeneration instead of removing
    // them after they're generated.
    if without_autogenerated_addresses.unwrap_or_default() {
        info!("interface '{}': waiting for link-local address generation", name);
        let mut addresses = fnet_interfaces_ext::wait_interface_with_id(
            fnet_interfaces_ext::event_stream_from_state::<fnet_interfaces_ext::DefaultInterest>(
                &interface_state,
                fnet_interfaces_ext::IncludedAddresses::OnlyAssigned,
            )
            .context("get interface state watcher events")?,
            &mut fnet_interfaces_ext::InterfaceState::<(), _>::Unknown(nicid),
            |properties_and_state| {
                let addresses = &properties_and_state.properties.addresses;
                if addresses.is_empty() {
                    None
                } else {
                    Some(addresses.clone())
                }
            },
        )
        .await
        .context("wait for link-local address generation")?;

        let interface_addr = match addresses.as_mut_slice() {
            [fnet_interfaces_ext::Address { addr, assignment_state, .. }] => {
                assert_eq!(*assignment_state, fnet_interfaces::AddressAssignmentState::Assigned);
                Ok(addr)
            }
            addrs => {
                Err(anyhow!("found more than one autogenerated link-local address: {:?}", addrs))
            }
        }?;

        let _removed: bool = control
            .remove_address(&interface_addr)
            .await
            .map_err(NetstackError::InterfaceControl)?
            .map_err(|error| NetstackError::RemoveAddress {
                error,
                addr: interface_addr.clone(),
            })?;

        info!("interface '{}': removed auto-generated link-local address", name);
    }

    if let Some(static_ips) = static_ips {
        for interface_address in static_ips {
            let address_state_provider = {
                let (address_state_provider, server_end) = fidl::endpoints::create_proxy::<
                    fnet_interfaces_admin::AddressStateProviderMarker,
                >();
                control
                    .add_address(
                        &interface_address,
                        &fnet_interfaces_admin::AddressParameters {
                            add_subnet_route: Some(true),
                            ..Default::default()
                        },
                        server_end,
                    )
                    .map_err(NetstackError::InterfaceControl)?;
                fnet_interfaces_ext::admin::wait_assignment_state(
                    &mut fnet_interfaces_ext::admin::assignment_state_stream(
                        address_state_provider.clone(),
                    ),
                    fnet_interfaces::AddressAssignmentState::Assigned,
                )
                .await
                .map_err(NetstackError::WaitForAddressAssignment)?;

                address_state_provider
            };

            info!(
                "interface '{}': assigned static IP address {:?} (and subnet route)",
                name, interface_address
            );

            // Ensure this address won't be removed when we drop the state provider handle.
            address_state_provider.detach()?;
        }
    }

    if let Some(gateway) = gateway {
        let grant = control
            .get_authorization_for_interface()
            .await
            .context("failed to get interface authorization")?;

        async fn add_route_through_gateway<
            I: Ip + fnet_routes_ext::FidlRouteIpExt + fnet_routes_ext::admin::FidlRouteAdminIpExt,
        >(
            gateway: <I::Addr as fnet_ext::NetTypesIpAddressExt>::Fidl,
            fnet_interfaces_admin::GrantForInterfaceAuthorization { interface_id, token }: fnet_interfaces_admin::GrantForInterfaceAuthorization,
        ) -> Result<(), InterfaceConfigError>
        where
            <I as Ip>::Addr: fnet_ext::NetTypesIpAddressExt,
            <I::Addr as fnet_ext::NetTypesIpAddressExt>::Fidl: IntoExt<I::Addr>,
        {
            let gateway: I::Addr = gateway.into_ext();
            let gateway = SpecifiedAddr::new(gateway)
                .ok_or(anyhow::anyhow!("gateway address must be specified"))?;

            let root_routes = connect_to_protocol::<I::GlobalRouteTableMarker>()
                .context("connect to global route table")?;
            let global_route_set = fnet_routes_ext::admin::new_global_route_set::<I>(&root_routes)
                .context("create global route set")?;
            fnet_routes_ext::admin::authenticate_for_interface::<I>(
                &global_route_set,
                fnet_interfaces_admin::ProofOfInterfaceAuthorization { interface_id, token },
            )
            .await
            .context("FIDL error authenticating for interface")?
            .map_err(|e| anyhow::anyhow!("error authenticating for interface: {e:?}"))?;

            let _: bool = fnet_routes_ext::admin::add_route::<I>(
                &global_route_set,
                &fnet_routes_ext::Route::new_forward_with_inherited_metric(
                    net_types::ip::Subnet::new(I::UNSPECIFIED_ADDRESS, 0)
                        .expect("unspecified subnet is valid"),
                    interface_id,
                    Some(gateway),
                )
                .try_into()
                .expect("convert to FIDL should succeed"),
            )
            .await
            .context("FIDL error adding route")?
            .map_err(|e| anyhow::anyhow!("error adding route: {e:?}"))?;
            Ok(())
        }

        match gateway {
            fnet::IpAddress::Ipv4(gateway) => {
                add_route_through_gateway::<Ipv4>(gateway, grant).await?;
            }
            fnet::IpAddress::Ipv6(gateway) => {
                add_route_through_gateway::<Ipv6>(gateway, grant).await?;
            }
        };

        info!("interface '{}': configured default route with gateway address {:?}", name, gateway);
    }

    let _prev_config = control
        .set_configuration(&fnet_interfaces_admin::Configuration {
            ipv4: Some(fnet_interfaces_admin::Ipv4Configuration {
                unicast_forwarding: enable_ipv4_forwarding,
                arp: Some(fnet_interfaces_admin::ArpConfiguration {
                    nud: Some(fnet_interfaces_admin::NudConfiguration {
                        max_multicast_solicitations: ipv4_multicast_neighbor_solicitations,
                        ..Default::default()
                    }),
                    ..Default::default()
                }),
                ..Default::default()
            }),
            ipv6: Some(fnet_interfaces_admin::Ipv6Configuration {
                unicast_forwarding: enable_ipv6_forwarding,
                ndp: Some(fnet_interfaces_admin::NdpConfiguration {
                    nud: Some(fnet_interfaces_admin::NudConfiguration {
                        max_multicast_solicitations: ipv6_multicast_neighbor_solicitations,
                        ..Default::default()
                    }),
                    ..Default::default()
                }),
                ..Default::default()
            }),
            ..Default::default()
        })
        .await
        .map_err(NetstackError::InterfaceControl)?
        .map_err(NetstackError::SetConfiguration)?;
    if enable_ipv4_forwarding.is_some_and(|enabled| enabled) {
        info!("interface `{name}`: enabled IPv4 forwarding");
    }
    if enable_ipv6_forwarding.is_some_and(|enabled| enabled) {
        info!("interface `{name}`: enabled IPv6 forwarding");
    }
    if let Some(max_solicits) = ipv4_multicast_neighbor_solicitations {
        info!(
            "interface `{name}`: set IPv4 max multicast neighbor solicitations to: {max_solicits}",
        );
    }
    if let Some(max_solicits) = ipv6_multicast_neighbor_solicitations {
        info!(
            "interface `{name}`: set IPv6 max multicast neighbor solicitations to: {max_solicits}",
        );
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use assert_matches::assert_matches;

    #[fuchsia_async::run_singlethreaded(test)]
    async fn missing_name() {
        let result =
            configure_interface(fnetemul::InterfaceOptions { name: None, ..Default::default() })
                .await;

        assert_matches!(result, Err(InterfaceConfigError::NameNotProvided));
    }

    #[fuchsia_async::run_singlethreaded(test)]
    async fn missing_device() {
        let result = configure_interface(fnetemul::InterfaceOptions {
            name: Some("ep".to_string()),
            device: None,
            ..Default::default()
        })
        .await;

        assert_matches!(result, Err(InterfaceConfigError::DeviceConnectionNotProvided));
    }

    #[fuchsia_async::run_singlethreaded(test)]
    async fn broken_port_instance() {
        let (client_end, server_end) =
            fidl::endpoints::create_endpoints::<fhardware_network::PortMarker>();
        drop(server_end);

        let result = configure_interface(fnetemul::InterfaceOptions {
            name: Some("ep".to_string()),
            device: Some(client_end),
            ..Default::default()
        })
        .await;

        assert_matches!(result, Err(InterfaceConfigError::Fidl(e)) if e.is_closed());
    }
}
