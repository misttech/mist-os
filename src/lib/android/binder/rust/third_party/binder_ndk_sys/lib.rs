/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* automatically generated by rust-bindgen 0.69.5 */

use libc::sockaddr;

extern "C" {
    pub fn android_get_application_target_sdk_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn android_get_device_api_level() -> ::std::os::raw::c_int;
}
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __uid_t = __kernel_uid32_t;
pub type uid_t = __uid_t;
pub type __pid_t = __kernel_pid_t;
pub type pid_t = __pid_t;
pub type __socklen_t = u32;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn __assert(
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
        __msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert2(
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
        __function: *const ::std::os::raw::c_char,
        __msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __errno() -> *mut ::std::os::raw::c_int;
}
#[doc = " One of the STATUS_* values.\n\n All unrecognized values are coerced into STATUS_UNKNOWN_ERROR."]
pub type binder_status_t = i32;
#[doc = " One of the EX_* enumerators.\n\n All unrecognized values are coerced into EX_TRANSACTION_FAILED.\n\n These exceptions values are used by the SDK for parcelables. Also see Parcel.java."]
pub type binder_exception_t = i32;
#[doc = " This is a helper class that encapsulates a standard way to keep track of and chain binder errors\n along with service specific errors.\n\n It is not required to be used in order to parcel/receive transactions, but it is required in\n order to be compatible with standard AIDL transactions since it is written as the header to the\n out parcel for transactions which get executed (don't fail during unparceling of input arguments\n or sooner)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AStatus {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " New status which is considered a success.\n\n Available since API level 29.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_newOk() -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with exception code.\n\n Available since API level 29.\n\n \\param exception the code that this status should represent. If this is EX_NONE, then this\n constructs an non-error status object.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromExceptionCode(exception: binder_exception_t) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with exception code and message.\n\n Available since API level 29.\n\n \\param exception the code that this status should represent. If this is EX_NONE, then this\n constructs an non-error status object.\n \\param message the error message to associate with this status object.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromExceptionCodeWithMessage(
        exception: binder_exception_t,
        message: *const ::std::os::raw::c_char,
    ) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with a service speciic error.\n\n This is considered to be EX_TRANSACTION_FAILED with extra information.\n\n Available since API level 29.\n\n \\param serviceSpecific an implementation defined error code.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromServiceSpecificError(serviceSpecific: i32) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with a service specific error and message.\n\n This is considered to be EX_TRANSACTION_FAILED with extra information.\n\n Available since API level 29.\n\n \\param serviceSpecific an implementation defined error code.\n \\param message the error message to associate with this status object.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromServiceSpecificErrorWithMessage(
        serviceSpecific: i32,
        message: *const ::std::os::raw::c_char,
    ) -> *mut AStatus;
}
extern "C" {
    #[doc = " New status with binder_status_t. This is typically for low level failures when a binder_status_t\n is returned by an API on AIBinder or AParcel, and that is to be returned from a method returning\n an AStatus instance. This is the least preferable way to return errors.\n Prefer exceptions (particularly service-specific errors) when possible.\n\n Available since API level 29.\n\n \\param status a low-level error to associate with this status object.\n\n \\return a newly constructed status object that the caller owns."]
    pub fn AStatus_fromStatus(status: binder_status_t) -> *mut AStatus;
}
extern "C" {
    #[doc = " Whether this object represents a successful transaction. If this function returns true, then\n AStatus_getExceptionCode will return EX_NONE.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return whether the status represents a successful transaction. For more details, see below."]
    pub fn AStatus_isOk(status: *const AStatus) -> bool;
}
extern "C" {
    #[doc = " The exception that this status object represents.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return the exception code that this object represents."]
    pub fn AStatus_getExceptionCode(status: *const AStatus) -> binder_exception_t;
}
extern "C" {
    #[doc = " The service specific error if this object represents one. This function will only ever return a\n non-zero result if AStatus_getExceptionCode returns EX_SERVICE_SPECIFIC. If this function returns\n 0, the status object may still represent a different exception or status. To find out if this\n transaction as a whole is okay, use AStatus_isOk instead.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return the service-specific error code if the exception code is EX_SERVICE_SPECIFIC or 0."]
    pub fn AStatus_getServiceSpecificError(status: *const AStatus) -> i32;
}
extern "C" {
    #[doc = " The status if this object represents one. This function will only ever return a non-zero result\n if AStatus_getExceptionCode returns EX_TRANSACTION_FAILED. If this function return 0, the status\n object may represent a different exception or a service specific error. To find out if this\n transaction as a whole is okay, use AStatus_isOk instead.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return the status code if the exception code is EX_TRANSACTION_FAILED or 0."]
    pub fn AStatus_getStatus(status: *const AStatus) -> binder_status_t;
}
extern "C" {
    #[doc = " If there is a message associated with this status, this will return that message. If there is no\n message, this will return an empty string.\n\n The returned string has the lifetime of the status object passed into this function.\n\n Available since API level 29.\n\n \\param status the status being queried.\n\n \\return the message associated with this error."]
    pub fn AStatus_getMessage(status: *const AStatus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get human-readable description for debugging.\n\n Available since API level 30.\n\n \\param status the status being queried.\n\n \\return a description, must be deleted with AStatus_deleteDescription."]
    pub fn AStatus_getDescription(status: *const AStatus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Delete description.\n\n \\param description value from AStatus_getDescription"]
    pub fn AStatus_deleteDescription(description: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Deletes memory associated with the status instance.\n\n Available since API level 29.\n\n \\param status the status to delete, returned from AStatus_newOk or one of the AStatus_from* APIs."]
    pub fn AStatus_delete(status: *mut AStatus);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbstate_t {
    pub __seq: [::std::os::raw::c_uchar; 4usize],
    pub __reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mbstate_t>(),
        1usize,
        concat!("Alignment of ", stringify!(mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__seq) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mbstate_t), "::", stringify!(__seq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(mbstate_t), "::", stringify!(__reserved))
    );
}
extern "C" {
    pub fn c16rtomb(__buf: *mut ::std::os::raw::c_char, __ch16: u16, __ps: *mut mbstate_t)
        -> usize;
}
extern "C" {
    pub fn c32rtomb(__buf: *mut ::std::os::raw::c_char, __ch32: u32, __ps: *mut mbstate_t)
        -> usize;
}
extern "C" {
    pub fn mbrtoc16(
        __ch16: *mut u16,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbrtoc32(
        __ch32: *mut u32,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
#[doc = " Represents a local or remote object which can be used for IPC or which can itself be sent.\n\n This object has a refcount associated with it and will be deleted when its refcount reaches zero.\n How methods interactive with this refcount is described below. When using this API, it is\n intended for a client of a service to hold a strong reference to that service. This also means\n that user data typically should hold a strong reference to a local AIBinder object. A remote\n AIBinder object automatically holds a strong reference to the AIBinder object in the server's\n process. A typically memory layout looks like this:\n\n Key:\n   --->         Ownership/a strong reference\n   ...>         A weak reference\n\n                         (process boundary)\n                                 |\n MyInterface ---> AIBinder_Weak  |  ProxyForMyInterface\n      ^                .         |          |\n      |                .         |          |\n      |                v         |          v\n   UserData  <---   AIBinder   <-|-      AIBinder\n                                 |\n\n In this way, you'll notice that a proxy for the interface holds a strong reference to the\n implementation and that in the server process, the AIBinder object which was sent can be resent\n so that the same AIBinder object always represents the same object. This allows, for instance, an\n implementation (usually a callback) to transfer all ownership to a remote process and\n automatically be deleted when the remote process is done with it or dies. Other memory models are\n possible, but this is the standard one.\n\n If the process containing an AIBinder dies, it is possible to be holding a strong reference to\n an object which does not exist. In this case, transactions to this binder will return\n STATUS_DEAD_OBJECT. See also AIBinder_linkToDeath, AIBinder_unlinkToDeath, and AIBinder_isAlive.\n\n Once an AIBinder is created, anywhere it is passed (remotely or locally), there is a 1-1\n correspondence between the address of an AIBinder and the object it represents. This means that\n when two AIBinder pointers point to the same address, they represent the same object (whether\n that object is local or remote). This correspondance can be broken accidentally if AIBinder_new\n is erronesouly called to create the same object multiple times."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder {
    _unused: [u8; 0],
}
#[doc = " This object represents a package of data that can be sent between processes. When transacting, an\n instance of it is automatically created to be used for the transaction. When two processes use\n binder to communicate, they must agree on a format of this parcel to be used in order to transfer\n data. This is usually done in an IDL (see AIDL, specificially)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AParcel {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Cleans up a parcel.\n\n Available since API level 29.\n\n \\param parcel A parcel returned by AIBinder_prepareTransaction or AIBinder_transact when a\n transaction is being aborted."]
    pub fn AParcel_delete(parcel: *mut AParcel);
}
extern "C" {
    #[doc = " Sets the position within the parcel.\n\n This must be called with a position that has been previously returned from\n AParcel_getDataPosition. If writes are made after setting the data position, they must\n be made in the exact same sequence used before resetting data position. Writing over\n objects such as binders or file descriptors is not supported.\n\n Available since API level 29.\n\n \\param parcel The parcel of which to set the position.\n \\param position Position of the parcel to set. This must be a value returned by\n AParcel_getDataPosition. Positions are constant for a given parcel between processes.\n\n \\return STATUS_OK on success. If position is negative, then STATUS_BAD_VALUE will be returned."]
    pub fn AParcel_setDataPosition(parcel: *const AParcel, position: i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the current position within the parcel.\n\n Available since API level 29.\n\n \\param parcel The parcel of which to get the position.\n\n \\return The size of the parcel. This will always be greater than 0. The values returned by this\n function before and after calling various reads and writes are not defined. Only the delta\n between two positions between a specific sequence of calls is defined. For instance, if position\n is X, writeBool is called, and then position is Y, readBool can be called from position X will\n return the same value, and then position will be Y."]
    pub fn AParcel_getDataPosition(parcel: *const AParcel) -> i32;
}
#[doc = " This is called to allocate a buffer for a C-style string (null-terminated). The returned buffer\n should be at least length bytes. This includes space for a null terminator. For a string, length\n will always be strictly less than or equal to the maximum size that can be held in a size_t and\n will always be greater than 0. However, if a 'null' string is being read, length will be -1.\n\n See also AParcel_readString.\n\n If allocation fails, null should be returned.\n\n \\param stringData some external representation of a string\n \\param length the length of the buffer needed to fill (including the null-terminator)\n \\param buffer a buffer of size 'length' or null if allocation failed.\n\n \\return true if the allocation succeeded, false otherwise. If length is -1, a true return here\n means that a 'null' value (or equivalent) was successfully stored."]
pub type AParcel_stringAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        stringData: *mut ::std::os::raw::c_void,
        length: i32,
        buffer: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " This is called to allocate an array of size 'length'. If length is -1, then a 'null' array (or\n equivalent) should be created.\n\n See also AParcel_readStringArray\n\n \\param arrayData some external representation of an array\n \\param length the length to allocate this array to\n\n \\return true if allocation succeeded. If length is -1, a true return here means that a 'null'\n value (or equivalent) was successfully stored."]
pub type AParcel_stringArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to allocate a string inside of an array that was allocated by an\n AParcel_stringArrayAllocator.\n\n The index returned will always be within the range [0, length of arrayData). The returned buffer\n should be at least length bytes. This includes space for a null-terminator. For a string, length\n will always be strictly less than or equal to the maximum size that can be held in a size_t and\n will always be greater than 0. However, if a 'null' string is being read, length will be -1.\n\n See also AParcel_readStringArray\n\n \\param arrayData some external representation of an array.\n \\param index the index at which a string should be allocated.\n \\param length the length of the string to be allocated at this index. See also\n AParcel_stringAllocator. This includes the length required for a null-terminator.\n \\param buffer a buffer of size 'length' or null if allocation failed.\n\n \\return true if the allocation succeeded, false otherwise. If length is -1, a true return here\n means that a 'null' value (or equivalent) was successfully stored."]
pub type AParcel_stringArrayElementAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        index: usize,
        length: i32,
        buffer: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " This returns the length and buffer of an array at a specific index in an arrayData object.\n\n See also AParcel_writeStringArray\n\n \\param arrayData some external representation of an array.\n \\param index the index at which a string should be allocated.\n \\param outLength an out parameter for the length of the string at the specified index. This\n should not include the length for a null-terminator if there is one. If the object at this index\n is 'null', then this should be set to -1.\n\n \\param a buffer of size outLength or more representing the string at the provided index. This is\n not required to be null-terminated. If the object at index is null, then this should be null."]
pub type AParcel_stringArrayElementGetter = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *const ::std::os::raw::c_void,
        index: usize,
        outLength: *mut i32,
    ) -> *const ::std::os::raw::c_char,
>;
#[doc = " This is called to allocate an array of size 'length'. If length is -1, then a 'null' array (or\n equivalent) should be created.\n\n See also AParcel_readParcelableArray\n\n \\param arrayData some external representation of an array\n \\param length the length to allocate this array to\n\n \\return true if allocation succeeded. If length is -1, a true return here means that a 'null'\n value (or equivalent) was successfully stored."]
pub type AParcel_parcelableArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to parcel the underlying data from an arrayData object at index.\n\n See also AParcel_writeParcelableArray\n\n \\param parcel parcel to write the parcelable to\n \\param arrayData some external representation of an array of parcelables (a user-defined type).\n \\param index the index of the value to be retrieved.\n\n \\return status (usually returned from other parceling functions). STATUS_OK for success."]
pub type AParcel_writeParcelableElement = ::std::option::Option<
    unsafe extern "C" fn(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        index: usize,
    ) -> binder_status_t,
>;
#[doc = " This is called to set an underlying value in an arrayData object at index.\n\n See also AParcel_readParcelableArray\n\n \\param parcel parcel to read the parcelable from\n \\param arrayData some external representation of an array of parcelables (a user-defined type).\n \\param index the index of the value to be set.\n\n \\return status (usually returned from other parceling functions). STATUS_OK for success."]
pub type AParcel_readParcelableElement = ::std::option::Option<
    unsafe extern "C" fn(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        index: usize,
    ) -> binder_status_t,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readInt32Array\n\n \\param arrayData some external representation of an array of int32_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of int32_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_int32ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readUint32Array\n\n \\param arrayData some external representation of an array of uint32_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of uint32_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_uint32ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readInt64Array\n\n \\param arrayData some external representation of an array of int64_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of int64_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_int64ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i64,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readUint64Array\n\n \\param arrayData some external representation of an array of uint64_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of uint64_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_uint64ArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u64,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readFloatArray\n\n \\param arrayData some external representation of an array of float.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of float of size 'length' (if length is >= 0, if length is 0, this may\n be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_floatArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut f32,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readDoubleArray\n\n \\param arrayData some external representation of an array of double.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of double of size 'length' (if length is >= 0, if length is 0, this may\n be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_doubleArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut f64,
    ) -> bool,
>;
#[doc = " This allocates an array of size 'length' inside of arrayData and returns whether or not there was\n a success. If length is -1, then this should allocate some representation of a null array.\n\n See also AParcel_readBoolArray\n\n \\param arrayData some external representation of an array of bool.\n \\param length the length to allocate arrayData to (or -1 if this represents a null array).\n\n \\return whether the allocation succeeded."]
pub type AParcel_boolArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, length: i32) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object at index.\n\n See also AParcel_writeBoolArray\n\n \\param arrayData some external representation of an array of bool.\n \\param index the index of the value to be retrieved.\n\n \\return the value of the array at index index."]
pub type AParcel_boolArrayGetter = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *const ::std::os::raw::c_void, index: usize) -> bool,
>;
#[doc = " This is called to set an underlying value in an arrayData object at index.\n\n See also AParcel_readBoolArray\n\n \\param arrayData some external representation of an array of bool.\n \\param index the index of the value to be set.\n \\param value the value to set at index index."]
pub type AParcel_boolArraySetter = ::std::option::Option<
    unsafe extern "C" fn(arrayData: *mut ::std::os::raw::c_void, index: usize, value: bool),
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readCharArray\n\n \\param arrayData some external representation of an array of char16_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of char16_t of size 'length' (if length is >= 0, if length is 0, this\n may be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_charArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut u16,
    ) -> bool,
>;
#[doc = " This is called to get the underlying data from an arrayData object.\n\n The implementation of this function should allocate a contiguous array of size 'length' and\n return that underlying buffer to be filled out. If there is an error or length is 0, null may be\n returned. If length is -1, this should allocate some representation of a null array.\n\n See also AParcel_readByteArray\n\n \\param arrayData some external representation of an array of int8_t.\n \\param length the length to allocate arrayData to.\n \\param outBuffer a buffer of int8_t of size 'length' (if length is >= 0, if length is 0, this may\n be nullptr).\n\n \\return whether or not the allocation was successful (or whether a null array is represented when\n length is -1)."]
pub type AParcel_byteArrayAllocator = ::std::option::Option<
    unsafe extern "C" fn(
        arrayData: *mut ::std::os::raw::c_void,
        length: i32,
        outBuffer: *mut *mut i8,
    ) -> bool,
>;
extern "C" {
    #[doc = " Writes an AIBinder to the next location in a non-null parcel. Can be null. This does not take any\n refcounts of ownership of the binder from the client.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param binder the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStrongBinder(
        parcel: *mut AParcel,
        binder: *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an AIBinder from the next location in a non-null parcel. One strong ref-count of ownership\n is passed to the caller of this function.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param binder the out parameter for what is read from the parcel. This may be null.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_readStrongBinder(
        parcel: *const AParcel,
        binder: *mut *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes a file descriptor to the next location in a non-null parcel. This does not take ownership\n of fd.\n\n This corresponds to the SDK's android.os.ParcelFileDescriptor.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param fd the value to write to the parcel (-1 to represent a null ParcelFileDescriptor).\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeParcelFileDescriptor(
        parcel: *mut AParcel,
        fd: ::std::os::raw::c_int,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an int from the next location in a non-null parcel.\n\n The returned fd must be closed.\n\n This corresponds to the SDK's android.os.ParcelFileDescriptor.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param fd the out parameter for what is read from the parcel (or -1 to represent a null\n ParcelFileDescriptor)\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_readParcelFileDescriptor(
        parcel: *const AParcel,
        fd: *mut ::std::os::raw::c_int,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an AStatus object to the next location in a non-null parcel.\n\n If the status is considered to be a low-level status and has no additional information other\n than a binder_status_t (for instance, if it is created with AStatus_fromStatus), then that\n status will be returned from this method and nothing will be written to the parcel. If either\n this happens or if writing the status object itself fails, the return value from this function\n should be propagated to the client, and AParcel_readStatusHeader shouldn't be called.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param status the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStatusHeader(
        parcel: *mut AParcel,
        status: *const AStatus,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an AStatus from the next location in a non-null parcel. Ownership is passed to the caller\n of this function.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param status the out parameter for what is read from the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_readStatusHeader(
        parcel: *const AParcel,
        status: *mut *mut AStatus,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes utf-8 string value to the next location in a non-null parcel.\n\n If length is -1, and string is nullptr, this will write a 'null' string to the parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param string the null-terminated string to write to the parcel, at least of size 'length'.\n \\param length the length of the string to be written.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeString(
        parcel: *mut AParcel,
        string: *const ::std::os::raw::c_char,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads and allocates utf-8 string value from the next location in a non-null parcel.\n\n Data is passed to the string allocator once the string size is known. This size includes the\n space for the null-terminator of this string. This allocator returns a buffer which is used as\n the output buffer from this read. If there is a 'null' string on the binder buffer, the allocator\n will be called with length -1.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param stringData some external representation of a string.\n \\param allocator allocator that will be called once the size of the string is known.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_readString(
        parcel: *const AParcel,
        stringData: *mut ::std::os::raw::c_void,
        allocator: AParcel_stringAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes utf-8 string array data to the next location in a non-null parcel.\n\n length is the length of the array. AParcel_stringArrayElementGetter will be called for all\n indices in range [0, length) with the arrayData provided here. The string length and buffer\n returned from this function will be used to fill out the data from the parcel. If length is -1,\n this will write a 'null' string array to the binder buffer.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData some external representation of an array.\n \\param length the length of the array to be written.\n \\param getter the callback that will be called for every index of the array to retrieve the\n corresponding string buffer.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeStringArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        getter: AParcel_stringArrayElementGetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads and allocates utf-8 string array value from the next location in a non-null parcel.\n\n First, AParcel_stringArrayAllocator will be called with the size of the array to be read where\n length is the length of the array to be read from the parcel. Then, for each index i in [0,\n length), AParcel_stringArrayElementAllocator will be called with the length of the string to be\n read from the parcel. The resultant buffer from each of these calls will be filled according to\n the contents of the string that is read. If the string array being read is 'null', this will\n instead just pass -1 to AParcel_stringArrayAllocator.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called with arrayData once the size of the output\n array is known.\n \\param elementAllocator the callback that will be called on every index of arrayData to allocate\n the string at that location.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readStringArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_stringArrayAllocator,
        elementAllocator: AParcel_stringArrayElementAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of parcelables (user-defined types) to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n \\param elementWriter function to be called for every array index to write the user-defined type\n at that location.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeParcelableArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        elementWriter: AParcel_writeParcelableElement,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of parcelables (user-defined types) from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, elementReader will be called for every index to read the\n corresponding parcelable.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n \\param elementReader the callback that will be called to fill out individual elements.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readParcelableArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_parcelableArrayAllocator,
        elementReader: AParcel_readParcelableElement,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int32_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt32(parcel: *mut AParcel, value: i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes uint32_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint32(parcel: *mut AParcel, value: u32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int64_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt64(parcel: *mut AParcel, value: i64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes uint64_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint64(parcel: *mut AParcel, value: u64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes float value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeFloat(parcel: *mut AParcel, value: f32) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes double value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeDouble(parcel: *mut AParcel, value: f64) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes bool value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeBool(parcel: *mut AParcel, value: bool) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes char16_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeChar(parcel: *mut AParcel, value: u16) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes int8_t value to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param value the value to write to the parcel.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeByte(parcel: *mut AParcel, value: i8) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int32_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt32(parcel: *const AParcel, value: *mut i32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into uint32_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint32(parcel: *const AParcel, value: *mut u32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int64_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt64(parcel: *const AParcel, value: *mut i64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into uint64_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint64(parcel: *const AParcel, value: *mut u64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into float value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readFloat(parcel: *const AParcel, value: *mut f32) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into double value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readDouble(parcel: *const AParcel, value: *mut f64) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into bool value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readBool(parcel: *const AParcel, value: *mut bool) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into char16_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readChar(parcel: *const AParcel, value: *mut u16) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads into int8_t value from the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param value the value to read from the parcel.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readByte(parcel: *const AParcel, value: *mut i8) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int32_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt32Array(
        parcel: *mut AParcel,
        arrayData: *const i32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of uint32_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint32Array(
        parcel: *mut AParcel,
        arrayData: *const u32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int64_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeInt64Array(
        parcel: *mut AParcel,
        arrayData: *const i64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of uint64_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeUint64Array(
        parcel: *mut AParcel,
        arrayData: *const u64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of float to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeFloatArray(
        parcel: *mut AParcel,
        arrayData: *const f32,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of double to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeDoubleArray(
        parcel: *mut AParcel,
        arrayData: *const f64,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of bool to the next location in a non-null parcel.\n\n getter(arrayData, i) will be called for each i in [0, length) in order to get the underlying\n values to write to the parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData some external representation of an array.\n \\param length the length of arrayData (or -1 if this represents a null array).\n \\param getter the callback to retrieve data at specific locations in the array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeBoolArray(
        parcel: *mut AParcel,
        arrayData: *const ::std::os::raw::c_void,
        length: i32,
        getter: AParcel_boolArrayGetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of char16_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeCharArray(
        parcel: *mut AParcel,
        arrayData: *const u16,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Writes an array of int8_t to the next location in a non-null parcel.\n\n Available since API level 29.\n\n \\param parcel the parcel to write to.\n \\param arrayData an array of size 'length' (or null if length is -1, may be null if length is 0).\n \\param length the length of arrayData or -1 if this represents a null array.\n\n \\return STATUS_OK on successful write."]
    pub fn AParcel_writeByteArray(
        parcel: *mut AParcel,
        arrayData: *const i8,
        length: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int32_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt32Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_int32ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of uint32_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint32Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_uint32ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int64_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readInt64Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_int64ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of uint64_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readUint64Array(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_uint64ArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of float from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readFloatArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_floatArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of double from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readDoubleArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_doubleArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of bool from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. Then, for every i in [0, length),\n setter(arrayData, i, x) will be called where x is the value at the associated index.\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n \\param setter the callback that will be called to set a value at a specific location in the\n array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readBoolArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_boolArrayAllocator,
        setter: AParcel_boolArraySetter,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of char16_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readCharArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_charArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reads an array of int8_t from the next location in a non-null parcel.\n\n First, allocator will be called with the length of the array. If the allocation succeeds and the\n length is greater than zero, the buffer returned by the allocator will be filled with the\n corresponding data\n\n Available since API level 29.\n\n \\param parcel the parcel to read from.\n \\param arrayData some external representation of an array.\n \\param allocator the callback that will be called to allocate the array.\n\n \\return STATUS_OK on successful read."]
    pub fn AParcel_readByteArray(
        parcel: *const AParcel,
        arrayData: *mut ::std::os::raw::c_void,
        allocator: AParcel_byteArrayAllocator,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Reset the parcel to the initial status.\n\n Available since API level 31.\n\n \\param parcel The parcel of which to be reset.\n\n \\return STATUS_OK on success."]
    pub fn AParcel_reset(parcel: *mut AParcel) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the size of the parcel.\n\n Available since API level 31.\n\n \\param parcel The parcel of which to get the size.\n\n \\return The size of the parcel."]
    pub fn AParcel_getDataSize(parcel: *const AParcel) -> i32;
}
extern "C" {
    #[doc = " Copy the data of a parcel to other parcel.\n\n Available since API level 31.\n\n \\param from The source\n \\param to The detination\n \\param start The position where the copied data starts.\n \\param size The amount of data which will be copied.\n\n \\return STATUS_OK on success."]
    pub fn AParcel_appendFrom(
        from: *const AParcel,
        to: *mut AParcel,
        start: i32,
        size: i32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Creates a parcel.\n\n Available since API level 31.\n\n \\return A parcel which is not related to any IBinder objects."]
    pub fn AParcel_create() -> *mut AParcel;
}
extern "C" {
    #[doc = " Marshals the raw bytes of the Parcel to a buffer.\n\n Available since API level 33.\n\n The parcel must not contain any binders or file descriptors.\n\n The data you retrieve here must not be placed in any kind of persistent storage. (on local disk,\n across a network, etc). For that, you should use standard serialization or another kind of\n general serialization mechanism. The Parcel marshalled representation is highly optimized for\n local IPC, and as such does not attempt to maintain compatibility with data created in different\n versions of the platform.\n\n \\param parcel The parcel of which to get the data.\n \\param buffer The buffer to copy the raw bytes to.\n \\param start The start position in the buffer to copy from.\n \\param len The size of the data to copy, buffer size must be larger or equal to this.\n\n \\return STATUS_OK on success, STATUS_INVALID_OPERATION if parcel contains binders or file\n descriptors. STATUS_BAD_VALUE if the buffer size is less than parcel size."]
    pub fn AParcel_marshal(
        parcel: *const AParcel,
        buffer: *mut u8,
        start: usize,
        len: usize,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Set the data in the parcel to the raw bytes from the buffer.\n\n Available since API level 33.\n\n \\param parcel The parcel to set data.\n \\param buffer The data buffer to set.\n \\param len The size of the data to set.\n\n \\return STATUS_OK on success."]
    pub fn AParcel_unmarshal(
        parcel: *mut AParcel,
        buffer: *const u8,
        len: usize,
    ) -> binder_status_t;
}
#[doc = " Flags for AIBinder_transact."]
pub type binder_flags_t = u32;
#[doc = " Codes for AIBinder_transact. This defines the range of codes available for\n usage. Other codes are used or reserved by the Android system."]
pub type transaction_code_t = u32;
#[doc = " Represents a type of AIBinder object which can be sent out."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_Class {
    _unused: [u8; 0],
}
#[doc = " The AIBinder object associated with this can be retrieved if it is still alive so that it can be\n re-used. The intention of this is to enable the same AIBinder object to always represent the same\n object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_Weak {
    _unused: [u8; 0],
}
#[doc = " Represents a handle on a death notification. See AIBinder_linkToDeath/AIBinder_unlinkToDeath."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AIBinder_DeathRecipient {
    _unused: [u8; 0],
}
#[doc = " This is called whenever a new AIBinder object is needed of a specific class.\n\n \\param args these can be used to construct a new class. These are passed from AIBinder_new.\n \\return this is the userdata representing the class. It can be retrieved using\n AIBinder_getUserData."]
pub type AIBinder_Class_onCreate = ::std::option::Option<
    unsafe extern "C" fn(args: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = " This is called whenever an AIBinder object is no longer referenced and needs destroyed.\n\n Typically, this just deletes whatever the implementation is.\n\n \\param userData this is the same object returned by AIBinder_Class_onCreate"]
pub type AIBinder_Class_onDestroy =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[doc = " This is called whenever a transaction needs to be processed by a local implementation.\n\n This method will be called after the equivalent of\n android.os.Parcel#enforceInterface is called. That is, the interface\n descriptor associated with the AIBinder_Class descriptor will already be\n checked.\n\n \\param binder the object being transacted on.\n \\param code implementation-specific code representing which transaction should be taken.\n \\param in the implementation-specific input data to this transaction.\n \\param out the implementation-specific output data to this transaction.\n\n \\return the implementation-specific output code. This may be forwarded from another service, the\n result of a parcel read or write, or another error as is applicable to the specific\n implementation. Usually, implementation-specific error codes are written to the output parcel,\n and the transaction code is reserved for kernel errors or error codes that have been repeated\n from subsequent transactions."]
pub type AIBinder_Class_onTransact = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        code: transaction_code_t,
        in_: *const AParcel,
        out: *mut AParcel,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This creates a new instance of a class of binders which can be instantiated. This is called one\n time during library initialization and cleaned up when the process exits or execs.\n\n None of these parameters can be null.\n\n Available since API level 29.\n\n \\param interfaceDescriptor this is a unique identifier for the class. This is used internally for\n validity checks on transactions. This should be utf-8.\n \\param onCreate see AIBinder_Class_onCreate.\n \\param onDestroy see AIBinder_Class_onDestroy.\n \\param onTransact see AIBinder_Class_onTransact.\n\n \\return the class object representing these parameters or null on error."]
    pub fn AIBinder_Class_define(
        interfaceDescriptor: *const ::std::os::raw::c_char,
        onCreate: AIBinder_Class_onCreate,
        onDestroy: AIBinder_Class_onDestroy,
        onTransact: AIBinder_Class_onTransact,
    ) -> *mut AIBinder_Class;
}
#[doc = " Dump information about an AIBinder (usually for debugging).\n\n When no arguments are provided, a brief overview of the interview should be given.\n\n \\param binder interface being dumped\n \\param fd file descriptor to be dumped to, should be flushed, ownership is not passed.\n \\param args array of null-terminated strings for dump (may be null if numArgs is 0)\n \\param numArgs number of args to be sent\n\n \\return binder_status_t result of transaction (if remote, for instance)"]
pub type AIBinder_onDump = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        fd: ::std::os::raw::c_int,
        args: *mut *const ::std::os::raw::c_char,
        numArgs: u32,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This sets the implementation of the dump method for a class.\n\n If this isn't set, nothing will be dumped when dump is called (for instance with\n android.os.Binder#dump). Must be called before any instance of the class is created.\n\n Available since API level 29.\n\n \\param clazz class which should use this dump function\n \\param onDump function to call when an instance of this binder class is being dumped."]
    pub fn AIBinder_Class_setOnDump(clazz: *mut AIBinder_Class, onDump: AIBinder_onDump);
}
extern "C" {
    #[doc = " Associates a mapping of transaction codes(transaction_code_t) to function names for the given\n class.\n\n Trace messages will use the provided names instead of bare integer codes when set. If not set by\n this function, trace messages will only be identified by the bare code. This should be called one\n time during clazz initialization. clazz is defined using AIBinder_Class_define and\n transactionCodeToFunctionMap should have same scope as clazz. Resetting/clearing the\n transactionCodeToFunctionMap is not allowed. Passing null for either clazz or\n transactionCodeToFunctionMap will abort.\n\n Available since API level 36.\n\n \\param clazz class which should use this transaction to code function map.\n \\param transactionCodeToFunctionMap array of function names indexed by transaction code.\n Transaction codes start from 1, functions with transaction code 1 will correspond to index 0 in\n transactionCodeToFunctionMap. When defining methods, transaction codes are expected to be\n contiguous, and this is required for maximum memory efficiency.\n You can use nullptr if certain transaction codes are not used. Lifetime should be same as clazz.\n \\param length number of elements in the transactionCodeToFunctionMap"]
    pub fn AIBinder_Class_setTransactionCodeToFunctionNameMap(
        clazz: *mut AIBinder_Class,
        transactionCodeToFunctionMap: *mut *const ::std::os::raw::c_char,
        length: usize,
    );
}
extern "C" {
    #[doc = " Get function name associated with transaction code for given class\n\n This function returns function name associated with provided transaction code for given class.\n AIBinder_Class_setTransactionCodeToFunctionNameMap should be called first to associate function\n to transaction code mapping.\n\n Available since API level 36.\n\n \\param clazz class for which function name is requested\n \\param transactionCode transaction_code_t for which function name is requested.\n\n \\return function name in form of const char* if transaction code is valid for given class.\n The value returned is valid for the lifetime of clazz. if transaction code is invalid or\n transactionCodeToFunctionMap is not set, nullptr is returned."]
    pub fn AIBinder_Class_getFunctionName(
        clazz: *mut AIBinder_Class,
        code: transaction_code_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This tells users of this class not to use a transaction header. By default, libbinder_ndk users\n read/write transaction headers implicitly (in the SDK, this must be manually written by\n android.os.Parcel#writeInterfaceToken, and it is read/checked with\n android.os.Parcel#enforceInterface). This method is provided in order to talk to legacy code\n which does not write an interface token. When this is disabled, type safety is reduced, so you\n must have a separate way of determining the binder you are talking to is the right type. Must\n be called before any instance of the class is created.\n\n Available since API level 33.\n\n WARNING: this API interacts badly with linkernamespaces. For correct behavior, you must\n use it on all instances of a class in the same process which share the same interface\n descriptor. In general, it is recommended you do not use this API, because it is disabling\n type safety.\n\n \\param clazz class to disable interface header on."]
    pub fn AIBinder_Class_disableInterfaceTokenHeader(clazz: *mut AIBinder_Class);
}
extern "C" {
    #[doc = " Creates a new binder object of the appropriate class.\n\n Ownership of args is passed to this object. The lifecycle is implemented with AIBinder_incStrong\n and AIBinder_decStrong. When the reference count reaches zero, onDestroy is called.\n\n When this is called, the refcount is implicitly 1. So, calling decStrong exactly one time is\n required to delete this object.\n\n Once an AIBinder object is created using this API, re-creating that AIBinder for the same\n instance of the same class will break pointer equality for that specific AIBinder object. For\n instance, if someone erroneously created two AIBinder instances representing the same callback\n object and passed one to a hypothetical addCallback function and then later another one to a\n hypothetical removeCallback function, the remote process would have no way to determine that\n these two objects are actually equal using the AIBinder pointer alone (which they should be able\n to do). Also see the suggested memory ownership model suggested above.\n\n Available since API level 29.\n\n \\param clazz the type of the object to be created.\n \\param args the args to pass to AIBinder_onCreate for that class.\n\n \\return a binder object representing the newly instantiated object."]
    pub fn AIBinder_new(
        clazz: *const AIBinder_Class,
        args: *mut ::std::os::raw::c_void,
    ) -> *mut AIBinder;
}
extern "C" {
    #[doc = " If this is hosted in a process other than the current one.\n\n Available since API level 29.\n\n \\param binder the binder being queried.\n\n \\return true if the AIBinder represents an object in another process."]
    pub fn AIBinder_isRemote(binder: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " If this binder is known to be alive. This will not send a transaction to a remote process and\n returns a result based on the last known information. That is, whenever a transaction is made,\n this is automatically updated to reflect the current alive status of this binder. This will be\n updated as the result of a transaction made using AIBinder_transact, but it will also be updated\n based on the results of bookkeeping or other transactions made internally.\n\n Available since API level 29.\n\n \\param binder the binder being queried.\n\n \\return true if the binder is alive."]
    pub fn AIBinder_isAlive(binder: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " Built-in transaction for all binder objects. This sends a transaction that will immediately\n return. Usually this is used to make sure that a binder is alive, as a placeholder call, or as a\n consistency check.\n\n Available since API level 29.\n\n \\param binder the binder being queried.\n\n \\return STATUS_OK if the ping succeeds."]
    pub fn AIBinder_ping(binder: *mut AIBinder) -> binder_status_t;
}
extern "C" {
    #[doc = " Built-in transaction for all binder objects. This dumps information about a given binder.\n\n See also AIBinder_Class_setOnDump, AIBinder_onDump.\n\n Available since API level 29.\n\n \\param binder the binder to dump information about\n \\param fd where information should be dumped to\n \\param args null-terminated arguments to pass (may be null if numArgs is 0)\n \\param numArgs number of args to send\n\n \\return STATUS_OK if dump succeeds (or if there is nothing to dump)"]
    pub fn AIBinder_dump(
        binder: *mut AIBinder,
        fd: ::std::os::raw::c_int,
        args: *mut *const ::std::os::raw::c_char,
        numArgs: u32,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Registers for notifications that the associated binder is dead. The same death recipient may be\n associated with multiple different binders. If the binder is local, then no death recipient will\n be given (since if the local process dies, then no recipient will exist to receive a\n transaction). The cookie is passed to recipient in the case that this binder dies and can be\n null. The exact cookie must also be used to unlink this transaction (see AIBinder_unlinkToDeath).\n This function may return a binder transaction failure. The cookie can be used both for\n identification and holding user data.\n\n If binder is local, this will return STATUS_INVALID_OPERATION.\n\n Available since API level 29.\n\n \\param binder the binder object you want to receive death notifications from.\n \\param recipient the callback that will receive notifications when/if the binder dies.\n \\param cookie the value that will be passed to the death recipient on death.\n\n \\return STATUS_OK on success."]
    pub fn AIBinder_linkToDeath(
        binder: *mut AIBinder,
        recipient: *mut AIBinder_DeathRecipient,
        cookie: *mut ::std::os::raw::c_void,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Stops registration for the associated binder dying. Does not delete the recipient. This function\n may return a binder transaction failure and in case the death recipient cannot be found, it\n returns STATUS_NAME_NOT_FOUND.\n\n This only ever needs to be called when the AIBinder_DeathRecipient remains for use with other\n AIBinder objects. If the death recipient is deleted, all binders will automatically be unlinked.\n If the binder dies, it will automatically unlink. If the binder is deleted, it will be\n automatically unlinked.\n\n Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you\n need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using\n AIBinder_DeathRecipient_setOnUnlinked.\n\n Available since API level 29.\n\n \\param binder the binder object to remove a previously linked death recipient from.\n \\param recipient the callback to remove.\n \\param cookie the cookie used to link to death.\n\n \\return STATUS_OK on success. STATUS_NAME_NOT_FOUND if the binder cannot be found to be unlinked."]
    pub fn AIBinder_unlinkToDeath(
        binder: *mut AIBinder,
        recipient: *mut AIBinder_DeathRecipient,
        cookie: *mut ::std::os::raw::c_void,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " This returns the calling UID assuming that this thread is called from a thread that is processing\n a binder transaction (for instance, in the implementation of AIBinder_Class_onTransact).\n\n This can be used with higher-level system services to determine the caller's identity and check\n permissions.\n\n Available since API level 29.\n\n \\return calling uid or the current process's UID if this thread isn't processing a transaction."]
    pub fn AIBinder_getCallingUid() -> uid_t;
}
extern "C" {
    #[doc = " This returns the calling PID assuming that this thread is called from a thread that is processing\n a binder transaction (for instance, in the implementation of AIBinder_Class_onTransact).\n\n This can be used with higher-level system services to determine the caller's identity and check\n permissions. However, when doing this, one should be aware of possible TOCTOU problems when the\n calling process dies and is replaced with another process with elevated permissions and the same\n PID.\n\n Warning: oneway transactions do not receive PID. Even if you expect\n a transaction to be synchronous, a misbehaving client could send it\n as a synchronous call and result in a 0 PID here. Additionally, if\n there is a race and the calling process dies, the PID may still be\n 0 for a synchronous call.\n\n Available since API level 29.\n\n \\return calling pid or the current process's PID if this thread isn't processing a transaction.\n If the transaction being processed is a oneway transaction, then this method will return 0."]
    pub fn AIBinder_getCallingPid() -> pid_t;
}
extern "C" {
    #[doc = " Determine whether the current thread is currently executing an incoming transaction.\n\n \\return true if the current thread is currently executing an incoming transaction, and false\n otherwise."]
    pub fn AIBinder_isHandlingTransaction() -> bool;
}
extern "C" {
    #[doc = " This can only be called if a strong reference to this object already exists in process.\n\n Available since API level 29.\n\n \\param binder the binder object to add a refcount to."]
    pub fn AIBinder_incStrong(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " This will delete the object and call onDestroy once the refcount reaches zero.\n\n Available since API level 29.\n\n \\param binder the binder object to remove a refcount from."]
    pub fn AIBinder_decStrong(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " For debugging only!\n\n Available since API level 29.\n\n \\param binder the binder object to retrieve the refcount of.\n\n \\return the number of strong-refs on this binder in this process. If binder is null, this will be\n -1."]
    pub fn AIBinder_debugGetRefCount(binder: *mut AIBinder) -> i32;
}
extern "C" {
    #[doc = " This sets the class of an AIBinder object. This checks to make sure the remote object is of\n the expected class. A class must be set in order to use transactions on an AIBinder object.\n However, if an object is just intended to be passed through to another process or used as a\n handle this need not be called.\n\n This returns true if the class association succeeds. If it fails, no change is made to the\n binder object.\n\n Warning: this may fail if the binder is dead.\n\n Available since API level 29.\n\n \\param binder the object to attach the class to.\n \\param clazz the clazz to attach to binder.\n\n \\return true if the binder has the class clazz and if the association was successful."]
    pub fn AIBinder_associateClass(binder: *mut AIBinder, clazz: *const AIBinder_Class) -> bool;
}
extern "C" {
    #[doc = " Returns the class that this binder was constructed with or associated with.\n\n Available since API level 29.\n\n \\param binder the object that is being queried.\n\n \\return the class that this binder is associated with. If this binder wasn't created with\n AIBinder_new, and AIBinder_associateClass hasn't been called, then this will return null."]
    pub fn AIBinder_getClass(binder: *mut AIBinder) -> *const AIBinder_Class;
}
extern "C" {
    #[doc = " Value returned by onCreate for a local binder. For stateless classes (if onCreate returns\n null), this also returns null. For a remote binder, this will always return null.\n\n Available since API level 29.\n\n \\param binder the object that is being queried.\n\n \\return the userdata returned from AIBinder_onCreate when this object was created. This may be\n null for stateless objects. For remote objects, this is always null."]
    pub fn AIBinder_getUserData(binder: *mut AIBinder) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Creates a parcel to start filling out for a transaction. This will add a header to the\n transaction that corresponds to android.os.Parcel#writeInterfaceToken. This may add debugging\n or other information to the transaction for platform use or to enable other features to work. The\n contents of this header is a platform implementation detail, and it is required to use\n libbinder_ndk. This parcel is to be sent via AIBinder_transact and it represents the input data\n to the transaction. It is recommended to check if the object is local and call directly into its\n user data before calling this as the parceling and unparceling cost can be avoided. This AIBinder\n must be either built with a class or associated with a class before using this API.\n\n This does not affect the ownership of binder. When this function succeeds, the in parcel's\n ownership is passed to the caller. At this point, the parcel can be filled out and passed to\n AIBinder_transact. Alternatively, if there is an error while filling out the parcel, it can be\n deleted with AParcel_delete.\n\n Available since API level 29.\n\n \\param binder the binder object to start a transaction on.\n \\param in out parameter for input data to the transaction.\n\n \\return STATUS_OK on success. This will return STATUS_INVALID_OPERATION if the binder has not yet\n been associated with a class (see AIBinder_new and AIBinder_associateClass)."]
    pub fn AIBinder_prepareTransaction(
        binder: *mut AIBinder,
        in_: *mut *mut AParcel,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Transact using a parcel created from AIBinder_prepareTransaction. This actually communicates with\n the object representing this binder object. This also passes out a parcel to be used for the\n return transaction. This takes ownership of the in parcel and automatically deletes it after it\n is sent to the remote process. The output parcel is the result of the transaction. If the\n transaction has FLAG_ONEWAY, the out parcel will be empty. Otherwise, this will block until the\n remote process has processed the transaction, and the out parcel will contain the output data\n from transaction.\n\n This does not affect the ownership of binder. The out parcel's ownership is passed to the caller\n and must be released with AParcel_delete when finished reading.\n\n Available since API level 29.\n\n \\param binder the binder object to transact on.\n \\param code the implementation-specific code representing which transaction should be taken.\n \\param in the implementation-specific input data to this transaction.\n \\param out the implementation-specific output data to this transaction.\n \\param flags possible flags to alter the way in which the transaction is conducted or 0.\n\n \\return the result from the kernel or from the remote process. Usually, implementation-specific\n error codes are written to the output parcel, and the transaction code is reserved for kernel\n errors or error codes that have been repeated from subsequent transactions."]
    pub fn AIBinder_transact(
        binder: *mut AIBinder,
        code: transaction_code_t,
        in_: *mut *mut AParcel,
        out: *mut *mut AParcel,
        flags: binder_flags_t,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " This does not take any ownership of the input binder, but it can be used to retrieve it if\n something else in some process still holds a reference to it.\n\n Available since API level 29.\n\n \\param binder object to create a weak pointer to.\n\n \\return object representing a weak pointer to binder (or null if binder is null)."]
    pub fn AIBinder_Weak_new(binder: *mut AIBinder) -> *mut AIBinder_Weak;
}
extern "C" {
    #[doc = " Deletes the weak reference. This will have no impact on the lifetime of the binder.\n\n Available since API level 29.\n\n \\param weakBinder object created with AIBinder_Weak_new."]
    pub fn AIBinder_Weak_delete(weakBinder: *mut AIBinder_Weak);
}
extern "C" {
    #[doc = " If promotion succeeds, result will have one strong refcount added to it. Otherwise, this returns\n null.\n\n Available since API level 29.\n\n \\param weakBinder weak pointer to attempt retrieving the original object from.\n\n \\return an AIBinder object with one refcount given to the caller or null."]
    pub fn AIBinder_Weak_promote(weakBinder: *mut AIBinder_Weak) -> *mut AIBinder;
}
#[doc = " This function is executed on death receipt. See AIBinder_linkToDeath/AIBinder_unlinkToDeath.\n\n Available since API level 29.\n\n \\param cookie the cookie passed to AIBinder_linkToDeath."]
pub type AIBinder_DeathRecipient_onBinderDied =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
#[doc = " This function is intended for cleaning up the data in the provided cookie, and it is executed\n when the DeathRecipient is unlinked. When the DeathRecipient is unlinked due to a death receipt,\n this method is called after the call to onBinderDied.\n\n This method is called once for each binder that is unlinked. Hence, if the same cookie is passed\n to multiple binders, then the caller is responsible for reference counting the cookie.\n\n See also AIBinder_linkToDeath/AIBinder_unlinkToDeath.\n\n WARNING: Make sure the lifetime of this cookie is long enough. If it is dynamically\n allocated, it should be deleted with AIBinder_DeathRecipient_setOnUnlinked.\n\n Available since API level 33.\n\n \\param cookie the cookie passed to AIBinder_linkToDeath."]
pub type AIBinder_DeathRecipient_onBinderUnlinked =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Creates a new binder death recipient. This can be attached to multiple different binder objects.\n\n Available since API level 29.\n\n WARNING: Make sure the lifetime of this cookie is long enough. If it is dynamically\n allocated, it should be deleted with AIBinder_DeathRecipient_setOnUnlinked.\n\n \\param onBinderDied the callback to call when this death recipient is invoked.\n\n \\return the newly constructed object (or null if onBinderDied is null)."]
    pub fn AIBinder_DeathRecipient_new(
        onBinderDied: AIBinder_DeathRecipient_onBinderDied,
    ) -> *mut AIBinder_DeathRecipient;
}
extern "C" {
    #[doc = " Set the callback to be called when this DeathRecipient is unlinked from a binder. The callback is\n called in the following situations:\n\n  1. If the binder died, shortly after the call to onBinderDied.\n  2. If the binder is explicitly unlinked with AIBinder_unlinkToDeath or\n     AIBinder_DeathRecipient_delete, after any pending onBinderDied calls\n     finish.\n  3. During or shortly after the AIBinder_linkToDeath call if it returns an error.\n\n It is guaranteed that the callback is called exactly once for each call to linkToDeath unless the\n process is aborted before the binder is unlinked.\n\n Be aware that when the binder is explicitly unlinked, it is not guaranteed that onUnlinked has\n been called before the call to AIBinder_unlinkToDeath or AIBinder_DeathRecipient_delete returns.\n For example, if the binder dies concurrently with a call to AIBinder_unlinkToDeath, the binder is\n not unlinked until after the death notification is delivered, even if AIBinder_unlinkToDeath\n returns before that happens.\n\n This method should be called before linking the DeathRecipient to a binder because the function\n pointer is cached. If you change it after linking to a binder, it is unspecified whether the old\n binder will call the old or new onUnlinked callback.\n\n The onUnlinked argument may be null. In this case, no notification is given when the binder is\n unlinked.\n\n Available since API level 33.\n\n \\param recipient the DeathRecipient to set the onUnlinked callback for.\n \\param onUnlinked the callback to call when a binder is unlinked from recipient."]
    pub fn AIBinder_DeathRecipient_setOnUnlinked(
        recipient: *mut AIBinder_DeathRecipient,
        onUnlinked: AIBinder_DeathRecipient_onBinderUnlinked,
    );
}
extern "C" {
    #[doc = " Deletes a binder death recipient. It is not necessary to call AIBinder_unlinkToDeath before\n calling this as these will all be automatically unlinked.\n\n Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you\n need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using\n AIBinder_DeathRecipient_setOnUnlinked.\n\n Available since API level 29.\n\n \\param recipient the binder to delete (previously created with AIBinder_DeathRecipient_new)."]
    pub fn AIBinder_DeathRecipient_delete(recipient: *mut AIBinder_DeathRecipient);
}
extern "C" {
    #[doc = " Gets the extension registered with AIBinder_setExtension.\n\n See AIBinder_setExtension.\n\n Available since API level 30.\n\n \\param binder the object to get the extension of.\n \\param outExt the returned extension object. Will be null if there is no extension set or\n non-null with one strong ref count.\n\n \\return error of getting the interface (may be a transaction error if this is\n remote binder). STATUS_UNEXPECTED_NULL if binder is null."]
    pub fn AIBinder_getExtension(
        binder: *mut AIBinder,
        outExt: *mut *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets the extension of a binder interface. This allows a downstream developer to add\n an extension to an interface without modifying its interface file. This should be\n called immediately when the object is created before it is passed to another thread.\n No thread safety is required.\n\n For instance, imagine if we have this interface:\n     interface IFoo { void doFoo(); }\n\n A). Historical option that has proven to be BAD! Only the original\n     author of an interface should change an interface. If someone\n     downstream wants additional functionality, they should not ever\n     change the interface or use this method.\n\n    BAD TO DO:  interface IFoo {                       BAD TO DO\n    BAD TO DO:      void doFoo();                      BAD TO DO\n    BAD TO DO: +    void doBar(); // adding a method   BAD TO DO\n    BAD TO DO:  }                                      BAD TO DO\n\n B). Option that this method enables.\n     Leave the original interface unchanged (do not change IFoo!).\n     Instead, create a new interface in a downstream package:\n\n         package com.<name>; // new functionality in a new package\n         interface IBar { void doBar(); }\n\n     When registering the interface, add:\n         std::shared_ptr<MyFoo> foo = new MyFoo; // class in AOSP codebase\n         std::shared_ptr<MyBar> bar = new MyBar; // custom extension class\n         SpAIBinder binder = foo->asBinder(); // target binder to extend\n         ... = AIBinder_setExtension(binder.get(), bar->asBinder().get());\n         ... = AServiceManager_addService(binder.get(), instanceName);\n         // handle error\n\n         Do not use foo->asBinder().get() as the target binder argument to\n         AIBinder_setExtensions because asBinder it creates a new binder\n         object that will be destroyed after the function is called. The same\n         binder object must be used for AIBinder_setExtension and\n         AServiceManager_addService to register the service with an extension.\n\n     Then, clients of IFoo can get this extension:\n         SpAIBinder binder = ...;\n         std::shared_ptr<IFoo> foo = IFoo::fromBinder(binder); // handle if null\n         SpAIBinder barBinder;\n         ... = AIBinder_getExtension(barBinder.get());\n         // handle error\n         std::shared_ptr<IBar> bar = IBar::fromBinder(barBinder);\n         // type is checked with AIBinder_associateClass\n         // if bar is null, then there is no extension or a different\n         // type of extension\n\n Available since API level 30.\n\n \\param binder the object to get the extension on. Must be local.\n \\param ext the extension to set (binder will hold a strong reference to this)\n\n \\return OK on success, STATUS_INVALID_OPERATION if binder is not local, STATUS_UNEXPECTED_NULL\n if either binder is null."]
    pub fn AIBinder_setExtension(binder: *mut AIBinder, ext: *mut AIBinder) -> binder_status_t;
}
extern "C" {
    #[doc = " Retrieve the class descriptor for the class.\n\n Available since API level 31.\n\n \\param clazz the class to fetch the descriptor from\n\n \\return the class descriptor string. This pointer will never be null; a\n descriptor is required to define a class. The pointer is owned by the class\n and will remain valid as long as the class does. For a local class, this will\n be the same value (not necessarily pointer equal) as is passed into\n AIBinder_Class_define. Format is utf-8."]
    pub fn AIBinder_Class_getDescriptor(
        clazz: *const AIBinder_Class,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Whether AIBinder is less than another.\n\n This provides a per-process-unique total ordering of binders where a null\n AIBinder* object is considered to be before all other binder objects.\n For instance, two binders refer to the same object in a local or remote\n process when both AIBinder_lt(a, b) and AIBinder_lt(b, a) are false. This API\n might be used to insert and lookup binders in binary search trees.\n\n AIBinder* pointers themselves actually also create a per-process-unique total\n ordering. However, this ordering is inconsistent with AIBinder_Weak_lt for\n remote binders. So, in general, this function should be preferred.\n\n Available since API level 31.\n\n \\param lhs comparison object\n \\param rhs comparison object\n\n \\return whether \"lhs < rhs\" is true"]
    pub fn AIBinder_lt(lhs: *const AIBinder, rhs: *const AIBinder) -> bool;
}
extern "C" {
    #[doc = " Clone an AIBinder_Weak. Useful because even if a weak binder promotes to a\n null value, after further binder transactions, it may no longer promote to a\n null value.\n\n Available since API level 31.\n\n \\param weak Object to clone\n\n \\return clone of the input parameter. This must be deleted with\n AIBinder_Weak_delete. Null if weak input parameter is also null."]
    pub fn AIBinder_Weak_clone(weak: *const AIBinder_Weak) -> *mut AIBinder_Weak;
}
extern "C" {
    #[doc = " Whether AIBinder_Weak is less than another.\n\n This provides a per-process-unique total ordering of binders which is exactly\n the same as AIBinder_lt. Similarly, a null AIBinder_Weak* is considered to be\n ordered before all other weak references.\n\n This function correctly distinguishes binders even if one is deallocated. So,\n for instance, an AIBinder_Weak* entry representing a deleted binder will\n never compare as equal to an AIBinder_Weak* entry which represents a\n different allocation of a binder, even if the two binders were originally\n allocated at the same address. That is:\n\n     AIBinder* a = ...; // imagine this has address 0x8\n     AIBinder_Weak* bWeak = AIBinder_Weak_new(a);\n     AIBinder_decStrong(a); // a may be deleted, if this is the last reference\n     AIBinder* b = ...; // imagine this has address 0x8 (same address as b)\n     AIBinder_Weak* bWeak = AIBinder_Weak_new(b);\n\n Then when a/b are compared with other binders, their order will be preserved,\n and it will either be the case that AIBinder_Weak_lt(aWeak, bWeak) OR\n AIBinder_Weak_lt(bWeak, aWeak), but not both.\n\n Unlike AIBinder*, the AIBinder_Weak* addresses themselves have nothing to do\n with the underlying binder.\n\n Available since API level 31.\n\n \\param lhs comparison object\n \\param rhs comparison object\n\n \\return whether \"lhs < rhs\" is true"]
    pub fn AIBinder_Weak_lt(lhs: *const AIBinder_Weak, rhs: *const AIBinder_Weak) -> bool;
}
extern "C" {
    #[doc = " Makes calls to AIBinder_getCallingSid work if the kernel supports it. This\n must be called on a local binder server before it is sent out to any othe\n process. If this is a remote binder, it will abort. If the kernel doesn't\n support this feature, you'll always get null from AIBinder_getCallingSid.\n\n \\param binder local server binder to request security contexts on"]
    pub fn AIBinder_setRequestingSid(binder: *mut AIBinder, requestingSid: bool);
}
extern "C" {
    #[doc = " Returns the selinux context of the callee.\n\n In order for this to work, the following conditions must be met:\n - The kernel must be new enough to support this feature.\n - The server must have called AIBinder_setRequestingSid.\n - The callee must be a remote process.\n\n \\return security context or null if unavailable. The lifetime of this context\n is the lifetime of the transaction."]
    pub fn AIBinder_getCallingSid() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets a minimum scheduler policy for all transactions coming into this\n AIBinder.\n\n This must be called before the object is sent to another process.\n Aborts on invalid values. Not thread safe.\n\n \\param binder local server binder to set the policy for\n \\param policy scheduler policy as defined in linux UAPI\n \\param priority priority. [-20..19] for SCHED_NORMAL, [1..99] for RT"]
    pub fn AIBinder_setMinSchedulerPolicy(
        binder: *mut AIBinder,
        policy: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Allow the binder to inherit realtime scheduling policies from its caller.\n\n This must be called before the object is sent to another process. Not thread\n safe.\n\n \\param binder local server binder to set the policy for\n \\param inheritRt whether to inherit realtime scheduling policies (default is\n     false)."]
    pub fn AIBinder_setInheritRt(binder: *mut AIBinder, inheritRt: bool);
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AServiceManager_AddServiceFlag {
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_ALLOW_ISOLATED = 1,
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_DUMP_FLAG_PRIORITY_CRITICAL = 2,
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_DUMP_FLAG_PRIORITY_HIGH = 4,
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_DUMP_FLAG_PRIORITY_NORMAL = 8,
    #[doc = " This allows processes with AID_ISOLATED to get the binder of the service added.\n\n Services with methods that perform file IO, web socket creation or ways to egress data must\n not be added with this flag for privacy concerns."]
    ADD_SERVICE_DUMP_FLAG_PRIORITY_DEFAULT = 16,
}
extern "C" {
    #[doc = " This registers the service with the default service manager under this instance name. This does\n not take ownership of binder.\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n \\param binder object to register globally with the service manager.\n \\param instance identifier of the service. This will be used to lookup the service.\n\n \\return EX_NONE on success."]
    pub fn AServiceManager_addService(
        binder: *mut AIBinder,
        instance: *const ::std::os::raw::c_char,
    ) -> binder_exception_t;
}
extern "C" {
    #[doc = " This registers the service with the default service manager under this instance name. This does\n not take ownership of binder.\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n \\param binder object to register globally with the service manager.\n \\param instance identifier of the service. This will be used to lookup the service.\n \\param flags an AServiceManager_AddServiceFlag enum to denote how the service should be added.\n\n \\return EX_NONE on success."]
    pub fn AServiceManager_addServiceWithFlags(
        binder: *mut AIBinder,
        instance: *const ::std::os::raw::c_char,
        flags: AServiceManager_AddServiceFlag,
    ) -> binder_exception_t;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Will return nullptr immediately if the\n service is not available This also implicitly calls AIBinder_incStrong (so the caller of this\n function is responsible for calling AIBinder_decStrong).\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n \\param instance identifier of the service used to lookup the service."]
    pub fn AServiceManager_checkService(instance: *const ::std::os::raw::c_char) -> *mut AIBinder;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Blocks for a couple of seconds waiting on\n it. This also implicitly calls AIBinder_incStrong (so the caller of this function is responsible\n for calling AIBinder_decStrong). This does polling. A more efficient way to make sure you\n unblock as soon as the service is available is to use AIBinder_waitForService.\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n WARNING: when using this API, typically, you should call it in a loop. It's dangerous to\n assume that nullptr could mean that the service is not available. The service could just\n be starting. Generally, whether a service exists, this information should be declared\n externally (for instance, an Android feature might imply the existence of a service,\n a system property, or in the case of services in the VINTF manifest, it can be checked\n with AServiceManager_isDeclared).\n\n \\param instance identifier of the service used to lookup the service."]
    pub fn AServiceManager_getService(instance: *const ::std::os::raw::c_char) -> *mut AIBinder;
}
extern "C" {
    #[doc = " Registers a lazy service with the default service manager under the 'instance' name.\n Does not take ownership of binder.\n The service must be configured statically with init so it can be restarted with\n ctl.interface.* messages from servicemanager.\n AServiceManager_registerLazyService cannot safely be used with AServiceManager_addService\n in the same process. If one service is registered with AServiceManager_registerLazyService,\n the entire process will have its lifetime controlled by servicemanager.\n Instead, all services in the process should be registered using\n AServiceManager_registerLazyService.\n\n \\param binder object to register globally with the service manager.\n \\param instance identifier of the service. This will be used to lookup the service.\n\n \\return STATUS_OK on success."]
    pub fn AServiceManager_registerLazyService(
        binder: *mut AIBinder,
        instance: *const ::std::os::raw::c_char,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Gets a binder object with this specific instance name. Efficiently waits for the service.\n If the service is not ever registered, it will wait indefinitely. Requires the threadpool\n to be started in the service.\n This also implicitly calls AIBinder_incStrong (so the caller of this function is responsible\n for calling AIBinder_decStrong).\n\n WARNING: when using this API across an APEX boundary, do not use with unstable\n AIDL services. TODO(b/139325195)\n\n \\param instance identifier of the service used to lookup the service.\n\n \\return service if registered, null if not."]
    pub fn AServiceManager_waitForService(instance: *const ::std::os::raw::c_char)
        -> *mut AIBinder;
}
#[doc = " Function to call when a service is registered. The instance is passed as well as\n ownership of the binder named 'registered'.\n\n WARNING: a lock is held when this method is called in order to prevent races with\n AServiceManager_NotificationRegistration_delete. Do not make synchronous binder calls when\n implementing this method to avoid deadlocks.\n\n \\param instance instance name of service registered\n \\param registered ownership-passed instance of service registered\n \\param cookie data passed during registration for notifications"]
pub type AServiceManager_onRegister = ::std::option::Option<
    unsafe extern "C" fn(
        instance: *const ::std::os::raw::c_char,
        registered: *mut AIBinder,
        cookie: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Represents a registration to servicemanager which can be cleared anytime."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AServiceManager_NotificationRegistration {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get notifications when a service is registered. If the service is already registered,\n you will immediately get a notification.\n\n WARNING: it is strongly recommended to use AServiceManager_waitForService API instead.\n That API will wait synchronously, which is what you usually want in cases, including\n using some feature or during boot up. There is a history of bugs where waiting for\n notifications like this races with service startup. Also, when this API is used, a service\n bug will result in silent failure (rather than a debuggable deadlock). Furthermore, there\n is a history of this API being used to know when a service is up as a proxy for whethre\n that service should be started. This should only be used if you are intending to get\n ahold of the service as a client. For lazy services, whether a service is registered\n should not be used as a proxy for when it should be registered, which is only known\n by the real client.\n\n WARNING: if you use this API, you must also ensure that you check missing services are\n started and crash otherwise. If service failures are ignored, the system rots.\n\n \\param instance name of service to wait for notifications about\n \\param onRegister callback for when service is registered\n \\param cookie data associated with this callback\n\n \\return the token for this registration. Deleting this token will unregister."]
    pub fn AServiceManager_registerForServiceNotifications(
        instance: *const ::std::os::raw::c_char,
        onRegister: AServiceManager_onRegister,
        cookie: *mut ::std::os::raw::c_void,
    ) -> *mut AServiceManager_NotificationRegistration;
}
extern "C" {
    #[doc = " Unregister for notifications and delete the object.\n\n After this method is called, the callback is guaranteed to no longer be invoked. This will block\n until any in-progress onRegister callbacks have completed. It is therefore safe to immediately\n destroy the void* cookie that was registered when this method returns.\n\n \\param notification object to dismiss"]
    pub fn AServiceManager_NotificationRegistration_delete(
        notification: *mut AServiceManager_NotificationRegistration,
    );
}
extern "C" {
    #[doc = " Check if a service is declared (e.g. VINTF manifest).\n\n \\param instance identifier of the service.\n\n \\return true on success, meaning AServiceManager_waitForService should always\n    be able to return the service."]
    pub fn AServiceManager_isDeclared(instance: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Returns all declared instances for a particular interface.\n\n For instance, if 'android.foo.IFoo/foo' is declared, and 'android.foo.IFoo' is\n passed here, then [\"foo\"] would be returned.\n\n See also AServiceManager_isDeclared.\n\n \\param interface interface, e.g. 'android.foo.IFoo'\n \\param context to pass to callback\n \\param callback taking instance (e.g. 'foo') and context"]
    pub fn AServiceManager_forEachDeclaredInstance(
        interface: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Check if a service is updatable via an APEX module.\n\n \\param instance identifier of the service\n\n \\return whether the interface is updatable via APEX"]
    pub fn AServiceManager_isUpdatableViaApex(instance: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Returns the APEX name if a service is declared as updatable via an APEX module.\n\n \\param instance identifier of the service\n \\param context to pass to callback\n \\param callback taking the APEX name (e.g. 'com.android.foo') and context"]
    pub fn AServiceManager_getUpdatableApexName(
        instance: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Opens a declared passthrough HAL.\n\n \\param instance identifier of the passthrough service (e.g. \"mapper\")\n \\param instance identifier of the implemenatation (e.g. \"default\")\n \\param flag passed to dlopen()\n\n \\return the result of dlopen of the specified HAL"]
    pub fn AServiceManager_openDeclaredPassthroughHal(
        interface: *const ::std::os::raw::c_char,
        instance: *const ::std::os::raw::c_char,
        flag: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Prevent lazy services without client from shutting down their process\n\n This should only be used if it is every eventually set to false. If a\n service needs to persist but doesn't need to dynamically shut down,\n prefer to control it with another mechanism.\n\n \\param persist 'true' if the process should not exit."]
    pub fn AServiceManager_forceLazyServicesPersist(persist: bool);
}
extern "C" {
    #[doc = " Set a callback that is invoked when the active service count (i.e. services with clients)\n registered with this process drops to zero (or becomes nonzero).\n The callback takes a boolean argument, which is 'true' if there is\n at least one service with clients.\n\n \\param callback function to call when the number of services\n    with clients changes.\n \\param context opaque pointer passed back as second parameter to the\n callback.\n\n The callback takes two arguments. The first is a boolean that represents if there are\n services with clients (true) or not (false).\n The second is the 'context' pointer passed during the registration.\n\n Callback return value:\n - false: Default behavior for lazy services (shut down the process if there\n          are no clients).\n - true:  Don't shut down the process even if there are no clients.\n\n This callback gives a chance to:\n 1 - Perform some additional operations before exiting;\n 2 - Prevent the process from exiting by returning \"true\" from the callback."]
    pub fn AServiceManager_setActiveServicesCallback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: bool, arg2: *mut ::std::os::raw::c_void) -> bool,
        >,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Try to unregister all services previously registered with 'registerService'.\n\n \\return true on success."]
    pub fn AServiceManager_tryUnregister() -> bool;
}
extern "C" {
    #[doc = " Re-register services that were unregistered by 'tryUnregister'.\n This method should be called in the case 'tryUnregister' fails\n (and should be called on the same thread)."]
    pub fn AServiceManager_reRegister();
}
extern "C" {
    #[doc = " Gets whether or not FDs are allowed by this AParcel\n\n \\return true if FDs are allowed, false if they are not. That is\n if this returns false then AParcel_writeParcelFileDescriptor will\n return STATUS_FDS_NOT_ALLOWED."]
    pub fn AParcel_getAllowFds(arg1: *const AParcel) -> bool;
}
extern "C" {
    #[doc = " Data written to the parcel will be zero'd before being deleted or realloced.\n\n The main use of this is marking a parcel that will be used in a transaction\n with FLAG_CLEAR_BUF. When FLAG_CLEAR_BUF is used, the reply parcel will\n automatically be marked as sensitive when it is created.\n\n \\param parcel The parcel to clear associated data from."]
    pub fn AParcel_markSensitive(parcel: *const AParcel);
}
extern "C" {
    #[doc = " This creates a threadpool for incoming binder transactions if it has not already been created,\n spawning one thread, and allowing the kernel to lazily start threads according to the count\n that is specified in ABinderProcess_setThreadPoolMaxThreadCount.\n\n For instance, if ABinderProcess_setThreadPoolMaxThreadCount(3) is called,\n ABinderProcess_startThreadPool() is called (+1 thread) then the main thread calls\n ABinderProcess_joinThreadPool() (+1 thread), up to *5* total threads will be started\n (2 directly, and 3 more if the kernel starts them lazily).\n\n When using this, it is expected that ABinderProcess_setupPolling and\n ABinderProcess_handlePolledCommands are not used.\n\n Do not use this from a library. Apps setup their own threadpools, and otherwise, the main\n function should be responsible for configuring the threadpool for the entire application."]
    pub fn ABinderProcess_startThreadPool();
}
extern "C" {
    #[doc = " This sets the maximum number of threads that can be started in the threadpool. By default, after\n startThreadPool is called, this is 15. If it is called additional times, it will only prevent\n the kernel from starting new threads and will not delete already existing threads. This should\n be called once before startThreadPool. The number of threads can never decrease.\n\n This count refers to the number of threads that will be created lazily by the kernel, in\n addition to the single threads created by ABinderProcess_startThreadPool (+1) or\n ABinderProcess_joinThreadPool (+1). Note: ABinderProcess_startThreadPool starts a thread\n itself, but it also enables up to the number of threads passed to this function to start.\n This function does not start any threads itself; it only configures\n ABinderProcess_startThreadPool.\n\n Do not use this from a library. Apps setup their own threadpools, and otherwise, the main\n function should be responsible for configuring the threadpool for the entire application."]
    pub fn ABinderProcess_setThreadPoolMaxThreadCount(numThreads: u32) -> bool;
}
extern "C" {
    #[doc = " Check if the threadpool has already been started.\n This tells whether someone in the process has called ABinderProcess_startThreadPool. Usually,\n you should use this in a library to abort if the threadpool is not started.\n Programs should configure binder threadpools once at the beginning."]
    pub fn ABinderProcess_isThreadPoolStarted() -> bool;
}
extern "C" {
    #[doc = " This adds the current thread to the threadpool. This thread will be in addition to the thread\n configured with ABinderProcess_setThreadPoolMaxThreadCount and started with\n ABinderProcess_startThreadPool.\n\n Do not use this from a library. Apps setup their own threadpools, and otherwise, the main\n function should be responsible for configuring the threadpool for the entire application."]
    pub fn ABinderProcess_joinThreadPool();
}
extern "C" {
    #[doc = " This gives you an fd to wait on. Whenever data is available on the fd,\n ABinderProcess_handlePolledCommands can be called to handle binder queries.\n This is expected to be used in a single threaded process which waits on\n events from multiple different fds.\n\n When using this, it is expected ABinderProcess_startThreadPool and\n ABinderProcess_joinThreadPool are not used.\n\n \\param fd out param corresponding to the binder domain opened in this\n process.\n \\return STATUS_OK on success"]
    pub fn ABinderProcess_setupPolling(fd: *mut ::std::os::raw::c_int) -> binder_status_t;
}
extern "C" {
    #[doc = " This will handle all queued binder commands in this process and then return.\n It is expected to be called whenever there is data on the fd.\n\n \\return STATUS_OK on success"]
    pub fn ABinderProcess_handlePolledCommands() -> binder_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: __kernel_size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(::std::mem::size_of::<iovec>(), 16usize, concat!("Size of: ", stringify!(iovec)));
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(iovec), "::", stringify!(iov_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(iovec), "::", stringify!(iov_len))
    );
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(::std::mem::size_of::<msghdr>(), 56usize, concat!("Size of: ", stringify!(msghdr)));
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(msghdr), "::", stringify!(msg_name))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(msghdr), "::", stringify!(msg_namelen))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(msghdr), "::", stringify!(msg_iov))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(msghdr), "::", stringify!(msg_iovlen))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(msghdr), "::", stringify!(msg_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(msghdr), "::", stringify!(msg_controllen))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(msghdr), "::", stringify!(msg_flags))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<mmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mmsghdr>(),
        64usize,
        concat!("Size of: ", stringify!(mmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<mmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(mmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_hdr) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mmsghdr), "::", stringify!(msg_hdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_len) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(mmsghdr), "::", stringify!(msg_len))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cmsghdr), "::", stringify!(cmsg_len))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cmsghdr), "::", stringify!(cmsg_level))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(cmsghdr), "::", stringify!(cmsg_type))
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__msg: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_length: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept4(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_length: *mut socklen_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_length: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_length: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_length: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_length: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __option: ::std::os::raw::c_int,
        __value: *mut ::std::os::raw::c_void,
        __value_length: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        __fd: ::std::os::raw::c_int,
        __backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recvmmsg(
        __fd: ::std::os::raw::c_int,
        __msgs: *mut mmsghdr,
        __msg_count: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __msg: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendmmsg(
        __fd: ::std::os::raw::c_int,
        __msgs: *const mmsghdr,
        __msg_count: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __msg: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __option: ::std::os::raw::c_int,
        __value: *const ::std::os::raw::c_void,
        __value_length: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        __af: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __af: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __dst_addr: *const sockaddr,
        __dst_addr_length: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __src_addr: *mut sockaddr,
        __src_addr_length: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn __sendto_chk(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::std::os::raw::c_int,
        arg6: *const sockaddr,
        arg7: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn __recvfrom_chk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::std::os::raw::c_int,
        arg6: *mut sockaddr,
        arg7: *mut socklen_t,
    ) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ABinderRpc_Accessor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ABinderRpc_AccessorProvider {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ABinderRpc_ConnectionInfo {
    _unused: [u8; 0],
}
#[doc = " This callback is responsible for returning ABinderRpc_Accessor objects for a given\n service instance. These ABinderRpc_Accessor objects are implemented by\n libbinder_ndk and backed by implementations of android::os::IAccessor in\n libbinder.\n\n \\param instance name of the service like\n        `android.hardware.vibrator.IVibrator/default`. This string must remain\n        valid and unchanged for the duration of this function call.\n \\param data the data that was associated with this instance when the callback\n        was registered.\n \\return The ABinderRpc_Accessor associated with the service `instance`. This\n        callback gives up ownership of the object once it returns it. The\n        caller of this callback (libbinder_ndk) is responsible for deleting it\n        with ABinderRpc_Accessor_delete."]
pub type ABinderRpc_AccessorProvider_getAccessorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        instance: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ABinderRpc_Accessor,
>;
#[doc = " This callback is responsible deleting the `void* data` object that is passed\n in to ABinderRpc_registerAccessorProvider for the ABinderRpc_AccessorProvider_getAccessorCallback\n to use. That object is owned by the ABinderRpc_AccessorProvider and must remain valid for the\n lifetime of the callback because it may be called and use the object.\n This _delete callback is called after the ABinderRpc_AccessorProvider is remove and\n is guaranteed never to be called again.\n\n \\param data a pointer to data that the ABinderRpc_AccessorProvider_getAccessorCallback uses which\n is to be deleted by this call."]
pub type ABinderRpc_AccessorProviderUserData_deleteCallback =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Inject an ABinderRpc_AccessorProvider_getAccessorCallback into the process for\n the Service Manager APIs to use to retrieve ABinderRpc_Accessor objects associated\n with different RPC Binder services.\n\n \\param provider callback that returns ABinderRpc_Accessors for libbinder to set up\n        RPC clients with.\n \\param instances array of instances that are supported by this provider. It\n        will only be called if the client is looking for an instance that is\n        in this list. These instances must be unique per-process. If an\n        instance is being registered that was previously registered, this call\n        will fail and the ABinderRpc_AccessorProviderUserData_deleteCallback\n        will be called to clean up the data.\n        This array of strings must remain valid and unchanged for the duration\n        of this function call.\n \\param number of instances in the instances array.\n \\param data pointer that is passed to the ABinderRpc_AccessorProvider callback.\n        IMPORTANT: The ABinderRpc_AccessorProvider now OWNS that object that data\n        points to. It can be used as necessary in the callback. The data MUST\n        remain valid for the lifetime of the provider callback.\n        Do not attempt to give ownership of the same object to different\n        providers through multiple calls to this function because the first\n        one to be deleted will call the onDelete callback.\n \\param onDelete callback used to delete the objects that `data` points to.\n        This is called after ABinderRpc_AccessorProvider is guaranteed to never be\n        called again. Before this callback is called, `data` must remain\n        valid.\n \\return nullptr on error if the data pointer is non-null and the onDelete\n         callback is null or if an instance in the instances list was previously\n         registered. In the error case of duplicate instances, if data was\n         provided with a ABinderRpc_AccessorProviderUserData_deleteCallback,\n         the callback will be called to delete the data.\n         If nullptr is returned, ABinderRpc_AccessorProviderUserData_deleteCallback\n         will be called on data immediately.\n         Otherwise returns a pointer to the ABinderRpc_AccessorProvider that\n         can be used to remove with ABinderRpc_unregisterAccessorProvider."]
    pub fn ABinderRpc_registerAccessorProvider(
        provider: ABinderRpc_AccessorProvider_getAccessorCallback,
        instances: *const *const ::std::os::raw::c_char,
        numInstances: usize,
        data: *mut ::std::os::raw::c_void,
        onDelete: ABinderRpc_AccessorProviderUserData_deleteCallback,
    ) -> *mut ABinderRpc_AccessorProvider;
}
extern "C" {
    #[doc = " Remove an ABinderRpc_AccessorProvider from libbinder. This will remove references\n        from the ABinderRpc_AccessorProvider and will no longer call the\n        ABinderRpc_AccessorProvider_getAccessorCallback.\n\n Note: The `data` object that was used when adding the accessor will be\n       deleted by the ABinderRpc_AccessorProviderUserData_deleteCallback at some\n       point after this call. Do not use the object and do not try to delete\n       it through any other means.\n Note: This will abort when used incorrectly if this provider was never\n       registered or if it were already unregistered.\n\n \\param provider to be removed and deleted\n"]
    pub fn ABinderRpc_unregisterAccessorProvider(provider: *mut ABinderRpc_AccessorProvider);
}
#[doc = " Callback which returns the RPC connection information for libbinder to use to\n connect to a socket that a given service is listening on. This is needed to\n create an ABinderRpc_Accessor so it can connect to these services.\n\n \\param instance name of the service to connect to. This string must remain\n        valid and unchanged for the duration of this function call.\n \\param data user data for this callback. The pointer is provided in\n        ABinderRpc_Accessor_new.\n \\return ABinderRpc_ConnectionInfo with socket connection information for `instance`"]
pub type ABinderRpc_ConnectionInfoProvider = ::std::option::Option<
    unsafe extern "C" fn(
        instance: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ABinderRpc_ConnectionInfo,
>;
#[doc = " This callback is responsible deleting the `void* data` object that is passed\n in to ABinderRpc_Accessor_new for the ABinderRpc_ConnectionInfoProvider to use. That\n object is owned by the ABinderRpc_Accessor and must remain valid for the\n lifetime the Accessor because it may be used by the connection info provider\n callback.\n This _delete callback is called after the ABinderRpc_Accessor is removed and\n is guaranteed never to be called again.\n\n \\param data a pointer to data that the ABinderRpc_AccessorProvider uses which is to\n        be deleted by this call."]
pub type ABinderRpc_ConnectionInfoProviderUserData_delete =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Create a new ABinderRpc_Accessor. This creates an IAccessor object in libbinder\n that can use the info from the ABinderRpc_ConnectionInfoProvider to connect to a\n socket that the service with `instance` name is listening to.\n\n \\param instance name of the service that is listening on the socket. This\n        string must remain valid and unchanged for the duration of this\n        function call.\n \\param provider callback that can get the socket connection information for the\n           instance. This connection information may be dynamic, so the\n           provider will be called any time a new connection is required.\n \\param data pointer that is passed to the ABinderRpc_ConnectionInfoProvider callback.\n        IMPORTANT: The ABinderRpc_ConnectionInfoProvider now OWNS that object that data\n        points to. It can be used as necessary in the callback. The data MUST\n        remain valid for the lifetime of the provider callback.\n        Do not attempt to give ownership of the same object to different\n        providers through multiple calls to this function because the first\n        one to be deleted will call the onDelete callback.\n \\param onDelete callback used to delete the objects that `data` points to.\n        This is called after ABinderRpc_ConnectionInfoProvider is guaranteed to never be\n        called again. Before this callback is called, `data` must remain\n        valid.\n \\return an ABinderRpc_Accessor instance. This is deleted by the caller once it is\n         no longer needed."]
    pub fn ABinderRpc_Accessor_new(
        instance: *const ::std::os::raw::c_char,
        provider: ABinderRpc_ConnectionInfoProvider,
        data: *mut ::std::os::raw::c_void,
        onDelete: ABinderRpc_ConnectionInfoProviderUserData_delete,
    ) -> *mut ABinderRpc_Accessor;
}
extern "C" {
    #[doc = " Delete an ABinderRpc_Accessor\n\n \\param accessor to delete"]
    pub fn ABinderRpc_Accessor_delete(accessor: *mut ABinderRpc_Accessor);
}
extern "C" {
    #[doc = " Return the AIBinder associated with an ABinderRpc_Accessor. This can be used to\n send the Accessor to another process or even register it with servicemanager.\n\n \\param accessor to get the AIBinder for\n \\return binder of the supplied accessor with one strong ref count"]
    pub fn ABinderRpc_Accessor_asBinder(accessor: *mut ABinderRpc_Accessor) -> *mut AIBinder;
}
extern "C" {
    #[doc = " Return the ABinderRpc_Accessor associated with an AIBinder. The instance must match\n the ABinderRpc_Accessor implementation.\n This can be used when receiving an AIBinder from another process that the\n other process obtained from ABinderRpc_Accessor_asBinder.\n\n \\param instance name of the service that the Accessor is responsible for.\n        This string must remain valid and unchanged for the duration of this\n        function call.\n \\param accessorBinder proxy binder from another process's ABinderRpc_Accessor.\n        This function preserves the refcount of this binder object and the\n        caller still owns it.\n \\return ABinderRpc_Accessor representing the other processes ABinderRpc_Accessor\n         implementation. The caller owns this ABinderRpc_Accessor instance and\n         is responsible for deleting it with ABinderRpc_Accessor_delete or\n         passing ownership of it elsewhere, like returning it through\n         ABinderRpc_AccessorProvider_getAccessorCallback.\n         nullptr on error when the accessorBinder is not a valid binder from\n         an IAccessor implementation or the IAccessor implementation is not\n         associated with the provided instance."]
    pub fn ABinderRpc_Accessor_fromBinder(
        instance: *const ::std::os::raw::c_char,
        accessorBinder: *mut AIBinder,
    ) -> *mut ABinderRpc_Accessor;
}
extern "C" {
    #[doc = " Wrap an ABinderRpc_Accessor proxy binder with a delegator binder.\n\n The IAccessorDelegator binder delegates all calls to the proxy binder.\n\n This is required only in very specific situations when the process that has\n permissions to connect the to RPC service's socket and create the FD for it\n is in a separate process from this process that wants to serve the Accessor\n binder and the communication between these two processes is binder RPC. This\n is needed because the binder passed over the binder RPC connection can not be\n used as a kernel binder, and needs to be wrapped by a kernel binder that can\n then be registered with service manager.\n\n \\param instance name of the service associated with the Accessor\n \\param binder the AIBinder* from the ABinderRpc_Accessor from the\n        ABinderRpc_Accessor_asBinder. The other process across the binder RPC\n        connection will have called this and passed the AIBinder* across a\n        binder interface to the process calling this function.\n \\param outDelegator the AIBinder* for the kernel binder that wraps the\n        'binder' argument and delegates all calls to it. The caller now owns\n        this object with one strong ref count and is responsible for removing\n        that ref count with with AIBinder_decStrong when the caller wishes to\n        drop the reference.\n \\return STATUS_OK on success.\n         STATUS_UNEXPECTED_NULL if instance or binder arguments are null.\n         STATUS_BAD_TYPE if the binder is not an IAccessor.\n         STATUS_NAME_NOT_FOUND if the binder is an IAccessor, but not\n         associated with the provided instance name."]
    pub fn ABinderRpc_Accessor_delegateAccessor(
        instance: *const ::std::os::raw::c_char,
        binder: *mut AIBinder,
        outDelegator: *mut *mut AIBinder,
    ) -> binder_status_t;
}
extern "C" {
    #[doc = " Create a new ABinderRpc_ConnectionInfo with sockaddr. This can be supported socket\n types like sockaddr_vm (vsock) and sockaddr_un (Unix Domain Sockets).\n\n \\param addr sockaddr pointer that can come from supported socket\n        types like sockaddr_vm (vsock) and sockaddr_un (Unix Domain Sockets).\n \\param len length of the concrete sockaddr type being used. Like\n        sizeof(sockaddr_vm) when sockaddr_vm is used.\n \\return the connection info based on the given sockaddr"]
    pub fn ABinderRpc_ConnectionInfo_new(
        addr: *const sockaddr,
        len: socklen_t,
    ) -> *mut ABinderRpc_ConnectionInfo;
}
extern "C" {
    #[doc = " Delete an ABinderRpc_ConnectionInfo object that was created with\n ABinderRpc_ConnectionInfo_new.\n\n \\param info object to be deleted"]
    pub fn ABinderRpc_ConnectionInfo_delete(info: *mut ABinderRpc_ConnectionInfo);
}
#[doc = " Function to execute a shell command.\n\n Available since API level 30.\n\n \\param binder the binder executing the command\n \\param in input file descriptor, should be flushed, ownership is not passed\n \\param out output file descriptor, should be flushed, ownership is not passed\n \\param err error file descriptor, should be flushed, ownership is not passed\n \\param argv array of null-terminated strings for command (may be null if argc\n is 0)\n \\param argc length of argv array\n\n \\return binder_status_t result of transaction"]
pub type AIBinder_handleShellCommand = ::std::option::Option<
    unsafe extern "C" fn(
        binder: *mut AIBinder,
        in_: ::std::os::raw::c_int,
        out: ::std::os::raw::c_int,
        err: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
        argc: u32,
    ) -> binder_status_t,
>;
extern "C" {
    #[doc = " This sets the implementation of handleShellCommand for a class.\n\n If this isn't set, nothing will be executed when handleShellCommand is called.\n\n Available since API level 30.\n\n \\param handleShellCommand function to call when a shell transaction is\n received"]
    pub fn AIBinder_Class_setHandleShellCommand(
        clazz: *mut AIBinder_Class,
        handleShellCommand: AIBinder_handleShellCommand,
    );
}
extern "C" {
    #[doc = " This interface has the stability of the system image."]
    pub fn AIBinder_markSystemStability(binder: *mut AIBinder);
}
extern "C" {
    #[doc = " Given a binder interface at a certain stability, there may be some\n requirements associated with that higher stability level. For instance, a\n VINTF stability binder is required to be in the VINTF manifest. This API\n can be called to use that same interface within the system partition.\n\n WARNING: you must hold on to a binder instance after this is set, while you\n are using it. If you get a binder (e.g. `...->asBinder().get()`), you must\n save this binder and then\n use it. For instance:\n\n     auto binder = ...->asBinder();\n     AIBinder_forceDowngradeToSystemStability(binder.get());\n     doSomething(binder);"]
    pub fn AIBinder_forceDowngradeToSystemStability(binder: *mut AIBinder);
}
extern "C" {
    pub fn AIBinder_markVintfStability(binder: *mut AIBinder);
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum android_c_interface_StatusCode {
    OK = 0,
    UNKNOWN_ERROR = -2147483648,
    NO_MEMORY = -12,
    INVALID_OPERATION = -38,
    BAD_VALUE = -22,
    BAD_TYPE = -2147483647,
    NAME_NOT_FOUND = -2,
    PERMISSION_DENIED = -1,
    NO_INIT = -19,
    ALREADY_EXISTS = -17,
    DEAD_OBJECT = -32,
    FAILED_TRANSACTION = -2147483646,
    BAD_INDEX = -75,
    NOT_ENOUGH_DATA = -61,
    WOULD_BLOCK = -11,
    TIMED_OUT = -110,
    UNKNOWN_TRANSACTION = -74,
    FDS_NOT_ALLOWED = -2147483641,
    UNEXPECTED_NULL = -2147483640,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum android_c_interface_ExceptionCode {
    NONE = 0,
    SECURITY = -1,
    BAD_PARCELABLE = -2,
    ILLEGAL_ARGUMENT = -3,
    NULL_POINTER = -4,
    ILLEGAL_STATE = -5,
    NETWORK_MAIN_THREAD = -6,
    UNSUPPORTED_OPERATION = -7,
    SERVICE_SPECIFIC = -8,
    PARCELABLE = -9,
    #[doc = " This is special, and indicates to native binder proxies that the\n transaction has failed at a low level."]
    TRANSACTION_FAILED = -129,
}
pub const FIRST_CALL_TRANSACTION: android_c_interface_consts__bindgen_ty_1 = 1;
pub const LAST_CALL_TRANSACTION: android_c_interface_consts__bindgen_ty_1 = 16777215;
pub type android_c_interface_consts__bindgen_ty_1 = ::std::os::raw::c_uint;
pub const FLAG_ONEWAY: android_c_interface_consts__bindgen_ty_2 = 1;
pub const FLAG_CLEAR_BUF: android_c_interface_consts__bindgen_ty_2 = 32;
pub const FLAG_PRIVATE_LOCAL: android_c_interface_consts__bindgen_ty_2 = 0;
pub type android_c_interface_consts__bindgen_ty_2 = ::std::os::raw::c_uint;
