# Copyright 2024 Mist Tecnologia LTDA. All rights reserved.
# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/config/build_api_module.gni")
import("//build/config/compiler.gni")
import("//build/rust/config.gni")
import("//build/testing/validated_test_types_group.gni")
import("//build/toolchain/zircon/clang.gni")
import("//build/zbi/zbi.gni")

declare_args() {
  # Host-only tests.  These cannot have any dependency on an assembled platform
  # image, or the compiled OS itself, not even for their host_test_data().
  #
  # These will be added to the build using the host toolchain.
  host_test_labels = []

  # If you add labels to this variable, these will be included in the 'host'
  # artifact set, which represents an additional set of host-only software that
  # is produced by the build.
  #
  # These will be added to the build using the host toolchain.
  host_labels = []

  # Platform builders can add targets to this list so that they get built with
  # the //:default target
  additional_default_targets = []

  # These labels are added as dependencies of '//:default' transitively via
  # '//:build_only'.  These are used to add targets that need to be built
  # but aren't part of any product, board, etc.
  #
  # These also serve as an alternative to '//:default' for sub-builds that
  # only want to build and define a small subset of the tree.
  build_only_labels = []
}

if (host_os == "mac") {
  import("//build/config/mac/mac_sdk.gni")
}

assert(
    current_toolchain == default_toolchain,
    "The root build file (//BUILD.gn) can only be processed in the `default_toolchain`.")

###
### fx integration.
###

# Write a file that can be sourced by `fx`.  This file is produced
# by `gn gen` and is not known to Ninja at all, so it has nothing to
# do with the build itself.  Its sole purpose is to leave bread
# crumbs about the settings `gn gen` used for `fx` to use later.
_relative_build_dir = rebase_path(root_build_dir, "//", "//")
_host_out_dir = rebase_path(host_out_dir, root_build_dir)
_fx_config_lines = [
  "# Generated by `gn gen`.",
  "FUCHSIA_BUILD_DIR='${_relative_build_dir}'",
  "FUCHSIA_ARCH='${target_cpu}'",
  "FUCHSIA_ZBI_COMPRESSION=zstd",
  "HOST_OUT_DIR='${_host_out_dir}'",
]
write_file("$root_build_dir/fx.config", _fx_config_lines)
generated_file("default_toolchain_name.txt") {
  outputs = [ "$root_build_dir/default_toolchain_name.txt" ]
  contents = default_toolchain
}

###
### Build API modules.
###

# This is the top-level build API module that just lists all the others.
# Each element of the list is the simple name of the API module; the
# module's contents are found at "$root_build_dir/$target_name.json".
#
# Type: list(string)
#
build_api_module("api") {
  testonly = true
  data_keys = [ "build_api_modules" ]
  deps = [
    ":args",
    ":tests",
    ":tool_paths",
    "//build/rbe:rbe_settings.json",
  ]
}

# This target is used to generate, at `gn gen` time a file
# that is exclusively used by //build/api/client.py.
# NOTE: nothing should depend on this target.
generated_file("build_api_client_info") {
  deps = [ "//:api" ]
  outputs = [ "$root_build_dir/build_api_client_info" ]
  data_keys = [ "build_api_client_info" ]
  walk_keys = [ "build_api_client_info_barrier" ]
  testonly = true
  visibility = []  # Empty on purpose
}

# TODO(crbug.com/gn/132): Remove when GN emits the equivalent information
# itself.
#
# in file: "$root_build_dir/args.json"
#
# This just regurgitates the build arguments specified to `gn gen`.  This is
# the exact JSON representation of the settings in "$root_build_dir/args.gn".
# It does not include build arguments left to their default values.  So to
# reproduce the settings of this build, one could put in `args.gn`:
# ```
#   forward_variables_from(read_file("args.json", "json"), "*")
# ```
# Type: scope
#
build_api_module("args") {
  contents = read_file("$root_build_dir/args.gn", "scope")
}

# Tests in the build.
#
#  Below, the "testing root" refers to $root_build_dir on host, and the full
#  filesystem path from the root on device.
#
#  This rule outputs the tests.json file in the build directory,
#  which is aggregated at test time.
#
#  The format is documented at
#  https://fuchsia.dev/fuchsia-src/reference/testing/tests-json-format
#
# Type: list(scope)
#
#   * name
#     - Required: Name of test.
#     - Type: string
#
#   * label
#     - Required: GN label associated with the test
#     - Type: label_with_toolchain
#
#   * path
#     - Required: Path to the test's executable.
#     - Type: path relative to the testing root.
#
#   * cpu, os
#     - Required: cpu and os values, respectively, for which this test is
#       intended. Defaults to $current_cpu and $current_os if not manually
#       specified.
#     - Type: string
#
#   * disabled
#     - Optional: a free-form string indicating a reason for the test being
#       disabled.
#     - Type: string
#
#   * runtime_deps
#     - Optional: a JSON file containing a list of root_build_dir-relative
#       paths defining ascribed runtime dependencies of the test. These
#       dependencies are aggregated via the metadata graph of the associated
#       test target under a data key of "test_runtime_deps.
#     - Type: path relative to root_build_dir
#
#   * isolated
#     - Optional: whether the test needs to be run in isolation to other tests.
#     - Type: bool
#
#   * timeout_secs
#     - Optional: the timeout in seconds for the test.
#     - Type: int
#
build_api_module("tests") {
  testonly = true
  data_keys = [ "tests" ]
  walk_keys = [ "tests_barrier" ]
  deps = [
    # Pull in tests from host_labels.  This is deprecated, and tests should be
    # in //:host_tests instead.
    "//:host",

    # Pull in tests from the non-device type-specific test groups.
    "//:host_tests",
  ]
}

# Tools provided by the build or as prebuilts, to be used outside the build.
#
# Type: list(scope)
#
#   * name
#     - Required: Name of a host tool.
#     - Type: string
#
#   * label
#     - Required: GN label associated with the tool.
#     - Type: label_with_toolchain
#
#   * path
#     - Required: Path to the tool's executable for the build host.
#     - Type: path relative to $root_build_dir
#
#   * cpu, os
#     - Required: $current_cpu and $current_os values, respectively, for
#       which this tool is intended.
#     - Type: string
#
#   * runtime_files
#     - Optional: Path to files that are also required for the tool to function
#       (must also be built by `label`).
#     - Type: path relative to $root_build_dir
build_api_module("tool_paths") {
  testonly = true
  data_keys = [ "tool_paths" ]
  walk_keys = [ "tool_barrier" ]

  # Disable automatic sorting and grouping to ensure comments are associated
  # with only the intended lines.
  #
  # NOSORT
  deps = [
    # Pull in tools from host_labels.
    ":host",

    # ffx is used as part of the top-level build for every product configuration
    # so should always be included in the tools manifest.
    #"//src/developer/ffx($host_toolchain)",

    "//build/rust:tool_paths.llvm-profdata-rust($host_toolchain)",
    ":tool_paths.llvm-tools",
    ":tool_paths.metadata",

    #"//build/images/updates:packages",
    #"//src/sys/pkg/tests/system-tests:system_tests_tools($host_toolchain)",
    #"//src/storage/bin/fvm($host_toolchain)",
    "//third_party/cobalt/src/bin/config_change_validator/src:bin($host_toolchain)",
    "//third_party/cobalt/src/bin/config_parser/src:bin($host_toolchain)",

    #"//tools/doc_checker($host_toolchain)",
    "//tools/fidl:fidl-lint($host_toolchain)",
    "//tools/fidl:fidlfmt($host_toolchain)",
    "//tools/fidl/fidlc:host($host_toolchain)",

    #"//zircon/third_party/uapp/mkfs-msdosfs($host_toolchain)",
    #"//src/storage/blobfs/tools:blobfs($host_toolchain)",
    "//zircon/tools/lz4($host_toolchain)",

    #"//zircon/tools/merkleroot($host_toolchain)",
    #"//src/storage/minfs/tools:minfs($host_toolchain)",
    #"//zircon/tools/xdc-server($host_toolchain)",
    "//zircon/tools/zbi($host_toolchain)",
    "//zircon/tools/zither($host_toolchain)",
  ]
}

group("tool_paths.metadata") {
  visibility = [ ":tool_paths" ]
  prebuilt_tools = [
    "$rustc_prefix/bin/cargo",
    "$rustc_prefix/bin/rustc",
    "$rustc_prefix/bin/rustdoc",
    "$rustc_prefix/bin/rustfmt",

    #"//src/testing/perfcompare",

    # reclient is using fairly generic names (bootstrap, dumpstats). We may
    # need to move these into their own group() at some point to namespace
    # them.
    #"//prebuilt/proprietary/third_party/reclient/$host_platform/bootstrap",
    #"//prebuilt/proprietary/third_party/reclient/$host_platform/dumpstats",
    #"//prebuilt/proprietary/third_party/reclient/$host_platform/reproxy",
    #"//prebuilt/proprietary/third_party/reclient/$host_platform/rewrapper",
    #"//prebuilt/sdk/bazel/bazel",
    #"//prebuilt/third_party/buildifier/$host_platform/buildifier",
    "//prebuilt/third_party/clang/$host_platform/share/clang/clang-format-diff.py",
    "//prebuilt/third_party/clang/$host_platform/share/clang/clang-tidy-diff.py",

    #"//prebuilt/third_party/dart/$host_platform/bin/dart",
    "//prebuilt/third_party/gn/$host_platform/gn",
    "//prebuilt/third_party/go/$host_platform/bin/go",
    "//prebuilt/third_party/go/$host_platform/bin/gofmt",
    "//prebuilt/third_party/ninja/$host_platform/ninja",
    "//prebuilt/third_party/python3/$host_platform/bin/python3",
    "//prebuilt/tools/shac/shac",

    #"//third_party/catapult/tracing/bin/trace2html",
  ]

  renamed_prebuilt_tools = [
    # Rename prebuilt buildstats to avoid conflict with the buildstats go_binary
    # when they are both included in the build graph.
    {
      name = "buildstats_prebuilt"
      path = "//prebuilt/tools/buildstats/$host_platform/buildstats"
    },

    # Rename prebuilt ninjatrace to avoid conflict with the ninjatrace go_binary
    # when they are both included in the build graph.
    {
      name = "ninjatrace_prebuilt"
      path = "//prebuilt/tools/ninjatrace/$host_platform/ninjatrace"
    },
  ]

  metadata = {
    tool_paths = []
    foreach(tool, prebuilt_tools) {
      tool_paths += [
        {
          cpu = host_cpu
          label = get_label_info(":$target_name", "label_with_toolchain")
          name = get_path_info(tool, "name")
          os = host_os
          path = rebase_path(tool, root_build_dir)
        },
      ]
    }
    foreach(renamed_tool, renamed_prebuilt_tools) {
      tool_paths += [
        {
          cpu = host_cpu
          label = get_label_info(":$target_name", "label_with_toolchain")
          name = renamed_tool.name
          os = host_os
          path = rebase_path(renamed_tool.path, root_build_dir)
        },
      ]
    }

    # Add SSH prebuilts to the tool paths. We need both architectures regardless
    # of the host architectures since it's used on test bots that may be running
    # ARM64 (even if we built on x64).
    foreach(arch,
            [
              "arm64",
              "x64",
            ]) {
      tool_paths += [
        {
          cpu = arch
          label = get_label_info(
                  "//prebuilt/third_party/openssh-portable/linux-${arch}/bin/ssh",
                  "label_with_toolchain")
          name = get_path_info(
                  "//prebuilt/third_party/openssh-portable/linux-${arch}/bin/ssh",
                  "name")
          os = "linux"
          path = rebase_path(
                  "//prebuilt/third_party/openssh-portable/linux-${arch}/bin/ssh",
                  root_build_dir)
        },
      ]
    }
  }
}

group("tool_paths.llvm-tools") {
  visibility = [ ":tool_paths" ]
  _llvm_tools = [
    "clang",
    "clang++",
    "clang-doc",
    "clang-format",
    "clang-include-fixer",
    "clang-refactor",
    "clang-tidy",
    "clangd",
    "llvm-cov",
    "llvm-cxxfilt",
    "llvm-dwp",
    "llvm-objcopy",
    "llvm-profdata",
    "llvm-readelf",
    "llvm-size",
    "llvm-strip",
    "llvm-symbolizer",
    "llvm-xray",
    "sancov",
  ]
  metadata = {
    tool_paths = []
    foreach(tool, _llvm_tools) {
      tool_paths += [
        {
          cpu = host_cpu
          label = get_label_info(":$target_name", "label_with_toolchain")
          name = tool
          os = host_os
          path = rebase_path("$clang_tool_dir/$tool", root_build_dir)
        },
      ]
    }

    # Add the arm64 version of llvm-profdata to tool_paths for use by the arm64
    # coverage builder.
    if (target_cpu == "arm64" && host_platform == "linux-x64" && is_coverage) {
      tool_paths += [
        {
          cpu = target_cpu
          label = get_label_info(":$target_name", "label_no_toolchain") +
                  "($host_arm64_toolchain)"
          name = "llvm-profdata"
          os = host_os
          path = rebase_path(
                  "//prebuilt/third_party/clang/linux-arm64/bin/llvm-profdata",
                  root_build_dir)
        },
      ]
    }
  }
}

###
### Top-level targets.
###
group("default") {
  testonly = true
  deps = [
    "//:build_only",
    "//:host",
    "//zircon/kernel:boot_tests",

    # Produce Fuchsia libs zbi tests
    #"//src/lib/fuchsia:tests",
    #"//src/lib/fuchsia-runtime:tests",
    #"//src/lib/process_builder:tests",
    #"//src/lib/zircon:tests",
    #"//src/storage/lib/vfs/rust:tests",
    #"//src/sys/lib/elf_runner:tests",

    # Produce mist-os libs zbi tests
    #"//src/lib/mistos-bootfs:tests",
    #"//src/lib/mistos-logger:tests",
    #"//src/starnix_lite:tests",
    #"//src/starnix_lite",

    #"//src/starnix_lite/lib/usercopy:tests",

    # Host tools tests
    #"//zircon/tools:tests",

    # Generate ZBIs used to run on target
    "//build/images/mistos",

    # Mist Technologies
    "//vendor/misttech/zircon/kernel/lib/linux-rt",
    "//vendor/misttech/zircon/kernel/lib/starnix/examples",
  ]

  # Add any additional targets from the product.
  deps += additional_default_targets
}

###
# The build-only group.  These are additional targets to add to the build but
# are not part of a product, board, or host tools.  This group also serves as
# an alternative to '//:default' when performing sub-builds.
group("build_only") {
  testonly = true
  deps = build_only_labels
}

# Host-only tests.  These cannot have any dependency on an assembled platform
# image, or the compiled OS itself, not even for their host_test_data().
validated_test_types_group("host_tests") {
  testonly = true
  visibility = [ ":*" ]
  allowed_test_types = [ "host_only" ]

  deps = []
  foreach(label, host_test_labels) {
    # Strip any toolchain that is provided, and replace with the host toolchain.
    full_label = get_label_info(label, "label_no_toolchain")
    deps += [ "$full_label($host_toolchain)" ]
  }
}

###
# GN-Argument configured groups for host binaries and tools
#

group("host") {
  # TODO(https://fxbug.dev/42160904) investigate removing testonly here
  testonly = true
  public_deps = [
    #"//build/input/product:host($host_toolchain)",

    # Static analysis tools used by shac should always be built so that
    # `fx format-code` and other static analysis entrypoints can be run on any
    # build configuration.
    "//bundles/tools/shac:shac_tools",

    # Host tests for //build/api/client
    "//build/api:tests",

    # Tools & tests added by the developer
    ":developer_host_tools",
  ]
}

# WARNING: Known to infrastructure
#
# This group creates a single ninja build target that can create all targets
# specified by `host_labels` with `fx build :developer_host_tools`
group("developer_host_tools") {
  testonly = true
  public_deps = []

  foreach(label, host_labels) {
    # Strip any toolchain that is provided, and replace with the host toolchain.
    full_label = get_label_info(label, "label_no_toolchain")
    public_deps += [ "$full_label($host_toolchain)" ]
  }
}

# A GN pool matching the special Ninja 'console' pool. Any action() that
# uses this pool will be able to send its stdout/stderr directly to the
# output terminal, instead of being buffered by Ninja until the command
# completes.
#
# This is very useful for long-running commands, e.g. bazel build invocations
# that can take several dozen seconds to complete, or any other command that
# prints a _lot_ of output, because our infra bots will timeout if Ninja tries
# to print too much data at once after command completion for some undetermined
# reason.
#
pool("console") {
  depth = 1
}
